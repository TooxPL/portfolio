(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors"],{

/***/ "+PHv":
/*!********************************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/var/rcheckableType.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return /^(?:checkbox|radio)$/i;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "+aR0":
/*!*************************************************************!*\
  !*** ./node_modules/jquery/src/var/ObjectFunctionString.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./fnToString */ "HATn")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (fnToString) {
  "use strict";

  return fnToString.call(Object);
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "+y+W":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/core/DOMEval.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/document */ "iprW")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (document) {
  "use strict";

  var preservedScriptAttributes = {
    type: true,
    src: true,
    noModule: true
  };

  function DOMEval(code, doc, node) {
    doc = doc || document;
    var i,
        script = doc.createElement("script");
    script.text = code;

    if (node) {
      for (i in preservedScriptAttributes) {
        if (node[i]) {
          script[i] = node[i];
        }
      }
    }

    doc.head.appendChild(script).parentNode.removeChild(script);
  }

  return DOMEval;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "/vyx":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/ajax/var/nonce.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return Date.now();
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "06dU":
/*!*****************************************!*\
  !*** ./node_modules/jquery/src/ajax.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./var/document */ "iprW"), __webpack_require__(/*! ./var/isFunction */ "s44h"), __webpack_require__(/*! ./var/rnothtmlwhite */ "VK0Q"), __webpack_require__(/*! ./ajax/var/location */ "ZI4A"), __webpack_require__(/*! ./ajax/var/nonce */ "/vyx"), __webpack_require__(/*! ./ajax/var/rquery */ "Dc8T"), __webpack_require__(/*! ./core/init */ "MsD2"), __webpack_require__(/*! ./ajax/parseXML */ "kRrN"), __webpack_require__(/*! ./event/trigger */ "l58E"), __webpack_require__(/*! ./deferred */ "G5n7"), __webpack_require__(/*! ./serialize */ "xrz1") // jQuery.param
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document, isFunction, rnothtmlwhite, location, nonce, rquery) {
  "use strict";

  var r20 = /%20/g,
      rhash = /#.*$/,
      rantiCache = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      // #7653, #8125, #8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},
      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  allTypes = "*/".concat("*"),
      // Anchor tag for parsing the document origin
  originAnchor = document.createElement("a");
  originAnchor.href = location.href; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

  function addToPrefiltersOrTransports(structure) {
    // dataTypeExpression is optional and defaults to "*"
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }

      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

      if (isFunction(func)) {
        // For each dataType in the dataTypeExpression
        while (dataType = dataTypes[i++]) {
          // Prepend if requested
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  } // Base inspection function for prefilters and transports


  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = structure === transports;

    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }

    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  } // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887


  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }

    if (deep) {
      jQuery.extend(true, target, deep);
    }

    return target;
  }
  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */


  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

    while (dataTypes[0] === "*") {
      dataTypes.shift();

      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    } // Check if we're dealing with a known content-type


    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    } // Check to see if we have a response for the expected dataType


    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }

        if (!firstDataType) {
          firstDataType = type;
        }
      } // Or just use first one


      finalDataType = finalDataType || firstDataType;
    } // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response


    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }

      return responses[finalDataType];
    }
  }
  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */


  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }

    current = dataTypes.shift(); // Convert to each sequential dataType

    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      } // Apply the dataFilter if provided


      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }

      prev = current;
      current = dataTypes.shift();

      if (current) {
        // There's only work to do if current dataType is non-auto
        if (current === "*") {
          current = prev; // Convert response if prev dataType is non-auto and differs from current
        } else if (prev !== "*" && prev !== current) {
          // Seek a direct converter
          conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

          if (!conv) {
            for (conv2 in converters) {
              // If conv2 outputs current
              tmp = conv2.split(" ");

              if (tmp[1] === current) {
                // If prev can be converted to accepted input
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

                if (conv) {
                  // Condense equivalence converters
                  if (conv === true) {
                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }

                  break;
                }
              }
            }
          } // Apply converter (if not an equivalence)


          if (conv !== true) {
            // Unless errors are allowed to bubble, catch and return them
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }

    return {
      state: "success",
      data: response
    };
  }

  jQuery.extend({
    // Counter for holding the number of active queries
    active: 0,
    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",

      /*
      timeout: 0,
      data: null,
      dataType: null,
      username: null,
      password: null,
      cache: null,
      throws: false,
      traditional: false,
      headers: {},
      */
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      // Data converters
      // Keys separate source (or catchall "*") and destination types with a single space
      converters: {
        // Convert anything to text
        "* text": String,
        // Text to html (true = no transformation)
        "text html": true,
        // Evaluate text as a json expression
        "text json": JSON.parse,
        // Parse text as xml
        "text xml": jQuery.parseXML
      },
      // For options that shouldn't be deep extended:
      // you can add your own custom options here if
      // and when you create one that shouldn't be
      // deep extended (see ajaxExtend)
      flatOptions: {
        url: true,
        context: true
      }
    },
    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function (target, settings) {
      return settings ? // Building a settings object
      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
      ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    // Main method
    ajax: function (url, options) {
      // If url is an object, simulate pre-1.5 signature
      if (typeof url === "object") {
        options = url;
        url = undefined;
      } // Force options to be an object


      options = options || {};
      var transport,
          // URL without anti-cache param
      cacheURL,
          // Response headers
      responseHeadersString,
          responseHeaders,
          // timeout handle
      timeoutTimer,
          // Url cleanup var
      urlAnchor,
          // Request state (becomes false upon send and true upon completion)
      completed,
          // To know if global events are to be dispatched
      fireGlobals,
          // Loop variable
      i,
          // uncached part of the url
      uncached,
          // Create the final options object
      s = jQuery.ajaxSetup({}, options),
          // Callbacks context
      callbackContext = s.context || s,
          // Context for global events is callbackContext if it is a DOM node or jQuery collection
      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          // Deferreds
      deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          // Status-dependent callbacks
      statusCode = s.statusCode || {},
          // Headers (they are sent all at once)
      requestHeaders = {},
          requestHeadersNames = {},
          // Default abort message
      strAbort = "canceled",
          // Fake xhr
      jqXHR = {
        readyState: 0,
        // Builds headers hashtable if needed
        getResponseHeader: function (key) {
          var match;

          if (completed) {
            if (!responseHeaders) {
              responseHeaders = {};

              while (match = rheaders.exec(responseHeadersString)) {
                responseHeaders[match[1].toLowerCase()] = match[2];
              }
            }

            match = responseHeaders[key.toLowerCase()];
          }

          return match == null ? null : match;
        },
        // Raw string
        getAllResponseHeaders: function () {
          return completed ? responseHeadersString : null;
        },
        // Caches the header
        setRequestHeader: function (name, value) {
          if (completed == null) {
            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
            requestHeaders[name] = value;
          }

          return this;
        },
        // Overrides response content-type header
        overrideMimeType: function (type) {
          if (completed == null) {
            s.mimeType = type;
          }

          return this;
        },
        // Status-dependent callbacks
        statusCode: function (map) {
          var code;

          if (map) {
            if (completed) {
              // Execute the appropriate callbacks
              jqXHR.always(map[jqXHR.status]);
            } else {
              // Lazy-add the new callbacks in a way that preserves old ones
              for (code in map) {
                statusCode[code] = [statusCode[code], map[code]];
              }
            }
          }

          return this;
        },
        // Cancel the request
        abort: function (statusText) {
          var finalText = statusText || strAbort;

          if (transport) {
            transport.abort(finalText);
          }

          done(0, finalText);
          return this;
        }
      }; // Attach deferreds

      deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)
      // Handle falsy url in the settings object (#10093: consistency with old signature)
      // We also use the url parameter if available

      s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"); // Alias method option to type as per ticket #12004

      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""]; // A cross-domain request is in order when the origin doesn't match the current origin.

      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a"); // Support: IE <=8 - 11, Edge 12 - 15
        // IE throws exception on accessing the href property if url is malformed,
        // e.g. http://example.com:80x/

        try {
          urlAnchor.href = s.url; // Support: IE <=8 - 11 only
          // Anchor's host property isn't correctly set when s.url is relative

          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          // If there is an error parsing the URL, assume it is crossDomain,
          // it can be rejected by the transport if it is invalid
          s.crossDomain = true;
        }
      } // Convert data if not already a string


      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      } // Apply prefilters


      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

      if (completed) {
        return jqXHR;
      } // We can fire global events as of now if asked to
      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)


      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      } // Uppercase the type


      s.type = s.type.toUpperCase(); // Determine if request has content

      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on
      // Remove hash to simplify url manipulation

      cacheURL = s.url.replace(rhash, ""); // More options handling for requests with no content

      if (!s.hasContent) {
        // Remember the hash so we can put it back
        uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url

        if (s.data && (s.processData || typeof s.data === "string")) {
          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data; // #9682: remove data so that it's not used in an eventual retry

          delete s.data;
        } // Add or update anti-cache param if needed


        if (s.cache === false) {
          cacheURL = cacheURL.replace(rantiCache, "$1");
          uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached;
        } // Put hash and anti-cache on the URL that will be requested (gh-1732)


        s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)
      } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
        s.data = s.data.replace(r20, "+");
      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }

        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      } // Set the correct header, if data is being sent


      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      } // Set the Accepts header for the server, depending on the dataType


      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      } // Allow custom headers/mimetypes and early abort


      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
        // Abort if not done already and return
        return jqXHR.abort();
      } // Aborting is no longer a cancellation


      strAbort = "abort"; // Install callbacks on deferreds

      completeDeferred.add(s.complete);
      jqXHR.done(s.success);
      jqXHR.fail(s.error); // Get transport

      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1; // Send global event

        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        } // If request was aborted inside ajaxSend, stop there


        if (completed) {
          return jqXHR;
        } // Timeout


        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function () {
            jqXHR.abort("timeout");
          }, s.timeout);
        }

        try {
          completed = false;
          transport.send(requestHeaders, done);
        } catch (e) {
          // Rethrow post-completion exceptions
          if (completed) {
            throw e;
          } // Propagate others as results


          done(-1, e);
        }
      } // Callback for when everything is done


      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText; // Ignore repeat invocations

        if (completed) {
          return;
        }

        completed = true; // Clear timeout if it exists

        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        } // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)


        transport = undefined; // Cache response headers

        responseHeadersString = headers || ""; // Set readyState

        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        } // Convert no matter what (that way responseXXX fields are always set)


        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

        if (isSuccess) {
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");

            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }

            modified = jqXHR.getResponseHeader("etag");

            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          } // if no content


          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent"; // if not modified
          } else if (status === 304) {
            statusText = "notmodified"; // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          // Extract error from statusText and normalize for non-aborts
          error = statusText;

          if (status || !statusText) {
            statusText = "error";

            if (status < 0) {
              status = 0;
            }
          }
        } // Set data for the fake xhr object


        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        } // Status-dependent callbacks


        jqXHR.statusCode(statusCode);
        statusCode = undefined;

        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        } // Complete


        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

          if (! --jQuery.active) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }

      return jqXHR;
    },
    getJSON: function (url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function (url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function (i, method) {
    jQuery[method] = function (url, data, callback, type) {
      // Shift arguments if data argument was omitted
      if (isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      } // The url can be an options object (which then must have .url)


      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "06pk":
/*!*********************************************!*\
  !*** ./node_modules/jquery/src/ajax/xhr.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../var/support */ "hFd1"), __webpack_require__(/*! ../ajax */ "06dU")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, support) {
  "use strict";

  jQuery.ajaxSettings.xhr = function () {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };

  var xhrSuccessStatus = {
    // File protocol always yields status code 0, assume 200
    0: 200,
    // Support: IE <=9 only
    // #1450: sometimes IE returns 1223 when it should be 204
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest

    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function (headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          } // Override mime type if needed


          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          } // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.


          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          } // Set headers


          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          } // Callback


          callback = function (type) {
            return function () {
              if (callback) {
                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;

                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  // Support: IE <=9 only
                  // On a manual native abort, IE9 throws
                  // errors on any property access that is not readyState
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete( // File: protocol always yields status 0; see #8605, #14207
                    xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                  // IE9 has no XHR2 but throws on binary (trac-11426)
                  // For XHR2 non-text, let the caller handle it (gh-2498)
                  (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                    binary: xhr.response
                  } : {
                    text: xhr.responseText
                  }, xhr.getAllResponseHeaders());
                }
              }
            };
          }; // Listen to events


          xhr.onload = callback();
          errorCallback = xhr.onerror = xhr.ontimeout = callback("error"); // Support: IE 9 only
          // Use onreadystatechange to replace onabort
          // to handle uncaught aborts

          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function () {
              // Check readyState before timeout as it changes
              if (xhr.readyState === 4) {
                // Allow onerror to be called first,
                // but that will not handle a native abort
                // Also, save errorCallback to a variable
                // as xhr.onerror cannot be accessed
                window.setTimeout(function () {
                  if (callback) {
                    errorCallback();
                  }
                });
              }
            };
          } // Create the abort callback


          callback = callback("abort");

          try {
            // Do send the request (this may raise an exception)
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            // #14683: Only rethrow if this hasn't been notified as an error yet
            if (callback) {
              throw e;
            }
          }
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "082X":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/data/var/dataPriv.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../Data */ "Wwic")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Data) {
  "use strict";

  return new Data();
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "0VMG":
/*!******************************************!*\
  !*** ./node_modules/jquery/src/queue.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./data/var/dataPriv */ "082X"), __webpack_require__(/*! ./deferred */ "G5n7"), __webpack_require__(/*! ./callbacks */ "hX6M")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, dataPriv) {
  "use strict";

  jQuery.extend({
    queue: function (elem, type, data) {
      var queue;

      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

        if (data) {
          if (!queue || Array.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }

        return queue || [];
      }
    },
    dequeue: function (elem, type) {
      type = type || "fx";

      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function () {
        jQuery.dequeue(elem, type);
      }; // If the fx queue is dequeued, always remove the progress sentinel


      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }

      if (fn) {
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if (type === "fx") {
          queue.unshift("inprogress");
        } // Clear up the last queue stop function


        delete hooks.stop;
        fn.call(elem, next, hooks);
      }

      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    // Not public - generate a queueHooks object, or return the current one
    _queueHooks: function (elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
        empty: jQuery.Callbacks("once memory").add(function () {
          dataPriv.remove(elem, [type + "queue", key]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function (type, data) {
      var setter = 2;

      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }

      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }

      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

        jQuery._queueHooks(this, type);

        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function (type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function (type) {
      return this.queue(type || "fx", []);
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function (type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function () {
        if (! --count) {
          defer.resolveWith(elements, [elements]);
        }
      };

      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }

      type = type || "fx";

      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");

        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }

      resolve();
      return defer.promise(obj);
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "12ai":
/*!*******************************************************!*\
  !*** ./node_modules/jquery/src/attributes/classes.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../core/stripAndCollapse */ "3PRc"), __webpack_require__(/*! ../var/isFunction */ "s44h"), __webpack_require__(/*! ../var/rnothtmlwhite */ "VK0Q"), __webpack_require__(/*! ../data/var/dataPriv */ "082X"), __webpack_require__(/*! ../core/init */ "MsD2")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, stripAndCollapse, isFunction, rnothtmlwhite, dataPriv) {
  "use strict";

  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }

  function classesToArray(value) {
    if (Array.isArray(value)) {
      return value;
    }

    if (typeof value === "string") {
      return value.match(rnothtmlwhite) || [];
    }

    return [];
  }

  jQuery.fn.extend({
    addClass: function (value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }

      classes = classesToArray(value);

      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },
    removeClass: function (value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }

      if (!arguments.length) {
        return this.attr("class", "");
      }

      classes = classesToArray(value);

      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem); // This expression is here for better compressibility (see addClass)

          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              // Remove *all* instances
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },
    toggleClass: function (value, stateVal) {
      var type = typeof value,
          isValidValue = type === "string" || Array.isArray(value);

      if (typeof stateVal === "boolean" && isValidValue) {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }

      if (isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }

      return this.each(function () {
        var className, i, self, classNames;

        if (isValidValue) {
          // Toggle individual class names
          i = 0;
          self = jQuery(this);
          classNames = classesToArray(value);

          while (className = classNames[i++]) {
            // Check each className given, space separated list
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          } // Toggle whole class name

        } else if (value === undefined || type === "boolean") {
          className = getClass(this);

          if (className) {
            // Store className if set
            dataPriv.set(this, "__className__", className);
          } // If the element has a class name or if we're passed `false`,
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.


          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function (selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";

      while (elem = this[i++]) {
        if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
          return true;
        }
      }

      return false;
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "16XX":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/var/isWindow.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return function isWindow(obj) {
    return obj != null && obj === obj.window;
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "1wM/":
/*!****************************************!*\
  !*** ./node_modules/jquery/src/css.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./var/pnum */ "UQHn"), __webpack_require__(/*! ./core/access */ "MT+g"), __webpack_require__(/*! ./core/camelCase */ "jz24"), __webpack_require__(/*! ./var/document */ "iprW"), __webpack_require__(/*! ./var/rcssNum */ "FbHE"), __webpack_require__(/*! ./css/var/rnumnonpx */ "xLti"), __webpack_require__(/*! ./css/var/cssExpand */ "P+Hb"), __webpack_require__(/*! ./css/var/getStyles */ "kKdo"), __webpack_require__(/*! ./css/var/swap */ "pj6h"), __webpack_require__(/*! ./css/curCSS */ "Qvwh"), __webpack_require__(/*! ./css/adjustCSS */ "qbCo"), __webpack_require__(/*! ./css/addGetHookIf */ "fcmK"), __webpack_require__(/*! ./css/support */ "T4+F"), __webpack_require__(/*! ./core/init */ "MsD2"), __webpack_require__(/*! ./core/ready */ "vnkT"), __webpack_require__(/*! ./selector */ "dyyg") // contains
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, pnum, access, camelCase, document, rcssNum, rnumnonpx, cssExpand, getStyles, swap, curCSS, adjustCSS, addGetHookIf, support) {
  "use strict";

  var // Swappable if display is none or starts with table
  // except "table", "table-cell", or "table-caption"
  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rcustomProp = /^--/,
      cssShow = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
  },
      cssNormalTransform = {
    letterSpacing: "0",
    fontWeight: "400"
  },
      cssPrefixes = ["Webkit", "Moz", "ms"],
      emptyStyle = document.createElement("div").style; // Return a css property mapped to a potentially vendor prefixed property

  function vendorPropName(name) {
    // Shortcut for names that are not vendor prefixed
    if (name in emptyStyle) {
      return name;
    } // Check for vendor prefixed names


    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;

    while (i--) {
      name = cssPrefixes[i] + capName;

      if (name in emptyStyle) {
        return name;
      }
    }
  } // Return a property mapped along what jQuery.cssProps suggests or to
  // a vendor prefixed property.


  function finalPropName(name) {
    var ret = jQuery.cssProps[name];

    if (!ret) {
      ret = jQuery.cssProps[name] = vendorPropName(name) || name;
    }

    return ret;
  }

  function setPositiveNumber(elem, value, subtract) {
    // Any relative (+/-) values have already been
    // normalized at this point
    var matches = rcssNum.exec(value);
    return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }

  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
    var i = dimension === "width" ? 1 : 0,
        extra = 0,
        delta = 0; // Adjustment may not be necessary

    if (box === (isBorderBox ? "border" : "content")) {
      return 0;
    }

    for (; i < 4; i += 2) {
      // Both box models exclude margin
      if (box === "margin") {
        delta += jQuery.css(elem, box + cssExpand[i], true, styles);
      } // If we get here with a content-box, we're seeking "padding" or "border" or "margin"


      if (!isBorderBox) {
        // Add padding
        delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // For "border" or "margin", add border

        if (box !== "padding") {
          delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles); // But still keep track of it otherwise
        } else {
          extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        } // If we get here with a border-box (content + padding + border), we're seeking "content" or
        // "padding" or "margin"

      } else {
        // For "content", subtract padding
        if (box === "content") {
          delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        } // For "content" or "padding", subtract border


        if (box !== "margin") {
          delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    } // Account for positive content-box scroll gutter when requested by providing computedVal


    if (!isBorderBox && computedVal >= 0) {
      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
      // Assuming integer scroll gutter, subtract the rest and round down
      delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5));
    }

    return delta;
  }

  function getWidthOrHeight(elem, dimension, extra) {
    // Start with computed style
    var styles = getStyles(elem),
        val = curCSS(elem, dimension, styles),
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
        valueIsBorderBox = isBorderBox; // Support: Firefox <=54
    // Return a confounding non-pixel value or feign ignorance, as appropriate.

    if (rnumnonpx.test(val)) {
      if (!extra) {
        return val;
      }

      val = "auto";
    } // Check for style in case a browser which returns unreliable values
    // for getComputedStyle silently falls back to the reliable elem.style


    valueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]); // Fall back to offsetWidth/offsetHeight when value is "auto"
    // This happens for inline elements with no explicit setting (gh-3571)
    // Support: Android <=4.1 - 4.3 only
    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)

    if (val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") {
      val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)]; // offsetWidth/offsetHeight provide border-box values

      valueIsBorderBox = true;
    } // Normalize "" and auto


    val = parseFloat(val) || 0; // Adjust for the element's box model

    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
    val) + "px";
  }

  jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
      opacity: {
        get: function (elem, computed) {
          if (computed) {
            // We should always get a number back from opacity
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },
    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {},
    // Get and set the style property on a DOM Node
    style: function (elem, name, value, extra) {
      // Don't set styles on text and comment nodes
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      } // Make sure that we're working with the right name


      var ret,
          type,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name),
          style = elem.style; // Make sure that we're working with the right name. We don't
      // want to query the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Gets hook for the prefixed version, then unprefixed version


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

      if (value !== undefined) {
        type = typeof value; // Convert "+=" or "-=" to relative numbers (#7345)

        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret); // Fixes bug #9237

          type = "number";
        } // Make sure that null and NaN values aren't set (#7116)


        if (value == null || value !== value) {
          return;
        } // If a number was passed in, add the unit (except for certain CSS properties)


        if (type === "number") {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        } // background-* props affect original clone's values


        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        } // If a hook was provided, use that value, otherwise just set the specified value


        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          if (isCustomProp) {
            style.setProperty(name, value);
          } else {
            style[name] = value;
          }
        }
      } else {
        // If a hook was provided get the non-computed value from there
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        } // Otherwise just get the value from the style object


        return style[name];
      }
    },
    css: function (elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't
      // want to modify the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Try prefixed name followed by the unprefixed name


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      } // Otherwise, if a way to get the computed value exists, use that


      if (val === undefined) {
        val = curCSS(elem, name, styles);
      } // Convert "normal" to computed value


      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      } // Make numeric if forced or a qualifier was provided and val looks numeric


      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }

      return val;
    }
  });
  jQuery.each(["height", "width"], function (i, dimension) {
    jQuery.cssHooks[dimension] = {
      get: function (elem, computed, extra) {
        if (computed) {
          // Certain elements can have dimension info if we invisibly show them
          // but it must have a current display style that would benefit
          return rdisplayswap.test(jQuery.css(elem, "display")) && ( // Support: Safari 8+
          // Table columns in Safari have non-zero offsetWidth & zero
          // getBoundingClientRect().width unless display is changed.
          // Support: IE <=11 only
          // Running getBoundingClientRect on a disconnected node
          // in IE throws an error.
          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, dimension, extra);
          }) : getWidthOrHeight(elem, dimension, extra);
        }
      },
      set: function (elem, value, extra) {
        var matches,
            styles = getStyles(elem),
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            subtract = extra && boxModelAdjustment(elem, dimension, extra, isBorderBox, styles); // Account for unreliable border-box dimensions by comparing offset* to computed and
        // faking a content-box to get border and padding (gh-3699)

        if (isBorderBox && support.scrollboxSize() === styles.position) {
          subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
        } // Convert to pixels if value adjustment is needed


        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[dimension] = value;
          value = jQuery.css(elem, dimension);
        }

        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
        marginLeft: 0
      }, function () {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  }); // These hooks are used by animate to expand properties

  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function (value) {
        var i = 0,
            expanded = {},
            // Assumes a single number if not a string
        parts = typeof value === "string" ? value.split(" ") : [value];

        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }

        return expanded;
      }
    };

    if (prefix !== "margin") {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function (name, value) {
      return access(this, function (elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;

        if (Array.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;

          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }

          return map;
        }

        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "2Tf1":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/exports/amd.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict"; // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.
  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return jQuery;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "3PRc":
/*!**********************************************************!*\
  !*** ./node_modules/jquery/src/core/stripAndCollapse.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/rnothtmlwhite */ "VK0Q")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (rnothtmlwhite) {
  "use strict"; // Strip and collapse whitespace according to HTML spec
  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace

  function stripAndCollapse(value) {
    var tokens = value.match(rnothtmlwhite) || [];
    return tokens.join(" ");
  }

  return stripAndCollapse;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "4U/f":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/var/concat.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./arr */ "xccy")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (arr) {
  "use strict";

  return arr.concat;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "4f4o":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/queue/delay.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../queue */ "0VMG"), __webpack_require__(/*! ../effects */ "vY0G") // Delay is optional because of this dependency
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict"; // Based off of the plugin by Clint Helfers, with permission.
  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/

  jQuery.fn.delay = function (time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function (next, hooks) {
      var timeout = window.setTimeout(next, time);

      hooks.stop = function () {
        window.clearTimeout(timeout);
      };
    });
  };

  return jQuery.fn.delay;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "4wmo":
/*!***************************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/setGlobalEval.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../data/var/dataPriv */ "082X")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (dataPriv) {
  "use strict"; // Mark scripts as having already been evaluated

  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;

    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }

  return setGlobalEval;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "65MQ":
/*!*****************************************************************!*\
  !*** ./node_modules/jquery/src/traversing/var/rneedsContext.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../../core */ "mEBU"), __webpack_require__(/*! ../../selector */ "dyyg")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  return jQuery.expr.match.needsContext;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "75f9":
/*!************************************************************!*\
  !*** ./node_modules/jquery/src/traversing/var/siblings.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return function (n, elem) {
    var matched = [];

    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }

    return matched;
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "7PcZ":
/*!*******************************************************************!*\
  !*** ./node_modules/is-dom-node-list/dist/is-dom-node-list.es.js ***!
  \*******************************************************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var is_dom_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-dom-node */ "A00J");
/*! @license is-dom-node-list v1.2.1

	Copyright 2018 Fisssion LLC.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

*/


function isDomNodeList(x) {
  var prototypeToString = Object.prototype.toString.call(x);
  var regex = /^\[object (HTMLCollection|NodeList|Object)\]$/;
  return typeof window.NodeList === 'object' ? x instanceof window.NodeList : x !== null && typeof x === 'object' && typeof x.length === 'number' && regex.test(prototypeToString) && (x.length === 0 || Object(is_dom_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(x[0]));
}

/* harmony default export */ __webpack_exports__["a"] = (isDomNodeList);

/***/ }),

/***/ "7fyN":
/*!*****************************************!*\
  !*** ./node_modules/jquery/src/wrap.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./var/isFunction */ "s44h"), __webpack_require__(/*! ./core/init */ "MsD2"), __webpack_require__(/*! ./manipulation */ "PRQw"), // clone
__webpack_require__(/*! ./traversing */ "wkHr") // parent, contents
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, isFunction) {
  "use strict";

  jQuery.fn.extend({
    wrapAll: function (html) {
      var wrap;

      if (this[0]) {
        if (isFunction(html)) {
          html = html.call(this[0]);
        } // The elements to wrap the target around


        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }

        wrap.map(function () {
          var elem = this;

          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }

          return elem;
        }).append(this);
      }

      return this;
    },
    wrapInner: function (html) {
      if (isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }

      return this.each(function () {
        var self = jQuery(this),
            contents = self.contents();

        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function (html) {
      var htmlIsFunction = isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function (selector) {
      this.parent(selector).not("body").each(function () {
        jQuery(this).replaceWith(this.childNodes);
      });
      return this;
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "8g73":
/*!****************************************************!*\
  !*** ./node_modules/jquery/src/attributes/prop.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../core/access */ "MT+g"), __webpack_require__(/*! ./support */ "F83J"), __webpack_require__(/*! ../selector */ "dyyg")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, access, support) {
  "use strict";

  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function (name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function (name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function (elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }

      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        return elem[name] = value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      return elem[name];
    },
    propHooks: {
      tabIndex: {
        get: function (elem) {
          // Support: IE <=9 - 11 only
          // elem.tabIndex doesn't always return the
          // correct value when it hasn't been explicitly set
          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
          // Use proper attribute retrieval(#12072)
          var tabindex = jQuery.find.attr(elem, "tabindex");

          if (tabindex) {
            return parseInt(tabindex, 10);
          }

          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
            return 0;
          }

          return -1;
        }
      }
    },
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  }); // Support: IE <=11 only
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  // eslint rule "no-unused-expressions" is disabled for this code
  // since it considers such accessions noop

  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function (elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }

        return null;
      },
      set: function (elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent) {
          parent.selectedIndex;

          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }

  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "8oxB":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "8qe8":
/*!***************************************************!*\
  !*** ./node_modules/tealight/dist/tealight.es.js ***!
  \***************************************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var is_dom_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-dom-node */ "A00J");
/* harmony import */ var is_dom_node_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-dom-node-list */ "7PcZ");
/*! @license Tealight v0.3.6

	Copyright 2018 Fisssion LLC.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

*/



function tealight(target, context) {
  if (context === void 0) context = document;

  if (target instanceof Array) {
    return target.filter(is_dom_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);
  }

  if (Object(is_dom_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(target)) {
    return [target];
  }

  if (Object(is_dom_node_list__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(target)) {
    return Array.prototype.slice.call(target);
  }

  if (typeof target === "string") {
    try {
      var query = context.querySelectorAll(target);
      return Array.prototype.slice.call(query);
    } catch (err) {
      return [];
    }
  }

  return [];
}

/* harmony default export */ __webpack_exports__["a"] = (tealight);

/***/ }),

/***/ "9Pyl":
/*!*******************************************!*\
  !*** ./node_modules/jquery/src/offset.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./core/access */ "MT+g"), __webpack_require__(/*! ./var/document */ "iprW"), __webpack_require__(/*! ./var/documentElement */ "tz86"), __webpack_require__(/*! ./var/isFunction */ "s44h"), __webpack_require__(/*! ./css/var/rnumnonpx */ "xLti"), __webpack_require__(/*! ./css/curCSS */ "Qvwh"), __webpack_require__(/*! ./css/addGetHookIf */ "fcmK"), __webpack_require__(/*! ./css/support */ "T4+F"), __webpack_require__(/*! ./var/isWindow */ "16XX"), __webpack_require__(/*! ./core/init */ "MsD2"), __webpack_require__(/*! ./css */ "1wM/"), __webpack_require__(/*! ./selector */ "dyyg") // contains
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, access, document, documentElement, isFunction, rnumnonpx, curCSS, addGetHookIf, support, isWindow) {
  "use strict";

  jQuery.offset = {
    setOffset: function (elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {}; // Set position first, in-case top/left are set even on static elem

      if (position === "static") {
        elem.style.position = "relative";
      }

      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
      // top or left is auto and position is either absolute or fixed

      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }

      if (isFunction(options)) {
        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }

      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }

      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }

      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    // offset() relates an element's border box to the document origin
    offset: function (options) {
      // Preserve chaining for setter
      if (arguments.length) {
        return options === undefined ? this : this.each(function (i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }

      var rect,
          win,
          elem = this[0];

      if (!elem) {
        return;
      } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
      // Support: IE <=11 only
      // Running getBoundingClientRect on a
      // disconnected node in IE throws an error


      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


      rect = elem.getBoundingClientRect();
      win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    },
    // position() relates an element's margin box to its offset parent's padding box
    // This corresponds to the behavior of CSS absolute positioning
    position: function () {
      if (!this[0]) {
        return;
      }

      var offsetParent,
          offset,
          doc,
          elem = this[0],
          parentOffset = {
        top: 0,
        left: 0
      }; // position:fixed elements are offset from the viewport, which itself always has zero offset

      if (jQuery.css(elem, "position") === "fixed") {
        // Assume position:fixed implies availability of getBoundingClientRect
        offset = elem.getBoundingClientRect();
      } else {
        offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element
        // when a statically positioned element is identified

        doc = elem.ownerDocument;
        offsetParent = elem.offsetParent || doc.documentElement;

        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.parentNode;
        }

        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
          // Incorporate borders into its offset, since they are outside its content origin
          parentOffset = jQuery(offsetParent).offset();
          parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
          parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
        }
      } // Subtract parent offsets and element margins


      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    // This method will return documentElement in the following cases:
    // 1) For the element inside the iframe without offsetParent, this method will return
    //    documentElement of the parent window
    // 2) For the hidden or detached element
    // 3) For body or html element, i.e. in case of the html node - it will return itself
    //
    // but those exceptions were never presented as a real life use-cases
    // and might be considered as more preferable results.
    //
    // This logic, however, is not guaranteed and can change at any point in the future
    offsetParent: function () {
      return this.map(function () {
        var offsetParent = this.offsetParent;

        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || documentElement;
      });
    }
  }); // Create scrollLeft and scrollTop methods

  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (method, prop) {
    var top = "pageYOffset" === prop;

    jQuery.fn[method] = function (val) {
      return access(this, function (elem, method, val) {
        // Coalesce documents and windows
        var win;

        if (isWindow(elem)) {
          win = elem;
        } else if (elem.nodeType === 9) {
          win = elem.defaultView;
        }

        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }

        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here

  jQuery.each(["top", "left"], function (i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "9tPo":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */
module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  } // blank or null?


  if (!css || typeof css !== "string") {
    return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/"); // convert each url(...)

  /*
  This regular expression is just a way to recursively match brackets within
  a string.
  	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
     (  = Start a capturing group
       (?:  = Start a non-capturing group
           [^)(]  = Match anything that isn't a parentheses
           |  = OR
           \(  = Match a start parentheses
               (?:  = Start another non-capturing groups
                   [^)(]+  = Match anything that isn't a parentheses
                   |  = OR
                   \(  = Match a start parentheses
                       [^)(]*  = Match anything that isn't a parentheses
                   \)  = Match a end parentheses
               )  = End Group
               *\) = Match anything and then a close parens
           )  = Close non-capturing group
           *  = Match anything
        )  = Close capturing group
   \)  = Match a close parens
  	 /gi  = Get all matches, not the first.  Be case insensitive.
   */

  var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
    // strip quotes (if they exist)
    var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
      return $1;
    }).replace(/^'(.*)'$/, function (o, $1) {
      return $1;
    }); // already a full url? no change

    if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
      return fullMatch;
    } // convert the url to a full url


    var newUrl;

    if (unquotedOrigUrl.indexOf("//") === 0) {
      //TODO: should we add protocol?
      newUrl = unquotedOrigUrl;
    } else if (unquotedOrigUrl.indexOf("/") === 0) {
      // path should be relative to the base url
      newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
    } else {
      // path should be relative to current directory
      newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
    } // send back the fixed url(...)


    return "url(" + JSON.stringify(newUrl) + ")";
  }); // send back the fixed css

  return fixedCss;
};

/***/ }),

/***/ "A00J":
/*!*********************************************************!*\
  !*** ./node_modules/is-dom-node/dist/is-dom-node.es.js ***!
  \*********************************************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/*! @license is-dom-node v1.0.4

	Copyright 2018 Fisssion LLC.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

*/
function isDomNode(x) {
  return typeof window.Node === 'object' ? x instanceof window.Node : x !== null && typeof x === 'object' && typeof x.nodeType === 'number' && typeof x.nodeName === 'string';
}

/* harmony default export */ __webpack_exports__["a"] = (isDomNode);

/***/ }),

/***/ "BK5V":
/*!************************************************************!*\
  !*** ./node_modules/jquery/external/sizzle/dist/sizzle.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function (window) {
  var i,
      support,
      Expr,
      getText,
      isXML,
      tokenize,
      compile,
      select,
      outermostContext,
      sortInput,
      hasDuplicate,
      // Local document vars
  setDocument,
      document,
      docElem,
      documentIsHTML,
      rbuggyQSA,
      rbuggyMatches,
      matches,
      contains,
      // Instance-specific data
  expando = "sizzle" + 1 * new Date(),
      preferredDoc = window.document,
      dirruns = 0,
      done = 0,
      classCache = createCache(),
      tokenCache = createCache(),
      compilerCache = createCache(),
      sortOrder = function (a, b) {
    if (a === b) {
      hasDuplicate = true;
    }

    return 0;
  },
      // Instance methods
  hasOwn = {}.hasOwnProperty,
      arr = [],
      pop = arr.pop,
      push_native = arr.push,
      push = arr.push,
      slice = arr.slice,
      // Use a stripped-down indexOf as it's faster than native
  // https://jsperf.com/thor-indexof-vs-for/5
  indexOf = function (list, elem) {
    var i = 0,
        len = list.length;

    for (; i < len; i++) {
      if (list[i] === elem) {
        return i;
      }
    }

    return -1;
  },
      booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
      // Regular expressions
  // http://www.w3.org/TR/css3-selectors/#whitespace
  whitespace = "[\\x20\\t\\r\\n\\f]",
      // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
  identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
      // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
  attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
  "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
  "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
      pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
  // 1. quoted (capture 3; capture 4 or capture 5)
  "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
  "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
  ".*" + ")\\)|)",
      // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
  rwhitespace = new RegExp(whitespace + "+", "g"),
      rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
      rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
      rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
      rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
      rpseudo = new RegExp(pseudos),
      ridentifier = new RegExp("^" + identifier + "$"),
      matchExpr = {
    "ID": new RegExp("^#(" + identifier + ")"),
    "CLASS": new RegExp("^\\.(" + identifier + ")"),
    "TAG": new RegExp("^(" + identifier + "|[*])"),
    "ATTR": new RegExp("^" + attributes),
    "PSEUDO": new RegExp("^" + pseudos),
    "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
    "bool": new RegExp("^(?:" + booleans + ")$", "i"),
    // For use in libraries implementing .is()
    // We use this for POS matching in `select`
    "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
  },
      rinputs = /^(?:input|select|textarea|button)$/i,
      rheader = /^h\d$/i,
      rnative = /^[^{]+\{\s*\[native \w/,
      // Easily-parseable/retrievable ID or TAG or CLASS selectors
  rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
      rsibling = /[+~]/,
      // CSS escapes
  // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
  runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
      funescape = function (_, escaped, escapedWhitespace) {
    var high = "0x" + escaped - 0x10000; // NaN means non-codepoint
    // Support: Firefox<24
    // Workaround erroneous numeric interpretation of +"0x"

    return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint
    String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
  },
      // CSS string/identifier serialization
  // https://drafts.csswg.org/cssom/#common-serializing-idioms
  rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
      fcssescape = function (ch, asCodePoint) {
    if (asCodePoint) {
      // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
      if (ch === "\0") {
        return "\uFFFD";
      } // Control characters and (dependent upon position) numbers get escaped as code points


      return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
    } // Other potentially-special ASCII characters get backslash-escaped


    return "\\" + ch;
  },
      // Used for iframes
  // See setDocument()
  // Removing the function wrapper causes a "Permission Denied"
  // error in IE
  unloadHandler = function () {
    setDocument();
  },
      disabledAncestor = addCombinator(function (elem) {
    return elem.disabled === true && ("form" in elem || "label" in elem);
  }, {
    dir: "parentNode",
    next: "legend"
  }); // Optimize for push.apply( _, NodeList )


  try {
    push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
    // Detect silently failing push.apply

    arr[preferredDoc.childNodes.length].nodeType;
  } catch (e) {
    push = {
      apply: arr.length ? // Leverage slice if possible
      function (target, els) {
        push_native.apply(target, slice.call(els));
      } : // Support: IE<9
      // Otherwise append directly
      function (target, els) {
        var j = target.length,
            i = 0; // Can't trust NodeList.length

        while (target[j++] = els[i++]) {}

        target.length = j - 1;
      }
    };
  }

  function Sizzle(selector, context, results, seed) {
    var m,
        i,
        elem,
        nid,
        match,
        groups,
        newSelector,
        newContext = context && context.ownerDocument,
        // nodeType defaults to 9, since context defaults to document
    nodeType = context ? context.nodeType : 9;
    results = results || []; // Return early from calls with invalid selector or context

    if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
      return results;
    } // Try to shortcut find operations (as opposed to filters) in HTML documents


    if (!seed) {
      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
        setDocument(context);
      }

      context = context || document;

      if (documentIsHTML) {
        // If the selector is sufficiently simple, try using a "get*By*" DOM method
        // (excepting DocumentFragment context, where the methods don't exist)
        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
          // ID selector
          if (m = match[1]) {
            // Document context
            if (nodeType === 9) {
              if (elem = context.getElementById(m)) {
                // Support: IE, Opera, Webkit
                // TODO: identify versions
                // getElementById can match elements by name instead of ID
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              } // Element context

            } else {
              // Support: IE, Opera, Webkit
              // TODO: identify versions
              // getElementById can match elements by name instead of ID
              if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            } // Type selector

          } else if (match[2]) {
            push.apply(results, context.getElementsByTagName(selector));
            return results; // Class selector
          } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            return results;
          }
        } // Take advantage of querySelectorAll


        if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          if (nodeType !== 1) {
            newContext = context;
            newSelector = selector; // qSA looks outside Element context, which is not what we want
            // Thanks to Andrew Dupont for this workaround technique
            // Support: IE <=8
            // Exclude object elements
          } else if (context.nodeName.toLowerCase() !== "object") {
            // Capture the context ID, setting it first if necessary
            if (nid = context.getAttribute("id")) {
              nid = nid.replace(rcssescape, fcssescape);
            } else {
              context.setAttribute("id", nid = expando);
            } // Prefix every selector in the list


            groups = tokenize(selector);
            i = groups.length;

            while (i--) {
              groups[i] = "#" + nid + " " + toSelector(groups[i]);
            }

            newSelector = groups.join(","); // Expand context for sibling selectors

            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
          }

          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {} finally {
              if (nid === expando) {
                context.removeAttribute("id");
              }
            }
          }
        }
      }
    } // All others


    return select(selector.replace(rtrim, "$1"), context, results, seed);
  }
  /**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */


  function createCache() {
    var keys = [];

    function cache(key, value) {
      // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
      if (keys.push(key + " ") > Expr.cacheLength) {
        // Only keep the most recent entries
        delete cache[keys.shift()];
      }

      return cache[key + " "] = value;
    }

    return cache;
  }
  /**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */


  function markFunction(fn) {
    fn[expando] = true;
    return fn;
  }
  /**
   * Support testing using an element
   * @param {Function} fn Passed the created element and returns a boolean result
   */


  function assert(fn) {
    var el = document.createElement("fieldset");

    try {
      return !!fn(el);
    } catch (e) {
      return false;
    } finally {
      // Remove from its parent by default
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      } // release memory in IE


      el = null;
    }
  }
  /**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */


  function addHandle(attrs, handler) {
    var arr = attrs.split("|"),
        i = arr.length;

    while (i--) {
      Expr.attrHandle[arr[i]] = handler;
    }
  }
  /**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */


  function siblingCheck(a, b) {
    var cur = b && a,
        diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

    if (diff) {
      return diff;
    } // Check if b follows a


    if (cur) {
      while (cur = cur.nextSibling) {
        if (cur === b) {
          return -1;
        }
      }
    }

    return a ? 1 : -1;
  }
  /**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */


  function createInputPseudo(type) {
    return function (elem) {
      var name = elem.nodeName.toLowerCase();
      return name === "input" && elem.type === type;
    };
  }
  /**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */


  function createButtonPseudo(type) {
    return function (elem) {
      var name = elem.nodeName.toLowerCase();
      return (name === "input" || name === "button") && elem.type === type;
    };
  }
  /**
   * Returns a function to use in pseudos for :enabled/:disabled
   * @param {Boolean} disabled true for :disabled; false for :enabled
   */


  function createDisabledPseudo(disabled) {
    // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
    return function (elem) {
      // Only certain elements can match :enabled or :disabled
      // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
      // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
      if ("form" in elem) {
        // Check for inherited disabledness on relevant non-disabled elements:
        // * listed form-associated elements in a disabled fieldset
        //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
        //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
        // * option elements in a disabled optgroup
        //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
        // All such elements have a "form" property.
        if (elem.parentNode && elem.disabled === false) {
          // Option elements defer to a parent optgroup if present
          if ("label" in elem) {
            if ("label" in elem.parentNode) {
              return elem.parentNode.disabled === disabled;
            } else {
              return elem.disabled === disabled;
            }
          } // Support: IE 6 - 11
          // Use the isDisabled shortcut property to check for disabled fieldset ancestors


          return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

          /* jshint -W018 */
          elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
        }

        return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
        // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
        // even exist on them, let alone have a boolean value.
      } else if ("label" in elem) {
        return elem.disabled === disabled;
      } // Remaining elements are neither :enabled nor :disabled


      return false;
    };
  }
  /**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */


  function createPositionalPseudo(fn) {
    return markFunction(function (argument) {
      argument = +argument;
      return markFunction(function (seed, matches) {
        var j,
            matchIndexes = fn([], seed.length, argument),
            i = matchIndexes.length; // Match elements found at the specified indexes

        while (i--) {
          if (seed[j = matchIndexes[i]]) {
            seed[j] = !(matches[j] = seed[j]);
          }
        }
      });
    });
  }
  /**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */


  function testContext(context) {
    return context && typeof context.getElementsByTagName !== "undefined" && context;
  } // Expose support vars for convenience


  support = Sizzle.support = {};
  /**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */

  isXML = Sizzle.isXML = function (elem) {
    // documentElement is verified for cases where it doesn't yet exist
    // (such as loading iframes in IE - #4833)
    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
    return documentElement ? documentElement.nodeName !== "HTML" : false;
  };
  /**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */


  setDocument = Sizzle.setDocument = function (node) {
    var hasCompare,
        subWindow,
        doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected

    if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
      return document;
    } // Update global variables


    document = doc;
    docElem = document.documentElement;
    documentIsHTML = !isXML(document); // Support: IE 9-11, Edge
    // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)

    if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
      // Support: IE 11, Edge
      if (subWindow.addEventListener) {
        subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
      } else if (subWindow.attachEvent) {
        subWindow.attachEvent("onunload", unloadHandler);
      }
    }
    /* Attributes
    ---------------------------------------------------------------------- */
    // Support: IE<8
    // Verify that getAttribute really returns attributes and not properties
    // (excepting IE8 booleans)


    support.attributes = assert(function (el) {
      el.className = "i";
      return !el.getAttribute("className");
    });
    /* getElement(s)By*
    ---------------------------------------------------------------------- */
    // Check if getElementsByTagName("*") returns only elements

    support.getElementsByTagName = assert(function (el) {
      el.appendChild(document.createComment(""));
      return !el.getElementsByTagName("*").length;
    }); // Support: IE<9

    support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
    // Check if getElementById returns elements by name
    // The broken getElementById methods don't pick up programmatically-set names,
    // so use a roundabout getElementsByName test

    support.getById = assert(function (el) {
      docElem.appendChild(el).id = expando;
      return !document.getElementsByName || !document.getElementsByName(expando).length;
    }); // ID filter and find

    if (support.getById) {
      Expr.filter["ID"] = function (id) {
        var attrId = id.replace(runescape, funescape);
        return function (elem) {
          return elem.getAttribute("id") === attrId;
        };
      };

      Expr.find["ID"] = function (id, context) {
        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
          var elem = context.getElementById(id);
          return elem ? [elem] : [];
        }
      };
    } else {
      Expr.filter["ID"] = function (id) {
        var attrId = id.replace(runescape, funescape);
        return function (elem) {
          var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
          return node && node.value === attrId;
        };
      }; // Support: IE 6 - 7 only
      // getElementById is not reliable as a find shortcut


      Expr.find["ID"] = function (id, context) {
        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
          var node,
              i,
              elems,
              elem = context.getElementById(id);

          if (elem) {
            // Verify the id attribute
            node = elem.getAttributeNode("id");

            if (node && node.value === id) {
              return [elem];
            } // Fall back on getElementsByName


            elems = context.getElementsByName(id);
            i = 0;

            while (elem = elems[i++]) {
              node = elem.getAttributeNode("id");

              if (node && node.value === id) {
                return [elem];
              }
            }
          }

          return [];
        }
      };
    } // Tag


    Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
      if (typeof context.getElementsByTagName !== "undefined") {
        return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
      } else if (support.qsa) {
        return context.querySelectorAll(tag);
      }
    } : function (tag, context) {
      var elem,
          tmp = [],
          i = 0,
          // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
      results = context.getElementsByTagName(tag); // Filter out possible comments

      if (tag === "*") {
        while (elem = results[i++]) {
          if (elem.nodeType === 1) {
            tmp.push(elem);
          }
        }

        return tmp;
      }

      return results;
    }; // Class

    Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
      if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
        return context.getElementsByClassName(className);
      }
    };
    /* QSA/matchesSelector
    ---------------------------------------------------------------------- */
    // QSA and matchesSelector support
    // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


    rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
    // We allow this because of a bug in IE8/9 that throws an error
    // whenever `document.activeElement` is accessed on an iframe
    // So, we allow :focus to pass through QSA all the time to avoid the IE error
    // See https://bugs.jquery.com/ticket/13378

    rbuggyQSA = [];

    if (support.qsa = rnative.test(document.querySelectorAll)) {
      // Build QSA regex
      // Regex strategy adopted from Diego Perini
      assert(function (el) {
        // Select is set to empty string on purpose
        // This is to test IE's treatment of not explicitly
        // setting a boolean content attribute,
        // since its presence should be enough
        // https://bugs.jquery.com/ticket/12359
        docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
        // Nothing should be selected when empty strings follow ^= or $= or *=
        // The test attribute must be unknown in Opera but "safe" for WinRT
        // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

        if (el.querySelectorAll("[msallowcapture^='']").length) {
          rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
        } // Support: IE8
        // Boolean attributes and "value" are not treated correctly


        if (!el.querySelectorAll("[selected]").length) {
          rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
        } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


        if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
          rbuggyQSA.push("~=");
        } // Webkit/Opera - :checked should return selected option elements
        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
        // IE8 throws error here and will not see later tests


        if (!el.querySelectorAll(":checked").length) {
          rbuggyQSA.push(":checked");
        } // Support: Safari 8+, iOS 8+
        // https://bugs.webkit.org/show_bug.cgi?id=136851
        // In-page `selector#id sibling-combinator selector` fails


        if (!el.querySelectorAll("a#" + expando + "+*").length) {
          rbuggyQSA.push(".#.+[+~]");
        }
      });
      assert(function (el) {
        el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"; // Support: Windows 8 Native Apps
        // The type and name attributes are restricted during .innerHTML assignment

        var input = document.createElement("input");
        input.setAttribute("type", "hidden");
        el.appendChild(input).setAttribute("name", "D"); // Support: IE8
        // Enforce case-sensitivity of name attribute

        if (el.querySelectorAll("[name=d]").length) {
          rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
        } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
        // IE8 throws error here and will not see later tests


        if (el.querySelectorAll(":enabled").length !== 2) {
          rbuggyQSA.push(":enabled", ":disabled");
        } // Support: IE9-11+
        // IE's :disabled selector does not pick up the children of disabled fieldsets


        docElem.appendChild(el).disabled = true;

        if (el.querySelectorAll(":disabled").length !== 2) {
          rbuggyQSA.push(":enabled", ":disabled");
        } // Opera 10-11 does not throw on post-comma invalid pseudos


        el.querySelectorAll("*,:x");
        rbuggyQSA.push(",.*:");
      });
    }

    if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
      assert(function (el) {
        // Check to see if it's possible to do matchesSelector
        // on a disconnected node (IE 9)
        support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
        // Gecko does not error, returns false instead

        matches.call(el, "[s!='']:x");
        rbuggyMatches.push("!=", pseudos);
      });
    }

    rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
    rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
    /* Contains
    ---------------------------------------------------------------------- */

    hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
    // Purposefully self-exclusive
    // As in, an element does not contain itself

    contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
      var adown = a.nodeType === 9 ? a.documentElement : a,
          bup = b && b.parentNode;
      return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
    } : function (a, b) {
      if (b) {
        while (b = b.parentNode) {
          if (b === a) {
            return true;
          }
        }
      }

      return false;
    };
    /* Sorting
    ---------------------------------------------------------------------- */
    // Document order sorting

    sortOrder = hasCompare ? function (a, b) {
      // Flag for duplicate removal
      if (a === b) {
        hasDuplicate = true;
        return 0;
      } // Sort on method existence if only one input has compareDocumentPosition


      var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

      if (compare) {
        return compare;
      } // Calculate position if both inputs belong to the same document


      compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
      1; // Disconnected nodes

      if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
        // Choose the first element that is related to our preferred document
        if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
          return -1;
        }

        if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
          return 1;
        } // Maintain original order


        return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
      }

      return compare & 4 ? -1 : 1;
    } : function (a, b) {
      // Exit early if the nodes are identical
      if (a === b) {
        hasDuplicate = true;
        return 0;
      }

      var cur,
          i = 0,
          aup = a.parentNode,
          bup = b.parentNode,
          ap = [a],
          bp = [b]; // Parentless nodes are either documents or disconnected

      if (!aup || !bup) {
        return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
      } else if (aup === bup) {
        return siblingCheck(a, b);
      } // Otherwise we need full lists of their ancestors for comparison


      cur = a;

      while (cur = cur.parentNode) {
        ap.unshift(cur);
      }

      cur = b;

      while (cur = cur.parentNode) {
        bp.unshift(cur);
      } // Walk down the tree looking for a discrepancy


      while (ap[i] === bp[i]) {
        i++;
      }

      return i ? // Do a sibling check if the nodes have a common ancestor
      siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
      ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
    };
    return document;
  };

  Sizzle.matches = function (expr, elements) {
    return Sizzle(expr, null, null, elements);
  };

  Sizzle.matchesSelector = function (elem, expr) {
    // Set document vars if needed
    if ((elem.ownerDocument || elem) !== document) {
      setDocument(elem);
    } // Make sure that attribute selectors are quoted


    expr = expr.replace(rattributeQuotes, "='$1']");

    if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
      try {
        var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

        if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
        // fragment in IE 9
        elem.document && elem.document.nodeType !== 11) {
          return ret;
        }
      } catch (e) {}
    }

    return Sizzle(expr, document, null, [elem]).length > 0;
  };

  Sizzle.contains = function (context, elem) {
    // Set document vars if needed
    if ((context.ownerDocument || context) !== document) {
      setDocument(context);
    }

    return contains(context, elem);
  };

  Sizzle.attr = function (elem, name) {
    // Set document vars if needed
    if ((elem.ownerDocument || elem) !== document) {
      setDocument(elem);
    }

    var fn = Expr.attrHandle[name.toLowerCase()],
        // Don't get fooled by Object.prototype properties (jQuery #13807)
    val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
    return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
  };

  Sizzle.escape = function (sel) {
    return (sel + "").replace(rcssescape, fcssescape);
  };

  Sizzle.error = function (msg) {
    throw new Error("Syntax error, unrecognized expression: " + msg);
  };
  /**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */


  Sizzle.uniqueSort = function (results) {
    var elem,
        duplicates = [],
        j = 0,
        i = 0; // Unless we *know* we can detect duplicates, assume their presence

    hasDuplicate = !support.detectDuplicates;
    sortInput = !support.sortStable && results.slice(0);
    results.sort(sortOrder);

    if (hasDuplicate) {
      while (elem = results[i++]) {
        if (elem === results[i]) {
          j = duplicates.push(i);
        }
      }

      while (j--) {
        results.splice(duplicates[j], 1);
      }
    } // Clear input after sorting to release objects
    // See https://github.com/jquery/sizzle/pull/225


    sortInput = null;
    return results;
  };
  /**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */


  getText = Sizzle.getText = function (elem) {
    var node,
        ret = "",
        i = 0,
        nodeType = elem.nodeType;

    if (!nodeType) {
      // If no nodeType, this is expected to be an array
      while (node = elem[i++]) {
        // Do not traverse comment nodes
        ret += getText(node);
      }
    } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
      // Use textContent for elements
      // innerText usage removed for consistency of new lines (jQuery #11153)
      if (typeof elem.textContent === "string") {
        return elem.textContent;
      } else {
        // Traverse its children
        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
          ret += getText(elem);
        }
      }
    } else if (nodeType === 3 || nodeType === 4) {
      return elem.nodeValue;
    } // Do not include comment or processing instruction nodes


    return ret;
  };

  Expr = Sizzle.selectors = {
    // Can be adjusted by the user
    cacheLength: 50,
    createPseudo: markFunction,
    match: matchExpr,
    attrHandle: {},
    find: {},
    relative: {
      ">": {
        dir: "parentNode",
        first: true
      },
      " ": {
        dir: "parentNode"
      },
      "+": {
        dir: "previousSibling",
        first: true
      },
      "~": {
        dir: "previousSibling"
      }
    },
    preFilter: {
      "ATTR": function (match) {
        match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

        match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

        if (match[2] === "~=") {
          match[3] = " " + match[3] + " ";
        }

        return match.slice(0, 4);
      },
      "CHILD": function (match) {
        /* matches from matchExpr["CHILD"]
        	1 type (only|nth|...)
        	2 what (child|of-type)
        	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
        	4 xn-component of xn+y argument ([+-]?\d*n|)
        	5 sign of xn-component
        	6 x of xn-component
        	7 sign of y-component
        	8 y of y-component
        */
        match[1] = match[1].toLowerCase();

        if (match[1].slice(0, 3) === "nth") {
          // nth-* requires argument
          if (!match[3]) {
            Sizzle.error(match[0]);
          } // numeric x and y parameters for Expr.filter.CHILD
          // remember that false/true cast respectively to 0/1


          match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
          match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
        } else if (match[3]) {
          Sizzle.error(match[0]);
        }

        return match;
      },
      "PSEUDO": function (match) {
        var excess,
            unquoted = !match[6] && match[2];

        if (matchExpr["CHILD"].test(match[0])) {
          return null;
        } // Accept quoted arguments as-is


        if (match[3]) {
          match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
        } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
        excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
        excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
          // excess is a negative index
          match[0] = match[0].slice(0, excess);
          match[2] = unquoted.slice(0, excess);
        } // Return only captures needed by the pseudo filter method (type and argument)


        return match.slice(0, 3);
      }
    },
    filter: {
      "TAG": function (nodeNameSelector) {
        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
        return nodeNameSelector === "*" ? function () {
          return true;
        } : function (elem) {
          return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
        };
      },
      "CLASS": function (className) {
        var pattern = classCache[className + " "];
        return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
          return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
        });
      },
      "ATTR": function (name, operator, check) {
        return function (elem) {
          var result = Sizzle.attr(elem, name);

          if (result == null) {
            return operator === "!=";
          }

          if (!operator) {
            return true;
          }

          result += "";
          return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
        };
      },
      "CHILD": function (type, what, argument, first, last) {
        var simple = type.slice(0, 3) !== "nth",
            forward = type.slice(-4) !== "last",
            ofType = what === "of-type";
        return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
        function (elem) {
          return !!elem.parentNode;
        } : function (elem, context, xml) {
          var cache,
              uniqueCache,
              outerCache,
              node,
              nodeIndex,
              start,
              dir = simple !== forward ? "nextSibling" : "previousSibling",
              parent = elem.parentNode,
              name = ofType && elem.nodeName.toLowerCase(),
              useCache = !xml && !ofType,
              diff = false;

          if (parent) {
            // :(first|last|only)-(child|of-type)
            if (simple) {
              while (dir) {
                node = elem;

                while (node = node[dir]) {
                  if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                    return false;
                  }
                } // Reverse direction for :only-* (if we haven't yet done so)


                start = dir = type === "only" && !start && "nextSibling";
              }

              return true;
            }

            start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

            if (forward && useCache) {
              // Seek `elem` from a previously-cached index
              // ...in a gzip-friendly way
              node = parent;
              outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
              // Defend against cloned attroperties (jQuery gh-1709)

              uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
              cache = uniqueCache[type] || [];
              nodeIndex = cache[0] === dirruns && cache[1];
              diff = nodeIndex && cache[2];
              node = nodeIndex && parent.childNodes[nodeIndex];

              while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
              diff = nodeIndex = 0) || start.pop()) {
                // When found, cache indexes on `parent` and break
                if (node.nodeType === 1 && ++diff && node === elem) {
                  uniqueCache[type] = [dirruns, nodeIndex, diff];
                  break;
                }
              }
            } else {
              // Use previously-cached element index if available
              if (useCache) {
                // ...in a gzip-friendly way
                node = elem;
                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)

                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex;
              } // xml :nth-child(...)
              // or :nth-last-child(...) or :nth(-last)?-of-type(...)


              if (diff === false) {
                // Use the same loop as above to seek `elem` from the start
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                    // Cache the index of each encountered element
                    if (useCache) {
                      outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                      // Defend against cloned attroperties (jQuery gh-1709)

                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                      uniqueCache[type] = [dirruns, diff];
                    }

                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
            } // Incorporate the offset, then check against cycle size


            diff -= last;
            return diff === first || diff % first === 0 && diff / first >= 0;
          }
        };
      },
      "PSEUDO": function (pseudo, argument) {
        // pseudo-class names are case-insensitive
        // http://www.w3.org/TR/selectors/#pseudo-classes
        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
        // Remember that setFilters inherits from pseudos
        var args,
            fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
        // arguments are needed to create the filter function
        // just as Sizzle does

        if (fn[expando]) {
          return fn(argument);
        } // But maintain support for old signatures


        if (fn.length > 1) {
          args = [pseudo, pseudo, "", argument];
          return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
            var idx,
                matched = fn(seed, argument),
                i = matched.length;

            while (i--) {
              idx = indexOf(seed, matched[i]);
              seed[idx] = !(matches[idx] = matched[i]);
            }
          }) : function (elem) {
            return fn(elem, 0, args);
          };
        }

        return fn;
      }
    },
    pseudos: {
      // Potentially complex pseudos
      "not": markFunction(function (selector) {
        // Trim the selector passed to compile
        // to avoid treating leading and trailing
        // spaces as combinators
        var input = [],
            results = [],
            matcher = compile(selector.replace(rtrim, "$1"));
        return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
          var elem,
              unmatched = matcher(seed, null, xml, []),
              i = seed.length; // Match elements unmatched by `matcher`

          while (i--) {
            if (elem = unmatched[i]) {
              seed[i] = !(matches[i] = elem);
            }
          }
        }) : function (elem, context, xml) {
          input[0] = elem;
          matcher(input, null, xml, results); // Don't keep the element (issue #299)

          input[0] = null;
          return !results.pop();
        };
      }),
      "has": markFunction(function (selector) {
        return function (elem) {
          return Sizzle(selector, elem).length > 0;
        };
      }),
      "contains": markFunction(function (text) {
        text = text.replace(runescape, funescape);
        return function (elem) {
          return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
        };
      }),
      // "Whether an element is represented by a :lang() selector
      // is based solely on the element's language value
      // being equal to the identifier C,
      // or beginning with the identifier C immediately followed by "-".
      // The matching of C against the element's language value is performed case-insensitively.
      // The identifier C does not have to be a valid language name."
      // http://www.w3.org/TR/selectors/#lang-pseudo
      "lang": markFunction(function (lang) {
        // lang value must be a valid identifier
        if (!ridentifier.test(lang || "")) {
          Sizzle.error("unsupported lang: " + lang);
        }

        lang = lang.replace(runescape, funescape).toLowerCase();
        return function (elem) {
          var elemLang;

          do {
            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
              elemLang = elemLang.toLowerCase();
              return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
            }
          } while ((elem = elem.parentNode) && elem.nodeType === 1);

          return false;
        };
      }),
      // Miscellaneous
      "target": function (elem) {
        var hash = window.location && window.location.hash;
        return hash && hash.slice(1) === elem.id;
      },
      "root": function (elem) {
        return elem === docElem;
      },
      "focus": function (elem) {
        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
      },
      // Boolean properties
      "enabled": createDisabledPseudo(false),
      "disabled": createDisabledPseudo(true),
      "checked": function (elem) {
        // In CSS3, :checked should return both checked and selected elements
        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
        var nodeName = elem.nodeName.toLowerCase();
        return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
      },
      "selected": function (elem) {
        // Accessing this property makes selected-by-default
        // options in Safari work properly
        if (elem.parentNode) {
          elem.parentNode.selectedIndex;
        }

        return elem.selected === true;
      },
      // Contents
      "empty": function (elem) {
        // http://www.w3.org/TR/selectors/#empty-pseudo
        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
        //   but not by others (comment: 8; processing instruction: 7; etc.)
        // nodeType < 6 works because attributes (2) do not appear as children
        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
          if (elem.nodeType < 6) {
            return false;
          }
        }

        return true;
      },
      "parent": function (elem) {
        return !Expr.pseudos["empty"](elem);
      },
      // Element/input types
      "header": function (elem) {
        return rheader.test(elem.nodeName);
      },
      "input": function (elem) {
        return rinputs.test(elem.nodeName);
      },
      "button": function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === "button" || name === "button";
      },
      "text": function (elem) {
        var attr;
        return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ( // Support: IE<8
        // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
        (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
      },
      // Position-in-collection
      "first": createPositionalPseudo(function () {
        return [0];
      }),
      "last": createPositionalPseudo(function (matchIndexes, length) {
        return [length - 1];
      }),
      "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
        return [argument < 0 ? argument + length : argument];
      }),
      "even": createPositionalPseudo(function (matchIndexes, length) {
        var i = 0;

        for (; i < length; i += 2) {
          matchIndexes.push(i);
        }

        return matchIndexes;
      }),
      "odd": createPositionalPseudo(function (matchIndexes, length) {
        var i = 1;

        for (; i < length; i += 2) {
          matchIndexes.push(i);
        }

        return matchIndexes;
      }),
      "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
        var i = argument < 0 ? argument + length : argument;

        for (; --i >= 0;) {
          matchIndexes.push(i);
        }

        return matchIndexes;
      }),
      "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
        var i = argument < 0 ? argument + length : argument;

        for (; ++i < length;) {
          matchIndexes.push(i);
        }

        return matchIndexes;
      })
    }
  };
  Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

  for (i in {
    radio: true,
    checkbox: true,
    file: true,
    password: true,
    image: true
  }) {
    Expr.pseudos[i] = createInputPseudo(i);
  }

  for (i in {
    submit: true,
    reset: true
  }) {
    Expr.pseudos[i] = createButtonPseudo(i);
  } // Easy API for creating new setFilters


  function setFilters() {}

  setFilters.prototype = Expr.filters = Expr.pseudos;
  Expr.setFilters = new setFilters();

  tokenize = Sizzle.tokenize = function (selector, parseOnly) {
    var matched,
        match,
        tokens,
        type,
        soFar,
        groups,
        preFilters,
        cached = tokenCache[selector + " "];

    if (cached) {
      return parseOnly ? 0 : cached.slice(0);
    }

    soFar = selector;
    groups = [];
    preFilters = Expr.preFilter;

    while (soFar) {
      // Comma and first run
      if (!matched || (match = rcomma.exec(soFar))) {
        if (match) {
          // Don't consume trailing commas as valid
          soFar = soFar.slice(match[0].length) || soFar;
        }

        groups.push(tokens = []);
      }

      matched = false; // Combinators

      if (match = rcombinators.exec(soFar)) {
        matched = match.shift();
        tokens.push({
          value: matched,
          // Cast descendant combinators to space
          type: match[0].replace(rtrim, " ")
        });
        soFar = soFar.slice(matched.length);
      } // Filters


      for (type in Expr.filter) {
        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: type,
            matches: match
          });
          soFar = soFar.slice(matched.length);
        }
      }

      if (!matched) {
        break;
      }
    } // Return the length of the invalid excess
    // if we're just parsing
    // Otherwise, throw an error or return tokens


    return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
    tokenCache(selector, groups).slice(0);
  };

  function toSelector(tokens) {
    var i = 0,
        len = tokens.length,
        selector = "";

    for (; i < len; i++) {
      selector += tokens[i].value;
    }

    return selector;
  }

  function addCombinator(matcher, combinator, base) {
    var dir = combinator.dir,
        skip = combinator.next,
        key = skip || dir,
        checkNonElements = base && key === "parentNode",
        doneName = done++;
    return combinator.first ? // Check against closest ancestor/preceding element
    function (elem, context, xml) {
      while (elem = elem[dir]) {
        if (elem.nodeType === 1 || checkNonElements) {
          return matcher(elem, context, xml);
        }
      }

      return false;
    } : // Check against all ancestor/preceding elements
    function (elem, context, xml) {
      var oldCache,
          uniqueCache,
          outerCache,
          newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

      if (xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            if (matcher(elem, context, xml)) {
              return true;
            }
          }
        }
      } else {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
            // Defend against cloned attroperties (jQuery gh-1709)

            uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

            if (skip && skip === elem.nodeName.toLowerCase()) {
              elem = elem[dir] || elem;
            } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
              // Assign to newCache so results back-propagate to previous elements
              return newCache[2] = oldCache[2];
            } else {
              // Reuse newcache so results back-propagate to previous elements
              uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

              if (newCache[2] = matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        }
      }

      return false;
    };
  }

  function elementMatcher(matchers) {
    return matchers.length > 1 ? function (elem, context, xml) {
      var i = matchers.length;

      while (i--) {
        if (!matchers[i](elem, context, xml)) {
          return false;
        }
      }

      return true;
    } : matchers[0];
  }

  function multipleContexts(selector, contexts, results) {
    var i = 0,
        len = contexts.length;

    for (; i < len; i++) {
      Sizzle(selector, contexts[i], results);
    }

    return results;
  }

  function condense(unmatched, map, filter, context, xml) {
    var elem,
        newUnmatched = [],
        i = 0,
        len = unmatched.length,
        mapped = map != null;

    for (; i < len; i++) {
      if (elem = unmatched[i]) {
        if (!filter || filter(elem, context, xml)) {
          newUnmatched.push(elem);

          if (mapped) {
            map.push(i);
          }
        }
      }
    }

    return newUnmatched;
  }

  function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
    if (postFilter && !postFilter[expando]) {
      postFilter = setMatcher(postFilter);
    }

    if (postFinder && !postFinder[expando]) {
      postFinder = setMatcher(postFinder, postSelector);
    }

    return markFunction(function (seed, results, context, xml) {
      var temp,
          i,
          elem,
          preMap = [],
          postMap = [],
          preexisting = results.length,
          // Get initial elements from seed or context
      elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
          // Prefilter to get matcher input, preserving a map for seed-results synchronization
      matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
          matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
      postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
      [] : // ...otherwise use results directly
      results : matcherIn; // Find primary matches

      if (matcher) {
        matcher(matcherIn, matcherOut, context, xml);
      } // Apply postFilter


      if (postFilter) {
        temp = condense(matcherOut, postMap);
        postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

        i = temp.length;

        while (i--) {
          if (elem = temp[i]) {
            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
          }
        }
      }

      if (seed) {
        if (postFinder || preFilter) {
          if (postFinder) {
            // Get the final matcherOut by condensing this intermediate into postFinder contexts
            temp = [];
            i = matcherOut.length;

            while (i--) {
              if (elem = matcherOut[i]) {
                // Restore matcherIn since elem is not yet a final match
                temp.push(matcherIn[i] = elem);
              }
            }

            postFinder(null, matcherOut = [], temp, xml);
          } // Move matched elements from seed to results to keep them synchronized


          i = matcherOut.length;

          while (i--) {
            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
              seed[temp] = !(results[temp] = elem);
            }
          }
        } // Add elements to results, through postFinder if defined

      } else {
        matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

        if (postFinder) {
          postFinder(null, results, matcherOut, xml);
        } else {
          push.apply(results, matcherOut);
        }
      }
    });
  }

  function matcherFromTokens(tokens) {
    var checkContext,
        matcher,
        j,
        len = tokens.length,
        leadingRelative = Expr.relative[tokens[0].type],
        implicitRelative = leadingRelative || Expr.relative[" "],
        i = leadingRelative ? 1 : 0,
        // The foundational matcher ensures that elements are reachable from top-level context(s)
    matchContext = addCombinator(function (elem) {
      return elem === checkContext;
    }, implicitRelative, true),
        matchAnyContext = addCombinator(function (elem) {
      return indexOf(checkContext, elem) > -1;
    }, implicitRelative, true),
        matchers = [function (elem, context, xml) {
      var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

      checkContext = null;
      return ret;
    }];

    for (; i < len; i++) {
      if (matcher = Expr.relative[tokens[i].type]) {
        matchers = [addCombinator(elementMatcher(matchers), matcher)];
      } else {
        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

        if (matcher[expando]) {
          // Find the next relative operator (if any) for proper handling
          j = ++i;

          for (; j < len; j++) {
            if (Expr.relative[tokens[j].type]) {
              break;
            }
          }

          return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
          tokens.slice(0, i - 1).concat({
            value: tokens[i - 2].type === " " ? "*" : ""
          })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
        }

        matchers.push(matcher);
      }
    }

    return elementMatcher(matchers);
  }

  function matcherFromGroupMatchers(elementMatchers, setMatchers) {
    var bySet = setMatchers.length > 0,
        byElement = elementMatchers.length > 0,
        superMatcher = function (seed, context, xml, results, outermost) {
      var elem,
          j,
          matcher,
          matchedCount = 0,
          i = "0",
          unmatched = seed && [],
          setMatched = [],
          contextBackup = outermostContext,
          // We must always have either seed elements or outermost context
      elems = seed || byElement && Expr.find["TAG"]("*", outermost),
          // Use integer dirruns iff this is the outermost matcher
      dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
          len = elems.length;

      if (outermost) {
        outermostContext = context === document || context || outermost;
      } // Add elements passing elementMatchers directly to results
      // Support: IE<9, Safari
      // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


      for (; i !== len && (elem = elems[i]) != null; i++) {
        if (byElement && elem) {
          j = 0;

          if (!context && elem.ownerDocument !== document) {
            setDocument(elem);
            xml = !documentIsHTML;
          }

          while (matcher = elementMatchers[j++]) {
            if (matcher(elem, context || document, xml)) {
              results.push(elem);
              break;
            }
          }

          if (outermost) {
            dirruns = dirrunsUnique;
          }
        } // Track unmatched elements for set filters


        if (bySet) {
          // They will have gone through all possible matchers
          if (elem = !matcher && elem) {
            matchedCount--;
          } // Lengthen the array for every element, matched or not


          if (seed) {
            unmatched.push(elem);
          }
        }
      } // `i` is now the count of elements visited above, and adding it to `matchedCount`
      // makes the latter nonnegative.


      matchedCount += i; // Apply set filters to unmatched elements
      // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
      // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
      // no element matchers and no seed.
      // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
      // case, which will result in a "00" `matchedCount` that differs from `i` but is also
      // numerically zero.

      if (bySet && i !== matchedCount) {
        j = 0;

        while (matcher = setMatchers[j++]) {
          matcher(unmatched, setMatched, context, xml);
        }

        if (seed) {
          // Reintegrate element matches to eliminate the need for sorting
          if (matchedCount > 0) {
            while (i--) {
              if (!(unmatched[i] || setMatched[i])) {
                setMatched[i] = pop.call(results);
              }
            }
          } // Discard index placeholder values to get only actual matches


          setMatched = condense(setMatched);
        } // Add matches to results


        push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
          Sizzle.uniqueSort(results);
        }
      } // Override manipulation of globals by nested matchers


      if (outermost) {
        dirruns = dirrunsUnique;
        outermostContext = contextBackup;
      }

      return unmatched;
    };

    return bySet ? markFunction(superMatcher) : superMatcher;
  }

  compile = Sizzle.compile = function (selector, match
  /* Internal Use Only */
  ) {
    var i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[selector + " "];

    if (!cached) {
      // Generate a function of recursive functions that can be used to check each element
      if (!match) {
        match = tokenize(selector);
      }

      i = match.length;

      while (i--) {
        cached = matcherFromTokens(match[i]);

        if (cached[expando]) {
          setMatchers.push(cached);
        } else {
          elementMatchers.push(cached);
        }
      } // Cache the compiled function


      cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

      cached.selector = selector;
    }

    return cached;
  };
  /**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */


  select = Sizzle.select = function (selector, context, results, seed) {
    var i,
        tokens,
        token,
        type,
        find,
        compiled = typeof selector === "function" && selector,
        match = !seed && tokenize(selector = compiled.selector || selector);
    results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
    // (the latter of which guarantees us context)

    if (match.length === 1) {
      // Reduce context if the leading compound selector is an ID
      tokens = match[0] = match[0].slice(0);

      if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
        context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

        if (!context) {
          return results; // Precompiled matchers will still verify ancestry, so step up a level
        } else if (compiled) {
          context = context.parentNode;
        }

        selector = selector.slice(tokens.shift().value.length);
      } // Fetch a seed set for right-to-left matching


      i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

      while (i--) {
        token = tokens[i]; // Abort if we hit a combinator

        if (Expr.relative[type = token.type]) {
          break;
        }

        if (find = Expr.find[type]) {
          // Search, expanding context for leading sibling combinators
          if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
            // If seed is empty or no tokens remain, we can return early
            tokens.splice(i, 1);
            selector = seed.length && toSelector(tokens);

            if (!selector) {
              push.apply(results, seed);
              return results;
            }

            break;
          }
        }
      }
    } // Compile and execute a filtering function if one is not provided
    // Provide `match` to avoid retokenization if we modified the selector above


    (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
    return results;
  }; // One-time assignments
  // Sort stability


  support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
  // Always assume duplicates if they aren't passed to the comparison function

  support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

  setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
  // Detached nodes confoundingly follow *each other*

  support.sortDetached = assert(function (el) {
    // Should return 1, but returns 4 (following)
    return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
  }); // Support: IE<8
  // Prevent attribute/property "interpolation"
  // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

  if (!assert(function (el) {
    el.innerHTML = "<a href='#'></a>";
    return el.firstChild.getAttribute("href") === "#";
  })) {
    addHandle("type|href|height|width", function (elem, name, isXML) {
      if (!isXML) {
        return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
      }
    });
  } // Support: IE<9
  // Use defaultValue in place of getAttribute("value")


  if (!support.attributes || !assert(function (el) {
    el.innerHTML = "<input/>";
    el.firstChild.setAttribute("value", "");
    return el.firstChild.getAttribute("value") === "";
  })) {
    addHandle("value", function (elem, name, isXML) {
      if (!isXML && elem.nodeName.toLowerCase() === "input") {
        return elem.defaultValue;
      }
    });
  } // Support: IE<9
  // Use getAttributeNode to fetch booleans when getAttribute lies


  if (!assert(function (el) {
    return el.getAttribute("disabled") == null;
  })) {
    addHandle(booleans, function (elem, name, isXML) {
      var val;

      if (!isXML) {
        return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
      }
    });
  } // EXPOSE


  var _sizzle = window.Sizzle;

  Sizzle.noConflict = function () {
    if (window.Sizzle === Sizzle) {
      window.Sizzle = _sizzle;
    }

    return Sizzle;
  };

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return Sizzle;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // Sizzle requires that there be a global window in Common-JS like environments
  } else {} // EXPOSE

})(window);

/***/ }),

/***/ "D0Jr":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/var/hasOwn.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./class2type */ "FDjK")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (class2type) {
  "use strict";

  return class2type.hasOwnProperty;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "Dc8T":
/*!****************************************************!*\
  !*** ./node_modules/jquery/src/ajax/var/rquery.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return /\?/;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "E9Km":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/event/ajax.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../event */ "Y7H9")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict"; // Attach a bunch of functions for handling common AJAX events

  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "F7/y":
/*!**************************************************!*\
  !*** ./node_modules/jquery/src/event/focusin.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../data/var/dataPriv */ "082X"), __webpack_require__(/*! ./support */ "R5lg"), __webpack_require__(/*! ../event */ "Y7H9"), __webpack_require__(/*! ./trigger */ "l58E")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, dataPriv, support) {
  "use strict"; // Support: Firefox <=44
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857

  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function (orig, fix) {
      // Attach a single capturing handler on the document while someone wants focusin/focusout
      var handler = function (event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };

      jQuery.event.special[fix] = {
        setup: function () {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix);

          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }

          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function () {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix) - 1;

          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }

  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "F83J":
/*!*******************************************************!*\
  !*** ./node_modules/jquery/src/attributes/support.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/document */ "iprW"), __webpack_require__(/*! ../var/support */ "hFd1")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (document, support) {
  "use strict";

  (function () {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox"; // Support: Android <=4.3 only
    // Default value for a checkbox should be "on"

    support.checkOn = input.value !== ""; // Support: IE <=11 only
    // Must access selectedIndex to make default options select

    support.optSelected = opt.selected; // Support: IE <=11 only
    // An input loses its value after becoming a radio

    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();

  return support;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "FDjK":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/var/class2type.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict"; // [[Class]] -> type pairs

  return {};
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "FbHE":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/var/rcssNum.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/pnum */ "UQHn")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (pnum) {
  "use strict";

  return new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "G5n7":
/*!*********************************************!*\
  !*** ./node_modules/jquery/src/deferred.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./var/isFunction */ "s44h"), __webpack_require__(/*! ./var/slice */ "QQxG"), __webpack_require__(/*! ./callbacks */ "hX6M")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, isFunction, slice) {
  "use strict";

  function Identity(v) {
    return v;
  }

  function Thrower(ex) {
    throw ex;
  }

  function adoptValue(value, resolve, reject, noValue) {
    var method;

    try {
      // Check for promise aspect first to privilege synchronous behavior
      if (value && isFunction(method = value.promise)) {
        method.call(value).done(resolve).fail(reject); // Other thenables
      } else if (value && isFunction(method = value.then)) {
        method.call(value, resolve, reject); // Other non-thenables
      } else {
        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
        // * false: [ value ].slice( 0 ) => resolve( value )
        // * true: [ value ].slice( 1 ) => resolve()
        resolve.apply(undefined, [value].slice(noValue));
      } // For Promises/A+, convert exceptions into rejections
      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
      // Deferred#then to conditionally suppress rejection.

    } catch (value) {
      // Support: Android 4.0 only
      // Strict mode functions invoked without .call/.apply get global-object context
      reject.apply(undefined, [value]);
    }
  }

  jQuery.extend({
    Deferred: function (func) {
      var tuples = [// action, add listener, callbacks,
      // ... .then handlers, argument index, [final state]
      ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
          state = "pending",
          promise = {
        state: function () {
          return state;
        },
        always: function () {
          deferred.done(arguments).fail(arguments);
          return this;
        },
        "catch": function (fn) {
          return promise.then(null, fn);
        },
        // Keep pipe for back-compat
        pipe: function ()
        /* fnDone, fnFail, fnProgress */
        {
          var fns = arguments;
          return jQuery.Deferred(function (newDefer) {
            jQuery.each(tuples, function (i, tuple) {
              // Map tuples (progress, done, fail) to arguments (done, fail, progress)
              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
              // deferred.done(function() { bind to newDefer or newDefer.resolve })
              // deferred.fail(function() { bind to newDefer or newDefer.reject })

              deferred[tuple[1]](function () {
                var returned = fn && fn.apply(this, arguments);

                if (returned && isFunction(returned.promise)) {
                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                } else {
                  newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                }
              });
            });
            fns = null;
          }).promise();
        },
        then: function (onFulfilled, onRejected, onProgress) {
          var maxDepth = 0;

          function resolve(depth, deferred, handler, special) {
            return function () {
              var that = this,
                  args = arguments,
                  mightThrow = function () {
                var returned, then; // Support: Promises/A+ section 2.3.3.3.3
                // https://promisesaplus.com/#point-59
                // Ignore double-resolution attempts

                if (depth < maxDepth) {
                  return;
                }

                returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
                // https://promisesaplus.com/#point-48

                if (returned === deferred.promise()) {
                  throw new TypeError("Thenable self-resolution");
                } // Support: Promises/A+ sections 2.3.3.1, 3.5
                // https://promisesaplus.com/#point-54
                // https://promisesaplus.com/#point-75
                // Retrieve `then` only once


                then = returned && ( // Support: Promises/A+ section 2.3.4
                // https://promisesaplus.com/#point-64
                // Only check objects and functions for thenability
                typeof returned === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

                if (isFunction(then)) {
                  // Special processors (notify) just wait for resolution
                  if (special) {
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
                  } else {
                    // ...and disregard older resolution values
                    maxDepth++;
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                  } // Handle all other returned values

                } else {
                  // Only substitute handlers pass on context
                  // and multiple values (non-spec behavior)
                  if (handler !== Identity) {
                    that = undefined;
                    args = [returned];
                  } // Process the value(s)
                  // Default process is resolve


                  (special || deferred.resolveWith)(that, args);
                }
              },
                  // Only normal processors (resolve) catch and reject exceptions
              process = special ? mightThrow : function () {
                try {
                  mightThrow();
                } catch (e) {
                  if (jQuery.Deferred.exceptionHook) {
                    jQuery.Deferred.exceptionHook(e, process.stackTrace);
                  } // Support: Promises/A+ section 2.3.3.3.4.1
                  // https://promisesaplus.com/#point-61
                  // Ignore post-resolution exceptions


                  if (depth + 1 >= maxDepth) {
                    // Only substitute handlers pass on context
                    // and multiple values (non-spec behavior)
                    if (handler !== Thrower) {
                      that = undefined;
                      args = [e];
                    }

                    deferred.rejectWith(that, args);
                  }
                }
              }; // Support: Promises/A+ section 2.3.3.3.1
              // https://promisesaplus.com/#point-57
              // Re-resolve promises immediately to dodge false rejection from
              // subsequent errors


              if (depth) {
                process();
              } else {
                // Call an optional hook to record the stack, in case of exception
                // since it's otherwise lost when execution goes async
                if (jQuery.Deferred.getStackHook) {
                  process.stackTrace = jQuery.Deferred.getStackHook();
                }

                window.setTimeout(process);
              }
            };
          }

          return jQuery.Deferred(function (newDefer) {
            // progress_handlers.add( ... )
            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
          }).promise();
        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function (obj) {
          return obj != null ? jQuery.extend(obj, promise) : promise;
        }
      },
          deferred = {}; // Add list-specific methods

      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2],
            stateString = tuple[5]; // promise.progress = list.add
        // promise.done = list.add
        // promise.fail = list.add

        promise[tuple[1]] = list.add; // Handle state

        if (stateString) {
          list.add(function () {
            // state = "resolved" (i.e., fulfilled)
            // state = "rejected"
            state = stateString;
          }, // rejected_callbacks.disable
          // fulfilled_callbacks.disable
          tuples[3 - i][2].disable, // rejected_handlers.disable
          // fulfilled_handlers.disable
          tuples[3 - i][3].disable, // progress_callbacks.lock
          tuples[0][2].lock, // progress_handlers.lock
          tuples[0][3].lock);
        } // progress_handlers.fire
        // fulfilled_handlers.fire
        // rejected_handlers.fire


        list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
        // deferred.resolve = function() { deferred.resolveWith(...) }
        // deferred.reject = function() { deferred.rejectWith(...) }

        deferred[tuple[0]] = function () {
          deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
          return this;
        }; // deferred.notifyWith = list.fireWith
        // deferred.resolveWith = list.fireWith
        // deferred.rejectWith = list.fireWith


        deferred[tuple[0] + "With"] = list.fireWith;
      }); // Make the deferred a promise

      promise.promise(deferred); // Call given func if any

      if (func) {
        func.call(deferred, deferred);
      } // All done!


      return deferred;
    },
    // Deferred helper
    when: function (singleValue) {
      var // count of uncompleted subordinates
      remaining = arguments.length,
          // count of unprocessed arguments
      i = remaining,
          // subordinate fulfillment data
      resolveContexts = Array(i),
          resolveValues = slice.call(arguments),
          // the master Deferred
      master = jQuery.Deferred(),
          // subordinate callback factory
      updateFunc = function (i) {
        return function (value) {
          resolveContexts[i] = this;
          resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;

          if (! --remaining) {
            master.resolveWith(resolveContexts, resolveValues);
          }
        };
      }; // Single- and empty arguments are adopted like Promise.resolve


      if (remaining <= 1) {
        adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)

        if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
          return master.then();
        }
      } // Multiple arguments are aggregated like Promise.all array elements


      while (i--) {
        adoptValue(resolveValues[i], updateFunc(i), master.reject);
      }

      return master.promise();
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "GHrk":
/*!*********************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/support.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/document */ "iprW"), __webpack_require__(/*! ../var/support */ "hFd1")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (document, support) {
  "use strict";

  (function () {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input"); // Support: Android 4.0 - 4.3 only
    // Check state lost if the name is set (#11217)
    // Support: Windows Web Apps (WWA)
    // `name` and `type` must use .setAttribute for WWA (#14901)

    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input); // Support: Android <=4.1 only
    // Older WebKit doesn't clone checked state correctly in fragments

    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
    // Make sure textarea (and checkbox) defaultValue is properly cloned

    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();

  return support;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "HATn":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/var/fnToString.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./hasOwn */ "D0Jr")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (hasOwn) {
  "use strict";

  return hasOwn.toString;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "JPst":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader

module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return '@media ' + item[2] + '{' + content + '}';
      } else {
        return content;
      }
    }).join('');
  }; // import a list of modules into the list


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (i = 0; i < modules.length; i++) {
      var item = modules[i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || '';
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
  return '/*# ' + data + ' */';
}

/***/ }),

/***/ "Jsk8":
/*!**************************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/var/rtagName.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "KHd+":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "Knyl":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/ajax/jsonp.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../var/isFunction */ "s44h"), __webpack_require__(/*! ./var/nonce */ "/vyx"), __webpack_require__(/*! ./var/rquery */ "Dc8T"), __webpack_require__(/*! ../ajax */ "06dU")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, isFunction, nonce, rquery) {
  "use strict";

  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function () {
      var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
      this[callback] = true;
      return callback;
    }
  }); // Detect, normalize options and install callbacks for jsonp requests

  jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

    if (jsonProp || s.dataTypes[0] === "jsonp") {
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      } // Use data converter to retrieve json after script execution


      s.converters["script json"] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }

        return responseContainer[0];
      }; // Force json dataType


      s.dataTypes[0] = "json"; // Install callback

      overwritten = window[callbackName];

      window[callbackName] = function () {
        responseContainer = arguments;
      }; // Clean-up function (fires after converters)


      jqXHR.always(function () {
        // If previous value didn't exist - remove it
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value
        } else {
          window[callbackName] = overwritten;
        } // Save back as free


        if (s[callbackName]) {
          // Make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use

          oldCallbacks.push(callbackName);
        } // Call if it was a function and we have a response


        if (responseContainer && isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }

        responseContainer = overwritten = undefined;
      }); // Delegate to script

      return "script";
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "KsYY":
/*!*******************************************************!*\
  !*** ./node_modules/jquery/src/traversing/var/dir.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../../core */ "mEBU")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  return function (elem, dir, until) {
    var matched = [],
        truncate = until !== undefined;

    while ((elem = elem[dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }

        matched.push(elem);
      }
    }

    return matched;
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "Lps/":
/*!***************************************************************!*\
  !*** ./node_modules/jquery/src/css/var/isHiddenWithinTree.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../../core */ "mEBU"), __webpack_require__(/*! ../../selector */ "dyyg") // css is assumed
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict"; // isHiddenWithinTree reports if an element has a non-"none" display style (inline and/or
  // through the CSS cascade), which is useful in deciding whether or not to make it visible.
  // It differs from the :hidden selector (jQuery.expr.pseudos.hidden) in two important ways:
  // * A hidden ancestor does not force an element to be classified as hidden.
  // * Being disconnected from the document does not force an element to be classified as hidden.
  // These differences improve the behavior of .toggle() et al. when applied to elements that are
  // detached or contained within hidden ancestors (gh-2404, gh-2863).

  return function (elem, el) {
    // isHiddenWithinTree might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem; // Inline style trumps all

    return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
    // Support: Firefox <=43 - 45
    // Disconnected elements can have computed display: none, so first confirm that elem is
    // in the document.
    jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "MT+g":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/core/access.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../core/toType */ "VAby"), __webpack_require__(/*! ../var/isFunction */ "s44h")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, toType, isFunction) {
  "use strict"; // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function

  var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null; // Sets many values

    if (toType(key) === "object") {
      chainable = true;

      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      } // Sets one value

    } else if (value !== undefined) {
      chainable = true;

      if (!isFunction(value)) {
        raw = true;
      }

      if (bulk) {
        // Bulk operations run against the entire set
        if (raw) {
          fn.call(elems, value);
          fn = null; // ...except when executing function values
        } else {
          bulk = fn;

          fn = function (elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }

      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }

    if (chainable) {
      return elems;
    } // Gets


    if (bulk) {
      return fn.call(elems);
    }

    return len ? fn(elems[0], key) : emptyGet;
  };

  return access;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "MsD2":
/*!**********************************************!*\
  !*** ./node_modules/jquery/src/core/init.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Initialize a jQuery object
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../var/document */ "iprW"), __webpack_require__(/*! ../var/isFunction */ "s44h"), __webpack_require__(/*! ./var/rsingleTag */ "eTAU"), __webpack_require__(/*! ../traversing/findFilter */ "R026")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document, isFunction, rsingleTag) {
  "use strict"; // A central reference to the root jQuery(document)

  var rootjQuery,
      // A simple way to check for HTML strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  // Strict HTML recognition (#11290: must start with <)
  // Shortcut simple #id case for speed
  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
      init = jQuery.fn.init = function (selector, context, root) {
    var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

    if (!selector) {
      return this;
    } // Method init() accepts an alternate rootjQuery
    // so migrate can support jQuery.sub (gh-2101)


    root = root || rootjQuery; // Handle HTML strings

    if (typeof selector === "string") {
      if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [null, selector, null];
      } else {
        match = rquickExpr.exec(selector);
      } // Match html or make sure no context is specified for #id


      if (match && (match[1] || !context)) {
        // HANDLE: $(html) -> $(array)
        if (match[1]) {
          context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
          // Intentionally let the error be thrown if parseHTML is not present

          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
            for (match in context) {
              // Properties of context are called as methods if possible
              if (isFunction(this[match])) {
                this[match](context[match]); // ...and otherwise set as attributes
              } else {
                this.attr(match, context[match]);
              }
            }
          }

          return this; // HANDLE: $(#id)
        } else {
          elem = document.getElementById(match[2]);

          if (elem) {
            // Inject the element directly into the jQuery object
            this[0] = elem;
            this.length = 1;
          }

          return this;
        } // HANDLE: $(expr, $(...))

      } else if (!context || context.jquery) {
        return (context || root).find(selector); // HANDLE: $(expr, context)
        // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor(context).find(selector);
      } // HANDLE: $(DOMElement)

    } else if (selector.nodeType) {
      this[0] = selector;
      this.length = 1;
      return this; // HANDLE: $(function)
      // Shortcut for document ready
    } else if (isFunction(selector)) {
      return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
      selector(jQuery);
    }

    return jQuery.makeArray(selector, this);
  }; // Give the init function the jQuery prototype for later instantiation


  init.prototype = jQuery.fn; // Initialize central reference

  rootjQuery = jQuery(document);
  return init;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "NKsO":
/*!**************************************************!*\
  !*** ./node_modules/jquery/src/core/nodeName.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  function nodeName(elem, name) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  }

  ;
  return nodeName;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "NYe2":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/deprecated.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./core/nodeName */ "NKsO"), __webpack_require__(/*! ./core/camelCase */ "jz24"), __webpack_require__(/*! ./core/toType */ "VAby"), __webpack_require__(/*! ./var/isFunction */ "s44h"), __webpack_require__(/*! ./var/isWindow */ "16XX"), __webpack_require__(/*! ./var/slice */ "QQxG"), __webpack_require__(/*! ./event/alias */ "YefD")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, nodeName, camelCase, toType, isFunction, isWindow, slice) {
  "use strict";

  jQuery.fn.extend({
    bind: function (types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function (types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function (selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function (selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  }); // Bind a function to a context, optionally partially applying any
  // arguments.
  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  // However, it is not slated for removal any time soon

  jQuery.proxy = function (fn, context) {
    var tmp, args, proxy;

    if (typeof context === "string") {
      tmp = fn[context];
      context = fn;
      fn = tmp;
    } // Quick check to determine if target is callable, in the spec
    // this throws a TypeError, but we will just return undefined.


    if (!isFunction(fn)) {
      return undefined;
    } // Simulated bind


    args = slice.call(arguments, 2);

    proxy = function () {
      return fn.apply(context || this, args.concat(slice.call(arguments)));
    }; // Set the guid of unique handler to the same of original handler, so it can be removed


    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    return proxy;
  };

  jQuery.holdReady = function (hold) {
    if (hold) {
      jQuery.readyWait++;
    } else {
      jQuery.ready(true);
    }
  };

  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;
  jQuery.now = Date.now;

  jQuery.isNumeric = function (obj) {
    // As of jQuery 3.0, isNumeric is limited to
    // strings and numbers (primitives or objects)
    // that can be coerced to finite numbers (gh-2662)
    var type = jQuery.type(obj);
    return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    !isNaN(obj - parseFloat(obj));
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "P+Hb":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/css/var/cssExpand.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return ["Top", "Right", "Bottom", "Left"];
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "PRQw":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/manipulation.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./var/concat */ "4U/f"), __webpack_require__(/*! ./var/isFunction */ "s44h"), __webpack_require__(/*! ./var/push */ "y2oz"), __webpack_require__(/*! ./core/access */ "MT+g"), __webpack_require__(/*! ./manipulation/var/rcheckableType */ "+PHv"), __webpack_require__(/*! ./manipulation/var/rtagName */ "Jsk8"), __webpack_require__(/*! ./manipulation/var/rscriptType */ "Reib"), __webpack_require__(/*! ./manipulation/wrapMap */ "wqe2"), __webpack_require__(/*! ./manipulation/getAll */ "rwP8"), __webpack_require__(/*! ./manipulation/setGlobalEval */ "4wmo"), __webpack_require__(/*! ./manipulation/buildFragment */ "dxuR"), __webpack_require__(/*! ./manipulation/support */ "GHrk"), __webpack_require__(/*! ./data/var/dataPriv */ "082X"), __webpack_require__(/*! ./data/var/dataUser */ "aAjK"), __webpack_require__(/*! ./data/var/acceptData */ "T3mA"), __webpack_require__(/*! ./core/DOMEval */ "+y+W"), __webpack_require__(/*! ./core/nodeName */ "NKsO"), __webpack_require__(/*! ./core/init */ "MsD2"), __webpack_require__(/*! ./traversing */ "wkHr"), __webpack_require__(/*! ./selector */ "dyyg"), __webpack_require__(/*! ./event */ "Y7H9")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, concat, isFunction, push, access, rcheckableType, rtagName, rscriptType, wrapMap, getAll, setGlobalEval, buildFragment, support, dataPriv, dataUser, acceptData, DOMEval, nodeName) {
  "use strict";

  var
  /* eslint-disable max-len */
  // See https://github.com/eslint/eslint/issues/3229
  rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

  /* eslint-enable */
  // Support: IE <=10 - 11, Edge 12 - 13 only
  // In IE/Edge using regex groups here causes severe slowdowns.
  // See https://connect.microsoft.com/IE/feedback/details/1736512/
  rnoInnerhtml = /<script|<style|<link/i,
      // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; // Prefer a tbody over its parent table for containing new rows

  function manipulationTarget(elem, content) {
    if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
      return jQuery(elem).children("tbody")[0] || elem;
    }

    return elem;
  } // Replace/restore the type attribute of script elements for safe DOM manipulation


  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }

  function restoreScript(elem) {
    if ((elem.type || "").slice(0, 5) === "true/") {
      elem.type = elem.type.slice(5);
    } else {
      elem.removeAttribute("type");
    }

    return elem;
  }

  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

    if (dest.nodeType !== 1) {
      return;
    } // 1. Copy private data: events, handlers, etc.


    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.access(src);
      pdataCur = dataPriv.set(dest, pdataOld);
      events = pdataOld.events;

      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};

        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    } // 2. Copy user data


    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  } // Fix IE bugs, see support tests


  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }

  function domManip(collection, args, callback, ignored) {
    // Flatten any nested arrays
    args = concat.apply([], args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

    if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
      return collection.each(function (index) {
        var self = collection.eq(index);

        if (valueIsFunction) {
          args[0] = value.call(this, index, self.html());
        }

        domManip(self, args, callback, ignored);
      });
    }

    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;

      if (fragment.childNodes.length === 1) {
        fragment = first;
      } // Require either new content or an interest in ignored elements to invoke the callback


      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length; // Use the original fragment for the last item
        // instead of the first because it can end up
        // being emptied incorrectly in certain situations (#8070).

        for (; i < l; i++) {
          node = fragment;

          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

            if (hasScripts) {
              // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }

          callback.call(collection[i], node, i);
        }

        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

          jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];

            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src && (node.type || "").toLowerCase() !== "module") {
                // Optional AJAX dependency, but won't run scripts if not present
                if (jQuery._evalUrl) {
                  jQuery._evalUrl(node.src);
                }
              } else {
                DOMEval(node.textContent.replace(rcleanScript, ""), doc, node);
              }
            }
          }
        }
      }
    }

    return collection;
  }

  function remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;

    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }

      if (node.parentNode) {
        if (keepData && jQuery.contains(node.ownerDocument, node)) {
          setGlobalEval(getAll(node, "script"));
        }

        node.parentNode.removeChild(node);
      }
    }

    return elem;
  }

  jQuery.extend({
    htmlPrefilter: function (html) {
      return html.replace(rxhtmlTag, "<$1></$2>");
    },
    clone: function (elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = jQuery.contains(elem.ownerDocument, elem); // Fix IE cloning issues

      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
        destElements = getAll(clone);
        srcElements = getAll(elem);

        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      } // Copy the events from the original to the clone


      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);

          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      } // Preserve script evaluation history


      destElements = getAll(clone, "script");

      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      } // Return the cloned set


      return clone;
    },
    cleanData: function (elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;

      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if (data = elem[dataPriv.expando]) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            } // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove


            elem[dataPriv.expando] = undefined;
          }

          if (elem[dataUser.expando]) {
            // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    detach: function (selector) {
      return remove(this, selector, true);
    },
    remove: function (selector) {
      return remove(this, selector);
    },
    text: function (value) {
      return access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function () {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function () {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function () {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function () {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function () {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function () {
      var elem,
          i = 0;

      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          // Prevent memory leaks
          jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

          elem.textContent = "";
        }
      }

      return this;
    },
    clone: function (dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function (value) {
      return access(this, function (value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;

        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        } // See if we can take a shortcut and just use innerHTML


        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);

          try {
            for (; i < l; i++) {
              elem = this[i] || {}; // Remove element nodes and prevent memory leaks

              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }

            elem = 0; // If using innerHTML throws an exception, use the fallback method
          } catch (e) {}
        }

        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function () {
      var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

      return domManip(this, arguments, function (elem) {
        var parent = this.parentNode;

        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));

          if (parent) {
            parent.replaceChild(elem, this);
          }
        } // Force callback invocation

      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;

      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
        // .get() because push.apply(_, arraylike) throws on ancient WebKit

        push.apply(ret, elems.get());
      }

      return this.pushStack(ret);
    };
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "QQxG":
/*!**********************************************!*\
  !*** ./node_modules/jquery/src/var/slice.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./arr */ "xccy")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (arr) {
  "use strict";

  return arr.slice;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "Qlux":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/ajax/script.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../var/document */ "iprW"), __webpack_require__(/*! ../ajax */ "06dU")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document) {
  "use strict"; // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)

  jQuery.ajaxPrefilter(function (s) {
    if (s.crossDomain) {
      s.contents.script = false;
    }
  }); // Install script dataType

  jQuery.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function (text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  }); // Handle cache's special case and crossDomain

  jQuery.ajaxPrefilter("script", function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }

    if (s.crossDomain) {
      s.type = "GET";
    }
  }); // Bind script tag hack transport

  jQuery.ajaxTransport("script", function (s) {
    // This transport only deals with cross domain requests
    if (s.crossDomain) {
      var script, callback;
      return {
        send: function (_, complete) {
          script = jQuery("<script>").prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", callback = function (evt) {
            script.remove();
            callback = null;

            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          }); // Use native DOM manipulation to avoid our domManip AJAX trickery

          document.head.appendChild(script[0]);
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "Qvwh":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/css/curCSS.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ./var/rboxStyle */ "ikax"), __webpack_require__(/*! ./var/rnumnonpx */ "xLti"), __webpack_require__(/*! ./var/getStyles */ "kKdo"), __webpack_require__(/*! ./support */ "T4+F"), __webpack_require__(/*! ../selector */ "dyyg") // Get jQuery.contains
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, rboxStyle, rnumnonpx, getStyles, support) {
  "use strict";

  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        // Support: Firefox 51+
    // Retrieving style before computed somehow
    // fixes an issue with getting wrong values
    // on detached elements
    style = elem.style;
    computed = computed || getStyles(elem); // getPropertyValue is needed for:
    //   .css('filter') (IE 9 only, #12537)
    //   .css('--customProperty) (#3144)

    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];

      if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      } // A tribute to the "awesome hack by Dean Edwards"
      // Android Browser returns percentage for some values,
      // but width seems to be reliably pixels.
      // This is against the CSSOM draft spec:
      // https://drafts.csswg.org/cssom/#resolved-values


      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
        // Remember the original values
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth; // Put in the new values to get a computed value out

        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width; // Revert the changed values

        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }

    return ret !== undefined ? // Support: IE <=9 - 11 only
    // IE returns zIndex value as an integer.
    ret + "" : ret;
  }

  return curCSS;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "R026":
/*!**********************************************************!*\
  !*** ./node_modules/jquery/src/traversing/findFilter.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../var/indexOf */ "ePh3"), __webpack_require__(/*! ../var/isFunction */ "s44h"), __webpack_require__(/*! ./var/rneedsContext */ "65MQ"), __webpack_require__(/*! ../selector */ "dyyg")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, indexOf, isFunction, rneedsContext) {
  "use strict"; // Implement the identical functionality for filter and not

  function winnow(elements, qualifier, not) {
    if (isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    } // Single element


    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    } // Arraylike of elements (jQuery, arguments, Array)


    if (typeof qualifier !== "string") {
      return jQuery.grep(elements, function (elem) {
        return indexOf.call(qualifier, elem) > -1 !== not;
      });
    } // Filtered directly for both simple and complex selectors


    return jQuery.filter(qualifier, elements, not);
  }

  jQuery.filter = function (expr, elems, not) {
    var elem = elems[0];

    if (not) {
      expr = ":not(" + expr + ")";
    }

    if (elems.length === 1 && elem.nodeType === 1) {
      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
    }

    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
      return elem.nodeType === 1;
    }));
  };

  jQuery.fn.extend({
    find: function (selector) {
      var i,
          ret,
          len = this.length,
          self = this;

      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }

      ret = this.pushStack([]);

      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }

      return len > 1 ? jQuery.uniqueSort(ret) : ret;
    },
    filter: function (selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function (selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function (selector) {
      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "R5lg":
/*!**************************************************!*\
  !*** ./node_modules/jquery/src/event/support.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/support */ "hFd1")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (support) {
  "use strict";

  support.focusin = "onfocusin" in window;
  return support;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "Reib":
/*!*****************************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/var/rscriptType.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return /^$|^module$|\/(?:java|ecma)script/i;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "SZ7m":
/*!**************************************************************!*\
  !*** ./node_modules/vue-style-loader/lib/addStylesClient.js ***!
  \**************************************************************/
/*! exports provided: default */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return addStylesClient; });
/* harmony import */ var _listToStyles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./listToStyles */ "m7xV");
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/



var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = Object(_listToStyles__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = Object(_listToStyles__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),

/***/ "Snig":
/*!***************************************************************!*\
  !*** ./node_modules/jquery/src/css/hiddenVisibleSelectors.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../selector */ "dyyg")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  jQuery.expr.pseudos.hidden = function (elem) {
    return !jQuery.expr.pseudos.visible(elem);
  };

  jQuery.expr.pseudos.visible = function (elem) {
    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "T0SL":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/exports/global.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, noGlobal) {
  "use strict";

  var // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,
      // Map over the $ in case of overwrite
  _$ = window.$;

  jQuery.noConflict = function (deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }

    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }

    return jQuery;
  }; // Expose jQuery and $ identifiers, even in AMD
  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)


  if (!noGlobal) {
    window.jQuery = window.$ = jQuery;
  }
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "T3mA":
/*!********************************************************!*\
  !*** ./node_modules/jquery/src/data/var/acceptData.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";
  /**
   * Determines whether an object can have data
   */

  return function (owner) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "T4+F":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/css/support.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../var/document */ "iprW"), __webpack_require__(/*! ../var/documentElement */ "tz86"), __webpack_require__(/*! ../var/support */ "hFd1")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document, documentElement, support) {
  "use strict";

  (function () {
    // Executing both pixelPosition & boxSizingReliable tests require only one layout
    // so they're executed at the same time to save the second computation.
    function computeStyleTests() {
      // This is a singleton, we need to execute it only once
      if (!div) {
        return;
      }

      container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
      div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
      documentElement.appendChild(container).appendChild(div);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
      // Some styles come back with percentage values, even though they shouldn't

      div.style.right = "60%";
      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only
      // Detect misreporting of content dimensions for box-sizing:border-box elements

      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only
      // Detect overflow:scroll screwiness (gh-3699)

      div.style.position = "absolute";
      scrollboxSizeVal = div.offsetWidth === 36 || "absolute";
      documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
      // it will also be a sign that checks already performed

      div = null;
    }

    function roundPixelMeasures(measure) {
      return Math.round(parseFloat(measure));
    }

    var pixelPositionVal,
        boxSizingReliableVal,
        scrollboxSizeVal,
        pixelBoxStylesVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div"); // Finish early in limited (non-browser) environments

    if (!div.style) {
      return;
    } // Support: IE <=9 - 11 only
    // Style of cloned element affects source element cloned (#8908)


    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    jQuery.extend(support, {
      boxSizingReliable: function () {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelBoxStyles: function () {
        computeStyleTests();
        return pixelBoxStylesVal;
      },
      pixelPosition: function () {
        computeStyleTests();
        return pixelPositionVal;
      },
      reliableMarginLeft: function () {
        computeStyleTests();
        return reliableMarginLeftVal;
      },
      scrollboxSize: function () {
        computeStyleTests();
        return scrollboxSizeVal;
      }
    });
  })();

  return support;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "UQHn":
/*!*********************************************!*\
  !*** ./node_modules/jquery/src/var/pnum.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "URgk":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(/*! setimmediate */ "YBdB"); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "yLpj")))

/***/ }),

/***/ "VAby":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/core/toType.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/class2type */ "FDjK"), __webpack_require__(/*! ../var/toString */ "jbNc")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (class2type, toString) {
  "use strict";

  function toType(obj) {
    if (obj == null) {
      return obj + "";
    } // Support: Android <=2.3 only (functionish RegExp)


    return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
  }

  return toType;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "VK0Q":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/var/rnothtmlwhite.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict"; // Only count HTML whitespace
  // Other whitespace should count in values
  // https://infra.spec.whatwg.org/#ascii-whitespace

  return /[^\x20\t\r\n\f]+/g;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "Wwic":
/*!**********************************************!*\
  !*** ./node_modules/jquery/src/data/Data.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../core/camelCase */ "jz24"), __webpack_require__(/*! ../var/rnothtmlwhite */ "VK0Q"), __webpack_require__(/*! ./var/acceptData */ "T3mA")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, camelCase, rnothtmlwhite, acceptData) {
  "use strict";

  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }

  Data.uid = 1;
  Data.prototype = {
    cache: function (owner) {
      // Check if the owner object already has a cache
      var value = owner[this.expando]; // If not, create one

      if (!value) {
        value = {}; // We can accept data for non-element nodes in modern browsers,
        // but we should not, see #8335.
        // Always return an empty object.

        if (acceptData(owner)) {
          // If it is a node unlikely to be stringify-ed or looped over
          // use plain assignment
          if (owner.nodeType) {
            owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
            // configurable must be true to allow the property to be
            // deleted when data is removed
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }

      return value;
    },
    set: function (owner, data, value) {
      var prop,
          cache = this.cache(owner); // Handle: [ owner, key, value ] args
      // Always use camelCase key (gh-2257)

      if (typeof data === "string") {
        cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args
      } else {
        // Copy the properties one-by-one to the cache object
        for (prop in data) {
          cache[camelCase(prop)] = data[prop];
        }
      }

      return cache;
    },
    get: function (owner, key) {
      return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
      owner[this.expando] && owner[this.expando][camelCase(key)];
    },
    access: function (owner, key, value) {
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if (key === undefined || key && typeof key === "string" && value === undefined) {
        return this.get(owner, key);
      } // When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //


      this.set(owner, key, value); // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]

      return value !== undefined ? value : key;
    },
    remove: function (owner, key) {
      var i,
          cache = owner[this.expando];

      if (cache === undefined) {
        return;
      }

      if (key !== undefined) {
        // Support array or space separated string of keys
        if (Array.isArray(key)) {
          // If key is an array of keys...
          // We always set camelCase keys, so remove that.
          key = key.map(camelCase);
        } else {
          key = camelCase(key); // If a key with the spaces exists, use it.
          // Otherwise, create an array by matching non-whitespace

          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
        }

        i = key.length;

        while (i--) {
          delete cache[key[i]];
        }
      } // Remove the expando if there's no more data


      if (key === undefined || jQuery.isEmptyObject(cache)) {
        // Support: Chrome <=35 - 45
        // Webkit & Blink performance suffers when deleting properties
        // from DOM nodes, so set to undefined instead
        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function (owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  return Data;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "XTU/":
/*!*************************************************!*\
  !*** ./node_modules/miniraf/dist/miniraf.es.js ***!
  \*************************************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/*! @license miniraf v1.0.0

	Copyright 2018 Fisssion LLC.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

*/
var polyfill = function () {
  var clock = Date.now();
  return function (callback) {
    var currentTime = Date.now();

    if (currentTime - clock > 16) {
      clock = currentTime;
      callback(currentTime);
    } else {
      setTimeout(function () {
        return polyfill(callback);
      }, 0);
    }
  };
}();

var index = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || polyfill;
/* harmony default export */ __webpack_exports__["a"] = (index);

/***/ }),

/***/ "Y7H9":
/*!******************************************!*\
  !*** ./node_modules/jquery/src/event.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./var/document */ "iprW"), __webpack_require__(/*! ./var/documentElement */ "tz86"), __webpack_require__(/*! ./var/isFunction */ "s44h"), __webpack_require__(/*! ./var/rnothtmlwhite */ "VK0Q"), __webpack_require__(/*! ./var/slice */ "QQxG"), __webpack_require__(/*! ./data/var/dataPriv */ "082X"), __webpack_require__(/*! ./core/nodeName */ "NKsO"), __webpack_require__(/*! ./core/init */ "MsD2"), __webpack_require__(/*! ./selector */ "dyyg")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document, documentElement, isFunction, rnothtmlwhite, slice, dataPriv, nodeName) {
  "use strict";

  var rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  } // Support: IE <=9 only
  // See #13393 for more info


  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }

  function on(elem, types, selector, data, fn, one) {
    var origFn, type; // Types can be a map of types/handlers

    if (typeof types === "object") {
      // ( types-Object, selector, data )
      if (typeof selector !== "string") {
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }

      for (type in types) {
        on(elem, type, selector, data, types[type], one);
      }

      return elem;
    }

    if (data == null && fn == null) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }

    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }

    if (one === 1) {
      origFn = fn;

      fn = function (event) {
        // Can use an empty set, since event contains the info
        jQuery().off(event);
        return origFn.apply(this, arguments);
      }; // Use same guid so caller can remove using origFn


      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }

    return elem.each(function () {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */


  jQuery.event = {
    global: {},
    add: function (elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem); // Don't attach events to noData or text/comment nodes (but allow plain objects)

      if (!elemData) {
        return;
      } // Caller can pass in an object of custom data in lieu of the handler


      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      } // Ensure that invalid selectors throw exceptions at attach time
      // Evaluate against documentElement in case elem is a non-element node (e.g., document)


      if (selector) {
        jQuery.find.matchesSelector(documentElement, selector);
      } // Make sure that the handler has a unique ID, used to find/remove it later


      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      } // Init the element's event structure and main handler, if this is the first


      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }

      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      } // Handle multiple events separated by a space


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

        if (!type) {
          continue;
        } // If event changes its type, use the special event handlers for the changed type


        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn); // Init the event handler queue if we're the first

        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }

        if (special.add) {
          special.add.call(elem, handleObj);

          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        } // Add to the element's handler list, delegates in front


        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        } // Keep track of which events have ever been used, for event optimization


        jQuery.event.global[type] = true;
      }
    },
    // Detach an event or set of events from an element
    remove: function (elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

      if (!elemData || !(events = elemData.events)) {
        return;
      } // Once for each type.namespace in types; type may be omitted


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }

          continue;
        }

        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

        origCount = j = handlers.length;

        while (j--) {
          handleObj = handlers[j];

          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);

            if (handleObj.selector) {
              handlers.delegateCount--;
            }

            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        } // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)


        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }

          delete events[type];
        }
      } // Remove data and the expando if it's no longer used


      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function (nativeEvent) {
      // Make a writable jQuery.Event from the native event object
      var event = jQuery.event.fix(nativeEvent);
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue,
          args = new Array(arguments.length),
          handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

      args[0] = event;

      for (i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      } // Determine handlers


      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

      i = 0;

      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;

        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          // Triggered event must either 1) have no namespace, or 2) have namespace(s)
          // a subset or equal to those in the bound event (both can have no namespace).
          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      } // Call the postDispatch hook for the mapped type


      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }

      return event.result;
    },
    handlers: function (event, handlers) {
      var i,
          handleObj,
          sel,
          matchedHandlers,
          matchedSelectors,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target; // Find delegate handlers

      if (delegateCount && // Support: IE <=9
      // Black-hole SVG <use> instance trees (trac-13180)
      cur.nodeType && // Support: Firefox <=42
      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
      // Support: IE 11 only
      // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
      !(event.type === "click" && event.button >= 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          // Don't check non-elements (#13208)
          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
          if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
            matchedHandlers = [];
            matchedSelectors = {};

            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i]; // Don't conflict with Object.prototype properties (#13203)

              sel = handleObj.selector + " ";

              if (matchedSelectors[sel] === undefined) {
                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }

              if (matchedSelectors[sel]) {
                matchedHandlers.push(handleObj);
              }
            }

            if (matchedHandlers.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matchedHandlers
              });
            }
          }
        }
      } // Add the remaining (directly-bound) handlers


      cur = this;

      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: cur,
          handlers: handlers.slice(delegateCount)
        });
      }

      return handlerQueue;
    },
    addProp: function (name, hook) {
      Object.defineProperty(jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,
        get: isFunction(hook) ? function () {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        } : function () {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        },
        set: function (value) {
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          });
        }
      });
    },
    fix: function (originalEvent) {
      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
    },
    special: {
      load: {
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
      },
      focus: {
        // Fire native event if possible so blur/focus sequence is correct
        trigger: function () {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function () {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        // For checkbox, fire native event so checked state will be right
        trigger: function () {
          if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        // For cross-browser consistency, don't fire native .click() on links
        _default: function (event) {
          return nodeName(event.target, "a");
        }
      },
      beforeunload: {
        postDispatch: function (event) {
          // Support: Firefox 20+
          // Firefox doesn't alert if the returnValue field is not set.
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    }
  };

  jQuery.removeEvent = function (elem, type, handle) {
    // This "if" is needed for plain objects
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };

  jQuery.Event = function (src, props) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    } // Event object


    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type; // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.

      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
      src.returnValue === false ? returnTrue : returnFalse; // Create target properties
      // Support: Safari <=6 - 7 only
      // Target should not be a text node (#504, #13143)

      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget; // Event type
    } else {
      this.type = src;
    } // Put explicitly provided properties onto the event object


    if (props) {
      jQuery.extend(this, props);
    } // Create a timestamp if incoming event doesn't have one


    this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed

    this[jQuery.expando] = true;
  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
    preventDefault: function () {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;

      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function () {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function () {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }

      this.stopPropagation();
    }
  }; // Includes all common event props including KeyEvent and MouseEvent specific props

  jQuery.each({
    altKey: true,
    bubbles: true,
    cancelable: true,
    changedTouches: true,
    ctrlKey: true,
    detail: true,
    eventPhase: true,
    metaKey: true,
    pageX: true,
    pageY: true,
    shiftKey: true,
    view: true,
    "char": true,
    charCode: true,
    key: true,
    keyCode: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pointerId: true,
    pointerType: true,
    screenX: true,
    screenY: true,
    targetTouches: true,
    toElement: true,
    touches: true,
    which: function (event) {
      var button = event.button; // Add which for key events

      if (event.which == null && rkeyEvent.test(event.type)) {
        return event.charCode != null ? event.charCode : event.keyCode;
      } // Add which for click: 1 === left; 2 === middle; 3 === right


      if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
        if (button & 1) {
          return 1;
        }

        if (button & 2) {
          return 3;
        }

        if (button & 4) {
          return 2;
        }

        return 0;
      }

      return event.which;
    }
  }, jQuery.event.addProp); // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).

  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function (event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window

        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }

        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function (types, selector, data, fn) {
      return on(this, types, selector, data, fn);
    },
    one: function (types, selector, data, fn) {
      return on(this, types, selector, data, fn, 1);
    },
    off: function (types, selector, fn) {
      var handleObj, type;

      if (types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }

      if (typeof types === "object") {
        // ( types-object [, selector] )
        for (type in types) {
          this.off(type, selector, types[type]);
        }

        return this;
      }

      if (selector === false || typeof selector === "function") {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }

      if (fn === false) {
        fn = returnFalse;
      }

      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "YBdB":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function (handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function (event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function (handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function (handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function (handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function (handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 68
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "yLpj"), __webpack_require__(/*! ./../process/browser.js */ "8oxB")))

/***/ }),

/***/ "YefD":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/event/alias.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../event */ "Y7H9"), __webpack_require__(/*! ./trigger */ "l58E")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (i, name) {
    // Handle event binding
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function (fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "ZDXL":
/*!*******************************************************!*\
  !*** ./node_modules/vue-hot-reload-api/dist/index.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

var Vue; // late bind

var version;
var map = Object.create(null);

if (typeof window !== 'undefined') {
  window.__VUE_HOT_MAP__ = map;
}

var installed = false;
var isBrowserify = false;
var initHookName = 'beforeCreate';

exports.install = function (vue, browserify) {
  if (installed) {
    return;
  }

  installed = true;
  Vue = vue.__esModule ? vue.default : vue;
  version = Vue.version.split('.').map(Number);
  isBrowserify = browserify; // compat with < 2.0.0-alpha.7

  if (Vue.config._lifecycleHooks.indexOf('init') > -1) {
    initHookName = 'init';
  }

  exports.compatible = version[0] >= 2;

  if (!exports.compatible) {
    console.warn('[HMR] You are using a version of vue-hot-reload-api that is ' + 'only compatible with Vue.js core ^2.0.0.');
    return;
  }
};
/**
 * Create a record for a hot module, which keeps track of its constructor
 * and instances
 *
 * @param {String} id
 * @param {Object} options
 */


exports.createRecord = function (id, options) {
  if (map[id]) {
    return;
  }

  var Ctor = null;

  if (typeof options === 'function') {
    Ctor = options;
    options = Ctor.options;
  }

  makeOptionsHot(id, options);
  map[id] = {
    Ctor: Ctor,
    options: options,
    instances: []
  };
};
/**
 * Check if module is recorded
 *
 * @param {String} id
 */


exports.isRecorded = function (id) {
  return typeof map[id] !== 'undefined';
};
/**
 * Make a Component options object hot.
 *
 * @param {String} id
 * @param {Object} options
 */


function makeOptionsHot(id, options) {
  if (options.functional) {
    var render = options.render;

    options.render = function (h, ctx) {
      var instances = map[id].instances;

      if (ctx && instances.indexOf(ctx.parent) < 0) {
        instances.push(ctx.parent);
      }

      return render(h, ctx);
    };
  } else {
    injectHook(options, initHookName, function () {
      var record = map[id];

      if (!record.Ctor) {
        record.Ctor = this.constructor;
      }

      record.instances.push(this);
    });
    injectHook(options, 'beforeDestroy', function () {
      var instances = map[id].instances;
      instances.splice(instances.indexOf(this), 1);
    });
  }
}
/**
 * Inject a hook to a hot reloadable component so that
 * we can keep track of it.
 *
 * @param {Object} options
 * @param {String} name
 * @param {Function} hook
 */


function injectHook(options, name, hook) {
  var existing = options[name];
  options[name] = existing ? Array.isArray(existing) ? existing.concat(hook) : [existing, hook] : [hook];
}

function tryWrap(fn) {
  return function (id, arg) {
    try {
      fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn('Something went wrong during Vue component hot-reload. Full reload required.');
    }
  };
}

function updateOptions(oldOptions, newOptions) {
  for (var key in oldOptions) {
    if (!(key in newOptions)) {
      delete oldOptions[key];
    }
  }

  for (var key$1 in newOptions) {
    oldOptions[key$1] = newOptions[key$1];
  }
}

exports.rerender = tryWrap(function (id, options) {
  var record = map[id];

  if (!options) {
    record.instances.slice().forEach(function (instance) {
      instance.$forceUpdate();
    });
    return;
  }

  if (typeof options === 'function') {
    options = options.options;
  }

  if (record.Ctor) {
    record.Ctor.options.render = options.render;
    record.Ctor.options.staticRenderFns = options.staticRenderFns;
    record.instances.slice().forEach(function (instance) {
      instance.$options.render = options.render;
      instance.$options.staticRenderFns = options.staticRenderFns; // reset static trees
      // pre 2.5, all static trees are cached together on the instance

      if (instance._staticTrees) {
        instance._staticTrees = [];
      } // 2.5.0


      if (Array.isArray(record.Ctor.options.cached)) {
        record.Ctor.options.cached = [];
      } // 2.5.3


      if (Array.isArray(instance.$options.cached)) {
        instance.$options.cached = [];
      } // post 2.5.4: v-once trees are cached on instance._staticTrees.
      // Pure static trees are cached on the staticRenderFns array
      // (both already reset above)
      // 2.6: temporarily mark rendered scoped slots as unstable so that
      // child components can be forced to update


      var restore = patchScopedSlots(instance);
      instance.$forceUpdate();
      instance.$nextTick(restore);
    });
  } else {
    // functional or no instance created yet
    record.options.render = options.render;
    record.options.staticRenderFns = options.staticRenderFns; // handle functional component re-render

    if (record.options.functional) {
      // rerender with full options
      if (Object.keys(options).length > 2) {
        updateOptions(record.options, options);
      } else {
        // template-only rerender.
        // need to inject the style injection code for CSS modules
        // to work properly.
        var injectStyles = record.options._injectStyles;

        if (injectStyles) {
          var render = options.render;

          record.options.render = function (h, ctx) {
            injectStyles.call(ctx);
            return render(h, ctx);
          };
        }
      }

      record.options._Ctor = null; // 2.5.3

      if (Array.isArray(record.options.cached)) {
        record.options.cached = [];
      }

      record.instances.slice().forEach(function (instance) {
        instance.$forceUpdate();
      });
    }
  }
});
exports.reload = tryWrap(function (id, options) {
  var record = map[id];

  if (options) {
    if (typeof options === 'function') {
      options = options.options;
    }

    makeOptionsHot(id, options);

    if (record.Ctor) {
      if (version[1] < 2) {
        // preserve pre 2.2 behavior for global mixin handling
        record.Ctor.extendOptions = options;
      }

      var newCtor = record.Ctor.super.extend(options);
      record.Ctor.options = newCtor.options;
      record.Ctor.cid = newCtor.cid;
      record.Ctor.prototype = newCtor.prototype;

      if (newCtor.release) {
        // temporary global mixin strategy used in < 2.0.0-alpha.6
        newCtor.release();
      }
    } else {
      updateOptions(record.options, options);
    }
  }

  record.instances.slice().forEach(function (instance) {
    if (instance.$vnode && instance.$vnode.context) {
      instance.$vnode.context.$forceUpdate();
    } else {
      console.warn('Root or manually mounted instance modified. Full reload required.');
    }
  });
}); // 2.6 optimizes template-compiled scoped slots and skips updates if child
// only uses scoped slots. We need to patch the scoped slots resolving helper
// to temporarily mark all scoped slots as unstable in order to force child
// updates.

function patchScopedSlots(instance) {
  if (!instance._u) {
    return;
  } // https://github.com/vuejs/vue/blob/dev/src/core/instance/render-helpers/resolve-scoped-slots.js


  var original = instance._u;

  instance._u = function (slots) {
    try {
      // 2.6.4 ~ 2.6.6
      return original(slots, true);
    } catch (e) {
      // 2.5 / >= 2.6.7
      return original(slots, null, true);
    }
  };

  return function () {
    instance._u = original;
  };
}

/***/ }),

/***/ "ZI4A":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/ajax/var/location.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return window.location;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "ZNX1":
/*!**********************************************!*\
  !*** ./node_modules/jquery/src/ajax/load.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../core/stripAndCollapse */ "3PRc"), __webpack_require__(/*! ../var/isFunction */ "s44h"), __webpack_require__(/*! ../core/parseHTML */ "bgBX"), __webpack_require__(/*! ../ajax */ "06dU"), __webpack_require__(/*! ../traversing */ "wkHr"), __webpack_require__(/*! ../manipulation */ "PRQw"), __webpack_require__(/*! ../selector */ "dyyg")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, stripAndCollapse, isFunction) {
  "use strict";
  /**
   * Load a url into a page
   */

  jQuery.fn.load = function (url, params, callback) {
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");

    if (off > -1) {
      selector = stripAndCollapse(url.slice(off));
      url = url.slice(0, off);
    } // If it's a function


    if (isFunction(params)) {
      // We assume that it's the callback
      callback = params;
      params = undefined; // Otherwise, build a param string
    } else if (params && typeof params === "object") {
      type = "POST";
    } // If we have elements to modify, make the request


    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        // If "type" variable is undefined, then "GET" method will be used.
        // Make value of this field explicit since
        // user can override it through ajaxSetup method
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function (responseText) {
        // Save response for use in complete callback
        response = arguments;
        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
        // Exclude scripts to avoid IE 'Permission Denied' errors
        jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
        responseText); // If the request succeeds, this function gets "data", "status", "jqXHR"
        // but they are ignored because response was set above.
        // If it fails, this function gets "jqXHR", "status", "error"
      }).always(callback && function (jqXHR, status) {
        self.each(function () {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }

    return this;
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "aAjK":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/data/var/dataUser.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../Data */ "Wwic")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Data) {
  "use strict";

  return new Data();
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "aET+":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "9tPo");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "bgBX":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/core/parseHTML.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../var/document */ "iprW"), __webpack_require__(/*! ./var/rsingleTag */ "eTAU"), __webpack_require__(/*! ../manipulation/buildFragment */ "dxuR"), // This is the only module that needs core/support
__webpack_require__(/*! ./support */ "yPcJ")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document, rsingleTag, buildFragment, support) {
  "use strict"; // Argument "data" should be string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string

  jQuery.parseHTML = function (data, context, keepScripts) {
    if (typeof data !== "string") {
      return [];
    }

    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }

    var base, parsed, scripts;

    if (!context) {
      // Stop scripts or inline event handlers from being executed immediately
      // by using document.implementation
      if (support.createHTMLDocument) {
        context = document.implementation.createHTMLDocument(""); // Set the base href for the created document
        // so any parsed elements with URLs
        // are based on the document's URL (gh-2965)

        base = context.createElement("base");
        base.href = document.location.href;
        context.head.appendChild(base);
      } else {
        context = document;
      }
    }

    parsed = rsingleTag.exec(data);
    scripts = !keepScripts && []; // Single tag

    if (parsed) {
      return [context.createElement(parsed[1])];
    }

    parsed = buildFragment([data], context, scripts);

    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }

    return jQuery.merge([], parsed.childNodes);
  };

  return jQuery.parseHTML;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "bjeD":
/*!***************************************************!*\
  !*** ./node_modules/rematrix/dist/rematrix.es.js ***!
  \***************************************************/
/*! exports provided: format, identity, inverse, multiply, parse, rotate, rotateX, rotateY, rotateZ, scale, scaleX, scaleY, scaleZ, skew, skewX, skewY, toString, translate, translateX, translateY, translateZ */
/*! exports used: multiply, parse, rotateX, rotateY, rotateZ, scale, translateX, translateY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export format */
/* unused harmony export identity */
/* unused harmony export inverse */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return parse; });
/* unused harmony export rotate */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return scale; });
/* unused harmony export scaleX */
/* unused harmony export scaleY */
/* unused harmony export scaleZ */
/* unused harmony export skew */
/* unused harmony export skewX */
/* unused harmony export skewY */
/* unused harmony export toString */
/* unused harmony export translate */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return translateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return translateY; });
/* unused harmony export translateZ */
/*! @license Rematrix v0.3.0

	Copyright 2018 Julian Lloyd.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
*/

/**
 * @module Rematrix
 */

/**
 * Transformation matrices in the browser come in two flavors:
 *
 *  - `matrix` using 6 values (short)
 *  - `matrix3d` using 16 values (long)
 *
 * This utility follows this [conversion guide](https://goo.gl/EJlUQ1)
 * to expand short form matrices to their equivalent long form.
 *
 * @param  {array} source - Accepts both short and long form matrices.
 * @return {array}
 */
function format(source) {
  if (source.constructor !== Array) {
    throw new TypeError('Expected array.');
  }

  if (source.length === 16) {
    return source;
  }

  if (source.length === 6) {
    var matrix = identity();
    matrix[0] = source[0];
    matrix[1] = source[1];
    matrix[4] = source[2];
    matrix[5] = source[3];
    matrix[12] = source[4];
    matrix[13] = source[5];
    return matrix;
  }

  throw new RangeError('Expected array with either 6 or 16 values.');
}
/**
 * Returns a matrix representing no transformation. The product of any matrix
 * multiplied by the identity matrix will be the original matrix.
 *
 * > **Tip:** Similar to how `5 * 1 === 5`, where `1` is the identity.
 *
 * @return {array}
 */


function identity() {
  var matrix = [];

  for (var i = 0; i < 16; i++) {
    i % 5 == 0 ? matrix.push(1) : matrix.push(0);
  }

  return matrix;
}
/**
 * Returns a matrix describing the inverse transformation of the source
 * matrix. The product of any matrix multiplied by its inverse will be the
 * identity matrix.
 *
 * > **Tip:** Similar to how `5 * (1/5) === 1`, where `1/5` is the inverse.
 *
 * @param  {array} source - Accepts both short and long form matrices.
 * @return {array}
 */


function inverse(source) {
  var m = format(source);
  var s0 = m[0] * m[5] - m[4] * m[1];
  var s1 = m[0] * m[6] - m[4] * m[2];
  var s2 = m[0] * m[7] - m[4] * m[3];
  var s3 = m[1] * m[6] - m[5] * m[2];
  var s4 = m[1] * m[7] - m[5] * m[3];
  var s5 = m[2] * m[7] - m[6] * m[3];
  var c5 = m[10] * m[15] - m[14] * m[11];
  var c4 = m[9] * m[15] - m[13] * m[11];
  var c3 = m[9] * m[14] - m[13] * m[10];
  var c2 = m[8] * m[15] - m[12] * m[11];
  var c1 = m[8] * m[14] - m[12] * m[10];
  var c0 = m[8] * m[13] - m[12] * m[9];
  var determinant = 1 / (s0 * c5 - s1 * c4 + s2 * c3 + s3 * c2 - s4 * c1 + s5 * c0);

  if (isNaN(determinant) || determinant === Infinity) {
    throw new Error('Inverse determinant attempted to divide by zero.');
  }

  return [(m[5] * c5 - m[6] * c4 + m[7] * c3) * determinant, (-m[1] * c5 + m[2] * c4 - m[3] * c3) * determinant, (m[13] * s5 - m[14] * s4 + m[15] * s3) * determinant, (-m[9] * s5 + m[10] * s4 - m[11] * s3) * determinant, (-m[4] * c5 + m[6] * c2 - m[7] * c1) * determinant, (m[0] * c5 - m[2] * c2 + m[3] * c1) * determinant, (-m[12] * s5 + m[14] * s2 - m[15] * s1) * determinant, (m[8] * s5 - m[10] * s2 + m[11] * s1) * determinant, (m[4] * c4 - m[5] * c2 + m[7] * c0) * determinant, (-m[0] * c4 + m[1] * c2 - m[3] * c0) * determinant, (m[12] * s4 - m[13] * s2 + m[15] * s0) * determinant, (-m[8] * s4 + m[9] * s2 - m[11] * s0) * determinant, (-m[4] * c3 + m[5] * c1 - m[6] * c0) * determinant, (m[0] * c3 - m[1] * c1 + m[2] * c0) * determinant, (-m[12] * s3 + m[13] * s1 - m[14] * s0) * determinant, (m[8] * s3 - m[9] * s1 + m[10] * s0) * determinant];
}
/**
 * Returns a 4x4 matrix describing the combined transformations
 * of both arguments.
 *
 * > **Note:** Order is very important. For example, rotating 45
 * along the Z-axis, followed by translating 500 pixels along the
 * Y-axis... is not the same as translating 500 pixels along the
 * Y-axis, followed by rotating 45 along on the Z-axis.
 *
 * @param  {array} m - Accepts both short and long form matrices.
 * @param  {array} x - Accepts both short and long form matrices.
 * @return {array}
 */


function multiply(m, x) {
  var fm = format(m);
  var fx = format(x);
  var product = [];

  for (var i = 0; i < 4; i++) {
    var row = [fm[i], fm[i + 4], fm[i + 8], fm[i + 12]];

    for (var j = 0; j < 4; j++) {
      var k = j * 4;
      var col = [fx[k], fx[k + 1], fx[k + 2], fx[k + 3]];
      var result = row[0] * col[0] + row[1] * col[1] + row[2] * col[2] + row[3] * col[3];
      product[i + k] = result;
    }
  }

  return product;
}
/**
 * Attempts to return a 4x4 matrix describing the CSS transform
 * matrix passed in, but will return the identity matrix as a
 * fallback.
 *
 * > **Tip:** This method is used to convert a CSS matrix (retrieved as a
 * `string` from computed styles) to its equivalent array format.
 *
 * @param  {string} source - `matrix` or `matrix3d` CSS Transform value.
 * @return {array}
 */


function parse(source) {
  if (typeof source === 'string') {
    var match = source.match(/matrix(3d)?\(([^)]+)\)/);

    if (match) {
      var raw = match[2].split(', ').map(parseFloat);
      return format(raw);
    }
  }

  return identity();
}
/**
 * Returns a 4x4 matrix describing Z-axis rotation.
 *
 * > **Tip:** This is just an alias for `Rematrix.rotateZ` for parity with CSS
 *
 * @param  {number} angle - Measured in degrees.
 * @return {array}
 */


function rotate(angle) {
  return rotateZ(angle);
}
/**
 * Returns a 4x4 matrix describing X-axis rotation.
 *
 * @param  {number} angle - Measured in degrees.
 * @return {array}
 */


function rotateX(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[5] = matrix[10] = Math.cos(theta);
  matrix[6] = matrix[9] = Math.sin(theta);
  matrix[9] *= -1;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing Y-axis rotation.
 *
 * @param  {number} angle - Measured in degrees.
 * @return {array}
 */


function rotateY(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[0] = matrix[10] = Math.cos(theta);
  matrix[2] = matrix[8] = Math.sin(theta);
  matrix[2] *= -1;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing Z-axis rotation.
 *
 * @param  {number} angle - Measured in degrees.
 * @return {array}
 */


function rotateZ(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[0] = matrix[5] = Math.cos(theta);
  matrix[1] = matrix[4] = Math.sin(theta);
  matrix[4] *= -1;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing 2D scaling. The first argument
 * is used for both X and Y-axis scaling, unless an optional
 * second argument is provided to explicitly define Y-axis scaling.
 *
 * @param  {number} scalar    - Decimal multiplier.
 * @param  {number} [scalarY] - Decimal multiplier.
 * @return {array}
 */


function scale(scalar, scalarY) {
  var matrix = identity();
  matrix[0] = scalar;
  matrix[5] = typeof scalarY === 'number' ? scalarY : scalar;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing X-axis scaling.
 *
 * @param  {number} scalar - Decimal multiplier.
 * @return {array}
 */


function scaleX(scalar) {
  var matrix = identity();
  matrix[0] = scalar;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing Y-axis scaling.
 *
 * @param  {number} scalar - Decimal multiplier.
 * @return {array}
 */


function scaleY(scalar) {
  var matrix = identity();
  matrix[5] = scalar;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing Z-axis scaling.
 *
 * @param  {number} scalar - Decimal multiplier.
 * @return {array}
 */


function scaleZ(scalar) {
  var matrix = identity();
  matrix[10] = scalar;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing shear. The first argument
 * defines X-axis shearing, and an optional second argument
 * defines Y-axis shearing.
 *
 * @param  {number} angleX   - Measured in degrees.
 * @param  {number} [angleY] - Measured in degrees.
 * @return {array}
 */


function skew(angleX, angleY) {
  var thetaX = Math.PI / 180 * angleX;
  var matrix = identity();
  matrix[4] = Math.tan(thetaX);

  if (angleY) {
    var thetaY = Math.PI / 180 * angleY;
    matrix[1] = Math.tan(thetaY);
  }

  return matrix;
}
/**
 * Returns a 4x4 matrix describing X-axis shear.
 *
 * @param  {number} angle - Measured in degrees.
 * @return {array}
 */


function skewX(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[4] = Math.tan(theta);
  return matrix;
}
/**
 * Returns a 4x4 matrix describing Y-axis shear.
 *
 * @param  {number} angle - Measured in degrees
 * @return {array}
 */


function skewY(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[1] = Math.tan(theta);
  return matrix;
}
/**
 * Returns a CSS Transform property value equivalent to the source matrix.
 *
 * @param  {array} source - Accepts both short and long form matrices.
 * @return {string}
 */


function toString(source) {
  return "matrix3d(" + format(source).join(', ') + ")";
}
/**
 * Returns a 4x4 matrix describing 2D translation. The first
 * argument defines X-axis translation, and an optional second
 * argument defines Y-axis translation.
 *
 * @param  {number} distanceX   - Measured in pixels.
 * @param  {number} [distanceY] - Measured in pixels.
 * @return {array}
 */


function translate(distanceX, distanceY) {
  var matrix = identity();
  matrix[12] = distanceX;

  if (distanceY) {
    matrix[13] = distanceY;
  }

  return matrix;
}
/**
 * Returns a 4x4 matrix describing X-axis translation.
 *
 * @param  {number} distance - Measured in pixels.
 * @return {array}
 */


function translateX(distance) {
  var matrix = identity();
  matrix[12] = distance;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing Y-axis translation.
 *
 * @param  {number} distance - Measured in pixels.
 * @return {array}
 */


function translateY(distance) {
  var matrix = identity();
  matrix[13] = distance;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing Z-axis translation.
 *
 * @param  {number} distance - Measured in pixels.
 * @return {array}
 */


function translateZ(distance) {
  var matrix = identity();
  matrix[14] = distance;
  return matrix;
}



/***/ }),

/***/ "blUz":
/*!***********************************************************!*\
  !*** ./node_modules/scrollreveal/dist/scrollreveal.es.js ***!
  \***********************************************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var tealight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tealight */ "8qe8");
/* harmony import */ var rematrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rematrix */ "bjeD");
/* harmony import */ var miniraf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! miniraf */ "XTU/");
/*! @license ScrollReveal v4.0.5

	Copyright 2018 Fisssion LLC.

	Licensed under the GNU General Public License 3.0 for
	compatible open source projects and non-commercial use.

	For commercial sites, themes, projects, and applications,
	keep your source code private/proprietary by purchasing
	a commercial license from https://scrollrevealjs.org/
*/



var defaults = {
  delay: 0,
  distance: '0',
  duration: 600,
  easing: 'cubic-bezier(0.5, 0, 0, 1)',
  interval: 0,
  opacity: 0,
  origin: 'bottom',
  rotate: {
    x: 0,
    y: 0,
    z: 0
  },
  scale: 1,
  cleanup: false,
  container: document.documentElement,
  desktop: true,
  mobile: true,
  reset: false,
  useDelay: 'always',
  viewFactor: 0.0,
  viewOffset: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  afterReset: function afterReset() {},
  afterReveal: function afterReveal() {},
  beforeReset: function beforeReset() {},
  beforeReveal: function beforeReveal() {}
};

function failure() {
  document.documentElement.classList.remove('sr');
  return {
    clean: function clean() {},
    destroy: function destroy() {},
    reveal: function reveal() {},
    sync: function sync() {},

    get noop() {
      return true;
    }

  };
}

function success() {
  document.documentElement.classList.add('sr');

  if (document.body) {
    document.body.style.height = '100%';
  } else {
    document.addEventListener('DOMContentLoaded', function () {
      document.body.style.height = '100%';
    });
  }
}

var mount = {
  success: success,
  failure: failure
};

function isObject(x) {
  return x !== null && x instanceof Object && (x.constructor === Object || Object.prototype.toString.call(x) === '[object Object]');
}

function each(collection, callback) {
  if (isObject(collection)) {
    var keys = Object.keys(collection);
    return keys.forEach(function (key) {
      return callback(collection[key], key, collection);
    });
  }

  if (collection instanceof Array) {
    return collection.forEach(function (item, i) {
      return callback(item, i, collection);
    });
  }

  throw new TypeError('Expected either an array or object literal.');
}

function logger(message) {
  var details = [],
      len = arguments.length - 1;

  while (len-- > 0) details[len] = arguments[len + 1];

  if (this.constructor.debug && console) {
    var report = "%cScrollReveal: " + message;
    details.forEach(function (detail) {
      return report += "\n  " + detail;
    });
    console.log(report, 'color: #ea654b;'); // eslint-disable-line no-console
  }
}

function rinse() {
  var this$1 = this;

  var struct = function () {
    return {
      active: [],
      stale: []
    };
  };

  var elementIds = struct();
  var sequenceIds = struct();
  var containerIds = struct();
  /**
   * Take stock of active element IDs.
   */

  try {
    each(Object(tealight__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])('[data-sr-id]'), function (node) {
      var id = parseInt(node.getAttribute('data-sr-id'));
      elementIds.active.push(id);
    });
  } catch (e) {
    throw e;
  }
  /**
   * Destroy stale elements.
   */


  each(this.store.elements, function (element) {
    if (elementIds.active.indexOf(element.id) === -1) {
      elementIds.stale.push(element.id);
    }
  });
  each(elementIds.stale, function (staleId) {
    return delete this$1.store.elements[staleId];
  });
  /**
   * Take stock of active container and sequence IDs.
   */

  each(this.store.elements, function (element) {
    if (containerIds.active.indexOf(element.containerId) === -1) {
      containerIds.active.push(element.containerId);
    }

    if (element.hasOwnProperty('sequence')) {
      if (sequenceIds.active.indexOf(element.sequence.id) === -1) {
        sequenceIds.active.push(element.sequence.id);
      }
    }
  });
  /**
   * Destroy stale containers.
   */

  each(this.store.containers, function (container) {
    if (containerIds.active.indexOf(container.id) === -1) {
      containerIds.stale.push(container.id);
    }
  });
  each(containerIds.stale, function (staleId) {
    var stale = this$1.store.containers[staleId].node;
    stale.removeEventListener('scroll', this$1.delegate);
    stale.removeEventListener('resize', this$1.delegate);
    delete this$1.store.containers[staleId];
  });
  /**
   * Destroy stale sequences.
   */

  each(this.store.sequences, function (sequence) {
    if (sequenceIds.active.indexOf(sequence.id) === -1) {
      sequenceIds.stale.push(sequence.id);
    }
  });
  each(sequenceIds.stale, function (staleId) {
    return delete this$1.store.sequences[staleId];
  });
}

function clean(target) {
  var this$1 = this;
  var dirty;

  try {
    each(Object(tealight__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(target), function (node) {
      var id = node.getAttribute('data-sr-id');

      if (id !== null) {
        dirty = true;
        var element = this$1.store.elements[id];

        if (element.callbackTimer) {
          window.clearTimeout(element.callbackTimer.clock);
        }

        node.setAttribute('style', element.styles.inline.generated);
        node.removeAttribute('data-sr-id');
        delete this$1.store.elements[id];
      }
    });
  } catch (e) {
    return logger.call(this, 'Clean failed.', e.message);
  }

  if (dirty) {
    try {
      rinse.call(this);
    } catch (e) {
      return logger.call(this, 'Clean failed.', e.message);
    }
  }
}

function destroy() {
  var this$1 = this;
  /**
   * Remove all generated styles and element ids
   */

  each(this.store.elements, function (element) {
    element.node.setAttribute('style', element.styles.inline.generated);
    element.node.removeAttribute('data-sr-id');
  });
  /**
   * Remove all event listeners.
   */

  each(this.store.containers, function (container) {
    var target = container.node === document.documentElement ? window : container.node;
    target.removeEventListener('scroll', this$1.delegate);
    target.removeEventListener('resize', this$1.delegate);
  });
  /**
   * Clear all data from the store
   */

  this.store = {
    containers: {},
    elements: {},
    history: [],
    sequences: {}
  };
}

var getPrefixedCssProp = function () {
  var properties = {};
  var style = document.documentElement.style;

  function getPrefixedCssProperty(name, source) {
    if (source === void 0) source = style;

    if (name && typeof name === 'string') {
      if (properties[name]) {
        return properties[name];
      }

      if (typeof source[name] === 'string') {
        return properties[name] = name;
      }

      if (typeof source["-webkit-" + name] === 'string') {
        return properties[name] = "-webkit-" + name;
      }

      throw new RangeError("Unable to find \"" + name + "\" style property.");
    }

    throw new TypeError('Expected a string.');
  }

  getPrefixedCssProperty.clearCache = function () {
    return properties = {};
  };

  return getPrefixedCssProperty;
}();

function style(element) {
  var computed = window.getComputedStyle(element.node);
  var position = computed.position;
  var config = element.config;
  /**
   * Generate inline styles
   */

  var inline = {};
  var inlineStyle = element.node.getAttribute('style') || '';
  var inlineMatch = inlineStyle.match(/[\w-]+\s*:\s*[^;]+\s*/gi) || [];
  inline.computed = inlineMatch ? inlineMatch.map(function (m) {
    return m.trim();
  }).join('; ') + ';' : '';
  inline.generated = inlineMatch.some(function (m) {
    return m.match(/visibility\s?:\s?visible/i);
  }) ? inline.computed : inlineMatch.concat(['visibility: visible']).map(function (m) {
    return m.trim();
  }).join('; ') + ';';
  /**
   * Generate opacity styles
   */

  var computedOpacity = parseFloat(computed.opacity);
  var configOpacity = !isNaN(parseFloat(config.opacity)) ? parseFloat(config.opacity) : parseFloat(computed.opacity);
  var opacity = {
    computed: computedOpacity !== configOpacity ? "opacity: " + computedOpacity + ";" : '',
    generated: computedOpacity !== configOpacity ? "opacity: " + configOpacity + ";" : ''
  };
  /**
   * Generate transformation styles
   */

  var transformations = [];

  if (parseFloat(config.distance)) {
    var axis = config.origin === 'top' || config.origin === 'bottom' ? 'Y' : 'X';
    /**
     * Lets make sure our our pixel distances are negative for top and left.
     * e.g. { origin: 'top', distance: '25px' } starts at `top: -25px` in CSS.
     */

    var distance = config.distance;

    if (config.origin === 'top' || config.origin === 'left') {
      distance = /^-/.test(distance) ? distance.substr(1) : "-" + distance;
    }

    var ref = distance.match(/(^-?\d+\.?\d?)|(em$|px$|%$)/g);
    var value = ref[0];
    var unit = ref[1];

    switch (unit) {
      case 'em':
        distance = parseInt(computed.fontSize) * value;
        break;

      case 'px':
        distance = value;
        break;

      case '%':
        /**
         * Here we use `getBoundingClientRect` instead of
         * the existing data attached to `element.geometry`
         * because only the former includes any transformations
         * current applied to the element.
         *
         * If that behavior ends up being unintuitive, this
         * logic could instead utilize `element.geometry.height`
         * and `element.geoemetry.width` for the distaince calculation
         */
        distance = axis === 'Y' ? element.node.getBoundingClientRect().height * value / 100 : element.node.getBoundingClientRect().width * value / 100;
        break;

      default:
        throw new RangeError('Unrecognized or missing distance unit.');
    }

    if (axis === 'Y') {
      transformations.push(Object(rematrix__WEBPACK_IMPORTED_MODULE_1__[/* translateY */ "h"])(distance));
    } else {
      transformations.push(Object(rematrix__WEBPACK_IMPORTED_MODULE_1__[/* translateX */ "g"])(distance));
    }
  }

  if (config.rotate.x) {
    transformations.push(Object(rematrix__WEBPACK_IMPORTED_MODULE_1__[/* rotateX */ "c"])(config.rotate.x));
  }

  if (config.rotate.y) {
    transformations.push(Object(rematrix__WEBPACK_IMPORTED_MODULE_1__[/* rotateY */ "d"])(config.rotate.y));
  }

  if (config.rotate.z) {
    transformations.push(Object(rematrix__WEBPACK_IMPORTED_MODULE_1__[/* rotateZ */ "e"])(config.rotate.z));
  }

  if (config.scale !== 1) {
    if (config.scale === 0) {
      /**
       * The CSS Transforms matrix interpolation specification
       * basically disallows transitions of non-invertible
       * matrixes, which means browsers won't transition
       * elements with zero scale.
       *
       * Thats inconvenient for the API and developer
       * experience, so we simply nudge their value
       * slightly above zero; this allows browsers
       * to transition our element as expected.
       *
       * `0.0002` was the smallest number
       * that performed across browsers.
       */
      transformations.push(Object(rematrix__WEBPACK_IMPORTED_MODULE_1__[/* scale */ "f"])(0.0002));
    } else {
      transformations.push(Object(rematrix__WEBPACK_IMPORTED_MODULE_1__[/* scale */ "f"])(config.scale));
    }
  }

  var transform = {};

  if (transformations.length) {
    transform.property = getPrefixedCssProp('transform');
    /**
     * The default computed transform value should be one of:
     * undefined || 'none' || 'matrix()' || 'matrix3d()'
     */

    transform.computed = {
      raw: computed[transform.property],
      matrix: Object(rematrix__WEBPACK_IMPORTED_MODULE_1__[/* parse */ "b"])(computed[transform.property])
    };
    transformations.unshift(transform.computed.matrix);
    var product = transformations.reduce(rematrix__WEBPACK_IMPORTED_MODULE_1__[/* multiply */ "a"]);
    transform.generated = {
      initial: transform.property + ": matrix3d(" + product.join(', ') + ");",
      final: transform.property + ": matrix3d(" + transform.computed.matrix.join(', ') + ");"
    };
  } else {
    transform.generated = {
      initial: '',
      final: ''
    };
  }
  /**
   * Generate transition styles
   */


  var transition = {};

  if (opacity.generated || transform.generated.initial) {
    transition.property = getPrefixedCssProp('transition');
    transition.computed = computed[transition.property];
    transition.fragments = [];
    var delay = config.delay;
    var duration = config.duration;
    var easing = config.easing;

    if (opacity.generated) {
      transition.fragments.push({
        delayed: "opacity " + duration / 1000 + "s " + easing + " " + delay / 1000 + "s",
        instant: "opacity " + duration / 1000 + "s " + easing + " 0s"
      });
    }

    if (transform.generated.initial) {
      transition.fragments.push({
        delayed: transform.property + " " + duration / 1000 + "s " + easing + " " + delay / 1000 + "s",
        instant: transform.property + " " + duration / 1000 + "s " + easing + " 0s"
      });
    }
    /**
     * The default computed transition property should be one of:
     * undefined || '' || 'all 0s ease 0s' || 'all 0s 0s cubic-bezier()'
     */


    if (transition.computed && !transition.computed.match(/all 0s/)) {
      transition.fragments.unshift({
        delayed: transition.computed,
        instant: transition.computed
      });
    }

    var composed = transition.fragments.reduce(function (composition, fragment, i) {
      composition.delayed += i === 0 ? fragment.delayed : ", " + fragment.delayed;
      composition.instant += i === 0 ? fragment.instant : ", " + fragment.instant;
      return composition;
    }, {
      delayed: '',
      instant: ''
    });
    transition.generated = {
      delayed: transition.property + ": " + composed.delayed + ";",
      instant: transition.property + ": " + composed.instant + ";"
    };
  } else {
    transition.generated = {
      delayed: '',
      instant: ''
    };
  }

  return {
    inline: inline,
    opacity: opacity,
    position: position,
    transform: transform,
    transition: transition
  };
}

function animate(element, force) {
  if (force === void 0) force = {};
  var pristine = force.pristine || this.pristine;
  var delayed = element.config.useDelay === 'always' || element.config.useDelay === 'onload' && pristine || element.config.useDelay === 'once' && !element.seen;
  var shouldReveal = element.visible && !element.revealed;
  var shouldReset = !element.visible && element.revealed && element.config.reset;

  if (force.reveal || shouldReveal) {
    return triggerReveal.call(this, element, delayed);
  }

  if (force.reset || shouldReset) {
    return triggerReset.call(this, element);
  }
}

function triggerReveal(element, delayed) {
  var styles = [element.styles.inline.generated, element.styles.opacity.computed, element.styles.transform.generated.final];

  if (delayed) {
    styles.push(element.styles.transition.generated.delayed);
  } else {
    styles.push(element.styles.transition.generated.instant);
  }

  element.revealed = element.seen = true;
  element.node.setAttribute('style', styles.filter(function (s) {
    return s !== '';
  }).join(' '));
  registerCallbacks.call(this, element, delayed);
}

function triggerReset(element) {
  var styles = [element.styles.inline.generated, element.styles.opacity.generated, element.styles.transform.generated.initial, element.styles.transition.generated.instant];
  element.revealed = false;
  element.node.setAttribute('style', styles.filter(function (s) {
    return s !== '';
  }).join(' '));
  registerCallbacks.call(this, element);
}

function registerCallbacks(element, isDelayed) {
  var this$1 = this;
  var duration = isDelayed ? element.config.duration + element.config.delay : element.config.duration;
  var beforeCallback = element.revealed ? element.config.beforeReveal : element.config.beforeReset;
  var afterCallback = element.revealed ? element.config.afterReveal : element.config.afterReset;
  var elapsed = 0;

  if (element.callbackTimer) {
    elapsed = Date.now() - element.callbackTimer.start;
    window.clearTimeout(element.callbackTimer.clock);
  }

  beforeCallback(element.node);
  element.callbackTimer = {
    start: Date.now(),
    clock: window.setTimeout(function () {
      afterCallback(element.node);
      element.callbackTimer = null;

      if (element.revealed && !element.config.reset && element.config.cleanup) {
        clean.call(this$1, element.node);
      }
    }, duration - elapsed)
  };
}

var nextUniqueId = function () {
  var uid = 0;
  return function () {
    return uid++;
  };
}();

function sequence(element, pristine) {
  if (pristine === void 0) pristine = this.pristine;
  /**
   * We first check if the element should reset.
   */

  if (!element.visible && element.revealed && element.config.reset) {
    return animate.call(this, element, {
      reset: true
    });
  }

  var seq = this.store.sequences[element.sequence.id];
  var i = element.sequence.index;

  if (seq) {
    var visible = new SequenceModel(seq, 'visible', this.store);
    var revealed = new SequenceModel(seq, 'revealed', this.store);
    seq.models = {
      visible: visible,
      revealed: revealed
    };
    /**
     * If the sequence has no revealed members,
     * then we reveal the first visible element
     * within that sequence.
     *
     * The sequence then cues a recursive call
     * in both directions.
     */

    if (!revealed.body.length) {
      var nextId = seq.members[visible.body[0]];
      var nextElement = this.store.elements[nextId];

      if (nextElement) {
        cue.call(this, seq, visible.body[0], -1, pristine);
        cue.call(this, seq, visible.body[0], +1, pristine);
        return animate.call(this, nextElement, {
          reveal: true,
          pristine: pristine
        });
      }
    }
    /**
     * If our element isnt resetting, we check the
     * element sequence index against the head, and
     * then the foot of the sequence.
     */


    if (!seq.blocked.head && i === [].concat(revealed.head).pop() && i >= [].concat(visible.body).shift()) {
      cue.call(this, seq, i, -1, pristine);
      return animate.call(this, element, {
        reveal: true,
        pristine: pristine
      });
    }

    if (!seq.blocked.foot && i === [].concat(revealed.foot).shift() && i <= [].concat(visible.body).pop()) {
      cue.call(this, seq, i, +1, pristine);
      return animate.call(this, element, {
        reveal: true,
        pristine: pristine
      });
    }
  }
}

function Sequence(interval) {
  var i = Math.abs(interval);

  if (!isNaN(i)) {
    this.id = nextUniqueId();
    this.interval = Math.max(i, 16);
    this.members = [];
    this.models = {};
    this.blocked = {
      head: false,
      foot: false
    };
  } else {
    throw new RangeError('Invalid sequence interval.');
  }
}

function SequenceModel(seq, prop, store) {
  var this$1 = this;
  this.head = [];
  this.body = [];
  this.foot = [];
  each(seq.members, function (id, index) {
    var element = store.elements[id];

    if (element && element[prop]) {
      this$1.body.push(index);
    }
  });

  if (this.body.length) {
    each(seq.members, function (id, index) {
      var element = store.elements[id];

      if (element && !element[prop]) {
        if (index < this$1.body[0]) {
          this$1.head.push(index);
        } else {
          this$1.foot.push(index);
        }
      }
    });
  }
}

function cue(seq, i, direction, pristine) {
  var this$1 = this;
  var blocked = ['head', null, 'foot'][1 + direction];
  var nextId = seq.members[i + direction];
  var nextElement = this.store.elements[nextId];
  seq.blocked[blocked] = true;
  setTimeout(function () {
    seq.blocked[blocked] = false;

    if (nextElement) {
      sequence.call(this$1, nextElement, pristine);
    }
  }, seq.interval);
}

function initialize() {
  var this$1 = this;
  rinse.call(this);
  each(this.store.elements, function (element) {
    var styles = [element.styles.inline.generated];

    if (element.visible) {
      styles.push(element.styles.opacity.computed);
      styles.push(element.styles.transform.generated.final);
      element.revealed = true;
    } else {
      styles.push(element.styles.opacity.generated);
      styles.push(element.styles.transform.generated.initial);
      element.revealed = false;
    }

    element.node.setAttribute('style', styles.filter(function (s) {
      return s !== '';
    }).join(' '));
  });
  each(this.store.containers, function (container) {
    var target = container.node === document.documentElement ? window : container.node;
    target.addEventListener('scroll', this$1.delegate);
    target.addEventListener('resize', this$1.delegate);
  });
  /**
   * Manually invoke delegate once to capture
   * element and container dimensions, container
   * scroll position, and trigger any valid reveals
   */

  this.delegate();
  /**
   * Wipe any existing `setTimeout` now
   * that initialization has completed.
   */

  this.initTimeout = null;
}

function isMobile(agent) {
  if (agent === void 0) agent = navigator.userAgent;
  return /Android|iPhone|iPad|iPod/i.test(agent);
}

function deepAssign(target) {
  var sources = [],
      len = arguments.length - 1;

  while (len-- > 0) sources[len] = arguments[len + 1];

  if (isObject(target)) {
    each(sources, function (source) {
      each(source, function (data, key) {
        if (isObject(data)) {
          if (!target[key] || !isObject(target[key])) {
            target[key] = {};
          }

          deepAssign(target[key], data);
        } else {
          target[key] = data;
        }
      });
    });
    return target;
  } else {
    throw new TypeError('Target must be an object literal.');
  }
}

function reveal(target, options, syncing) {
  var this$1 = this;
  if (options === void 0) options = {};
  if (syncing === void 0) syncing = false;
  var containerBuffer = [];
  var sequence$$1;
  var interval = options.interval || defaults.interval;

  try {
    if (interval) {
      sequence$$1 = new Sequence(interval);
    }

    var nodes = Object(tealight__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(target);

    if (!nodes.length) {
      throw new Error('Invalid reveal target.');
    }

    var elements = nodes.reduce(function (elementBuffer, elementNode) {
      var element = {};
      var existingId = elementNode.getAttribute('data-sr-id');

      if (existingId) {
        deepAssign(element, this$1.store.elements[existingId]);
        /**
         * In order to prevent previously generated styles
         * from throwing off the new styles, the style tag
         * has to be reverted to its pre-reveal state.
         */

        element.node.setAttribute('style', element.styles.inline.computed);
      } else {
        element.id = nextUniqueId();
        element.node = elementNode;
        element.seen = false;
        element.revealed = false;
        element.visible = false;
      }

      var config = deepAssign({}, element.config || this$1.defaults, options);

      if (!config.mobile && isMobile() || !config.desktop && !isMobile()) {
        if (existingId) {
          clean.call(this$1, element);
        }

        return elementBuffer; // skip elements that are disabled
      }

      var containerNode = Object(tealight__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(config.container)[0];

      if (!containerNode) {
        throw new Error('Invalid container.');
      }

      if (!containerNode.contains(elementNode)) {
        return elementBuffer; // skip elements found outside the container
      }

      var containerId;
      {
        containerId = getContainerId(containerNode, containerBuffer, this$1.store.containers);

        if (containerId === null) {
          containerId = nextUniqueId();
          containerBuffer.push({
            id: containerId,
            node: containerNode
          });
        }
      }
      element.config = config;
      element.containerId = containerId;
      element.styles = style(element);

      if (sequence$$1) {
        element.sequence = {
          id: sequence$$1.id,
          index: sequence$$1.members.length
        };
        sequence$$1.members.push(element.id);
      }

      elementBuffer.push(element);
      return elementBuffer;
    }, []);
    /**
     * Modifying the DOM via setAttribute needs to be handled
     * separately from reading computed styles in the map above
     * for the browser to batch DOM changes (limiting reflows)
     */

    each(elements, function (element) {
      this$1.store.elements[element.id] = element;
      element.node.setAttribute('data-sr-id', element.id);
    });
  } catch (e) {
    return logger.call(this, 'Reveal failed.', e.message);
  }
  /**
   * Now that element set-up is complete...
   * Lets commit any container and sequence data we have to the store.
   */


  each(containerBuffer, function (container) {
    this$1.store.containers[container.id] = {
      id: container.id,
      node: container.node
    };
  });

  if (sequence$$1) {
    this.store.sequences[sequence$$1.id] = sequence$$1;
  }
  /**
   * If reveal wasn't invoked by sync, we want to
   * make sure to add this call to the history.
   */


  if (syncing !== true) {
    this.store.history.push({
      target: target,
      options: options
    });
    /**
     * Push initialization to the event queue, giving
     * multiple reveal calls time to be interpreted.
     */

    if (this.initTimeout) {
      window.clearTimeout(this.initTimeout);
    }

    this.initTimeout = window.setTimeout(initialize.bind(this), 0);
  }
}

function getContainerId(node) {
  var collections = [],
      len = arguments.length - 1;

  while (len-- > 0) collections[len] = arguments[len + 1];

  var id = null;
  each(collections, function (collection) {
    each(collection, function (container) {
      if (id === null && container.node === node) {
        id = container.id;
      }
    });
  });
  return id;
}
/**
 * Re-runs the reveal method for each record stored in history,
 * for capturing new content asynchronously loaded into the DOM.
 */


function sync() {
  var this$1 = this;
  each(this.store.history, function (record) {
    reveal.call(this$1, record.target, record.options, true);
  });
  initialize.call(this);
}

var polyfill = function (x) {
  return (x > 0) - (x < 0) || +x;
};

var mathSign = Math.sign || polyfill;

function getGeometry(target, isContainer) {
  /**
   * We want to ignore padding and scrollbars for container elements.
   * More information here: https://goo.gl/vOZpbz
   */
  var height = isContainer ? target.node.clientHeight : target.node.offsetHeight;
  var width = isContainer ? target.node.clientWidth : target.node.offsetWidth;
  var offsetTop = 0;
  var offsetLeft = 0;
  var node = target.node;

  do {
    if (!isNaN(node.offsetTop)) {
      offsetTop += node.offsetTop;
    }

    if (!isNaN(node.offsetLeft)) {
      offsetLeft += node.offsetLeft;
    }

    node = node.offsetParent;
  } while (node);

  return {
    bounds: {
      top: offsetTop,
      right: offsetLeft + width,
      bottom: offsetTop + height,
      left: offsetLeft
    },
    height: height,
    width: width
  };
}

function getScrolled(container) {
  var top, left;

  if (container.node === document.documentElement) {
    top = window.pageYOffset;
    left = window.pageXOffset;
  } else {
    top = container.node.scrollTop;
    left = container.node.scrollLeft;
  }

  return {
    top: top,
    left: left
  };
}

function isElementVisible(element) {
  if (element === void 0) element = {};
  var container = this.store.containers[element.containerId];

  if (!container) {
    return;
  }

  var viewFactor = Math.max(0, Math.min(1, element.config.viewFactor));
  var viewOffset = element.config.viewOffset;
  var elementBounds = {
    top: element.geometry.bounds.top + element.geometry.height * viewFactor,
    right: element.geometry.bounds.right - element.geometry.width * viewFactor,
    bottom: element.geometry.bounds.bottom - element.geometry.height * viewFactor,
    left: element.geometry.bounds.left + element.geometry.width * viewFactor
  };
  var containerBounds = {
    top: container.geometry.bounds.top + container.scroll.top + viewOffset.top,
    right: container.geometry.bounds.right + container.scroll.left - viewOffset.right,
    bottom: container.geometry.bounds.bottom + container.scroll.top - viewOffset.bottom,
    left: container.geometry.bounds.left + container.scroll.left + viewOffset.left
  };
  return elementBounds.top < containerBounds.bottom && elementBounds.right > containerBounds.left && elementBounds.bottom > containerBounds.top && elementBounds.left < containerBounds.right || element.styles.position === 'fixed';
}

function delegate(event, elements) {
  var this$1 = this;
  if (event === void 0) event = {
    type: 'init'
  };
  if (elements === void 0) elements = this.store.elements;
  Object(miniraf__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(function () {
    var stale = event.type === 'init' || event.type === 'resize';
    each(this$1.store.containers, function (container) {
      if (stale) {
        container.geometry = getGeometry.call(this$1, container, true);
      }

      var scroll = getScrolled.call(this$1, container);

      if (container.scroll) {
        container.direction = {
          x: mathSign(scroll.left - container.scroll.left),
          y: mathSign(scroll.top - container.scroll.top)
        };
      }

      container.scroll = scroll;
    });
    /**
     * Due to how the sequencer is implemented, its
     * important that we update the state of all
     * elements, before any animation logic is
     * evaluated (in the second loop below).
     */

    each(elements, function (element) {
      if (stale) {
        element.geometry = getGeometry.call(this$1, element);
      }

      element.visible = isElementVisible.call(this$1, element);
    });
    each(elements, function (element) {
      if (element.sequence) {
        sequence.call(this$1, element);
      } else {
        animate.call(this$1, element);
      }
    });
    this$1.pristine = false;
  });
}

function transformSupported() {
  var style = document.documentElement.style;
  return 'transform' in style || 'WebkitTransform' in style;
}

function transitionSupported() {
  var style = document.documentElement.style;
  return 'transition' in style || 'WebkitTransition' in style;
}

var version = "4.0.5";
var boundDelegate;
var boundDestroy;
var boundReveal;
var boundClean;
var boundSync;
var config;
var debug;
var instance;

function ScrollReveal(options) {
  if (options === void 0) options = {};
  var invokedWithoutNew = typeof this === 'undefined' || Object.getPrototypeOf(this) !== ScrollReveal.prototype;

  if (invokedWithoutNew) {
    return new ScrollReveal(options);
  }

  if (!ScrollReveal.isSupported()) {
    logger.call(this, 'Instantiation failed.', 'This browser is not supported.');
    return mount.failure();
  }

  var buffer;

  try {
    buffer = config ? deepAssign({}, config, options) : deepAssign({}, defaults, options);
  } catch (e) {
    logger.call(this, 'Invalid configuration.', e.message);
    return mount.failure();
  }

  try {
    var container = Object(tealight__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(buffer.container)[0];

    if (!container) {
      throw new Error('Invalid container.');
    }
  } catch (e) {
    logger.call(this, e.message);
    return mount.failure();
  }

  config = buffer;

  if (!config.mobile && isMobile() || !config.desktop && !isMobile()) {
    logger.call(this, 'This device is disabled.', "desktop: " + config.desktop, "mobile: " + config.mobile);
    return mount.failure();
  }

  mount.success();
  this.store = {
    containers: {},
    elements: {},
    history: [],
    sequences: {}
  };
  this.pristine = true;
  boundDelegate = boundDelegate || delegate.bind(this);
  boundDestroy = boundDestroy || destroy.bind(this);
  boundReveal = boundReveal || reveal.bind(this);
  boundClean = boundClean || clean.bind(this);
  boundSync = boundSync || sync.bind(this);
  Object.defineProperty(this, 'delegate', {
    get: function () {
      return boundDelegate;
    }
  });
  Object.defineProperty(this, 'destroy', {
    get: function () {
      return boundDestroy;
    }
  });
  Object.defineProperty(this, 'reveal', {
    get: function () {
      return boundReveal;
    }
  });
  Object.defineProperty(this, 'clean', {
    get: function () {
      return boundClean;
    }
  });
  Object.defineProperty(this, 'sync', {
    get: function () {
      return boundSync;
    }
  });
  Object.defineProperty(this, 'defaults', {
    get: function () {
      return config;
    }
  });
  Object.defineProperty(this, 'version', {
    get: function () {
      return version;
    }
  });
  Object.defineProperty(this, 'noop', {
    get: function () {
      return false;
    }
  });
  return instance ? instance : instance = this;
}

ScrollReveal.isSupported = function () {
  return transformSupported() && transitionSupported();
};

Object.defineProperty(ScrollReveal, 'debug', {
  get: function () {
    return debug || false;
  },
  set: function (value) {
    return debug = typeof value === 'boolean' ? value : debug;
  }
});
ScrollReveal();
/* harmony default export */ __webpack_exports__["a"] = (ScrollReveal);

/***/ }),

/***/ "dMnZ":
/*!**********************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/_evalUrl.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../ajax */ "06dU")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  jQuery._evalUrl = function (url) {
    return jQuery.ajax({
      url: url,
      // Make this explicit, since user can override this through ajaxSetup (#11264)
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      "throws": true
    });
  };

  return jQuery._evalUrl;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "dxuR":
/*!***************************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/buildFragment.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../core/toType */ "VAby"), __webpack_require__(/*! ./var/rtagName */ "Jsk8"), __webpack_require__(/*! ./var/rscriptType */ "Reib"), __webpack_require__(/*! ./wrapMap */ "wqe2"), __webpack_require__(/*! ./getAll */ "rwP8"), __webpack_require__(/*! ./setGlobalEval */ "4wmo")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, toType, rtagName, rscriptType, wrapMap, getAll, setGlobalEval) {
  "use strict";

  var rhtml = /<|&#?\w+;/;

  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        contains,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;

    for (; i < l; i++) {
      elem = elems[i];

      if (elem || elem === 0) {
        // Add nodes directly
        if (toType(elem) === "object") {
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

          j = wrap[0];

          while (j--) {
            tmp = tmp.lastChild;
          } // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit


          jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

          tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)

          tmp.textContent = "";
        }
      }
    } // Remove wrapper from fragment


    fragment.textContent = "";
    i = 0;

    while (elem = nodes[i++]) {
      // Skip elements already in the context collection (trac-4087)
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }

        continue;
      }

      contains = jQuery.contains(elem.ownerDocument, elem); // Append to fragment

      tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

      if (contains) {
        setGlobalEval(tmp);
      } // Capture executables


      if (scripts) {
        j = 0;

        while (elem = tmp[j++]) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }

    return fragment;
  }

  return buildFragment;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "dyyg":
/*!*********************************************!*\
  !*** ./node_modules/jquery/src/selector.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./selector-sizzle */ "tx45")], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "ePh3":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/var/indexOf.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./arr */ "xccy")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (arr) {
  "use strict";

  return arr.indexOf;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "eTAU":
/*!********************************************************!*\
  !*** ./node_modules/jquery/src/core/var/rsingleTag.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict"; // Match a standalone tag

  return /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "fcmK":
/*!*****************************************************!*\
  !*** ./node_modules/jquery/src/css/addGetHookIf.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  function addGetHookIf(conditionFn, hookFn) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
      get: function () {
        if (conditionFn()) {
          // Hook not needed (or it's not possible to use it due
          // to missing dependency), remove it.
          delete this.get;
          return;
        } // Hook needed; redefine it so that the support test is not executed again.


        return (this.get = hookFn).apply(this, arguments);
      }
    };
  }

  return addGetHookIf;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "hFd1":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/var/support.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict"; // All support tests are defined in their respective modules.

  return {};
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "hX6M":
/*!**********************************************!*\
  !*** ./node_modules/jquery/src/callbacks.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./core/toType */ "VAby"), __webpack_require__(/*! ./var/isFunction */ "s44h"), __webpack_require__(/*! ./var/rnothtmlwhite */ "VK0Q")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, toType, isFunction, rnothtmlwhite) {
  "use strict"; // Convert String-formatted options into Object-formatted ones

  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */


  jQuery.Callbacks = function (options) {
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

    var // Flag to know if list is currently firing
    firing,
        // Last fire value for non-forgettable lists
    memory,
        // Flag to know if list was already fired
    fired,
        // Flag to prevent firing
    locked,
        // Actual callback list
    list = [],
        // Queue of execution data for repeatable lists
    queue = [],
        // Index of currently firing callback (modified by add/remove as needed)
    firingIndex = -1,
        // Fire callbacks
    fire = function () {
      // Enforce single-firing
      locked = locked || options.once; // Execute callbacks for all pending executions,
      // respecting firingIndex overrides and runtime changes

      fired = firing = true;

      for (; queue.length; firingIndex = -1) {
        memory = queue.shift();

        while (++firingIndex < list.length) {
          // Run callback and check for early termination
          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
            // Jump to end and forget the data so .add doesn't re-fire
            firingIndex = list.length;
            memory = false;
          }
        }
      } // Forget the data if we're done with it


      if (!options.memory) {
        memory = false;
      }

      firing = false; // Clean up if we're done firing for good

      if (locked) {
        // Keep an empty list if we have data for future add calls
        if (memory) {
          list = []; // Otherwise, this object is spent
        } else {
          list = "";
        }
      }
    },
        // Actual Callbacks object
    self = {
      // Add a callback or a collection of callbacks to the list
      add: function () {
        if (list) {
          // If we have memory from a past run, we should fire after adding
          if (memory && !firing) {
            firingIndex = list.length - 1;
            queue.push(memory);
          }

          (function add(args) {
            jQuery.each(args, function (_, arg) {
              if (isFunction(arg)) {
                if (!options.unique || !self.has(arg)) {
                  list.push(arg);
                }
              } else if (arg && arg.length && toType(arg) !== "string") {
                // Inspect recursively
                add(arg);
              }
            });
          })(arguments);

          if (memory && !firing) {
            fire();
          }
        }

        return this;
      },
      // Remove a callback from the list
      remove: function () {
        jQuery.each(arguments, function (_, arg) {
          var index;

          while ((index = jQuery.inArray(arg, list, index)) > -1) {
            list.splice(index, 1); // Handle firing indexes

            if (index <= firingIndex) {
              firingIndex--;
            }
          }
        });
        return this;
      },
      // Check if a given callback is in the list.
      // If no argument is given, return whether or not list has callbacks attached.
      has: function (fn) {
        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
      },
      // Remove all callbacks from the list
      empty: function () {
        if (list) {
          list = [];
        }

        return this;
      },
      // Disable .fire and .add
      // Abort any current/pending executions
      // Clear all callbacks and values
      disable: function () {
        locked = queue = [];
        list = memory = "";
        return this;
      },
      disabled: function () {
        return !list;
      },
      // Disable .fire
      // Also disable .add unless we have memory (since it would have no effect)
      // Abort any pending executions
      lock: function () {
        locked = queue = [];

        if (!memory && !firing) {
          list = memory = "";
        }

        return this;
      },
      locked: function () {
        return !!locked;
      },
      // Call all callbacks with the given context and arguments
      fireWith: function (context, args) {
        if (!locked) {
          args = args || [];
          args = [context, args.slice ? args.slice() : args];
          queue.push(args);

          if (!firing) {
            fire();
          }
        }

        return this;
      },
      // Call all the callbacks with the given arguments
      fire: function () {
        self.fireWith(this, arguments);
        return this;
      },
      // To know if the callbacks have already been called at least once
      fired: function () {
        return !!fired;
      }
    };

    return self;
  };

  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "ikax":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/css/var/rboxStyle.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./cssExpand */ "P+Hb")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (cssExpand) {
  "use strict";

  return new RegExp(cssExpand.join("|"), "i");
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "iprW":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/var/document.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return window.document;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "jE9Z":
/*!********************************************************!*\
  !*** ./node_modules/vue-router/dist/vue-router.esm.js ***!
  \********************************************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/*!
  * vue-router v3.0.2
  * (c) 2018 Evan You
  * @license MIT
  */

/*  */
function assert(condition, message) {
  if (!condition) {
    throw new Error("[vue-router] " + message);
  }
}

function warn(condition, message) {
  if ( true && !condition) {
    typeof console !== 'undefined' && console.warn("[vue-router] " + message);
  }
}

function isError(err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1;
}

function extend(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }

  return a;
}

var View = {
  name: 'RouterView',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render(_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data; // used by devtools to display a router-view badge

    data.routerView = true; // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots

    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {}); // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.

    var depth = 0;
    var inactive = false;

    while (parent && parent._routerRoot !== parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }

      if (parent._inactive) {
        inactive = true;
      }

      parent = parent.$parent;
    }

    data.routerViewDepth = depth; // render previous view if the tree is inactive and kept-alive

    if (inactive) {
      return h(cache[name], data, children);
    }

    var matched = route.matched[depth]; // render empty node if no matched route

    if (!matched) {
      cache[name] = null;
      return h();
    }

    var component = cache[name] = matched.components[name]; // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks

    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];

      if (val && current !== vm || !val && current === vm) {
        matched.instances[name] = val;
      }
    } // also register instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;

    (data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    }; // resolve props


    var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);

    if (propsToPass) {
      // clone to prevent mutation
      propsToPass = data.props = extend({}, propsToPass); // pass non-declared props as attrs

      var attrs = data.attrs = data.attrs || {};

      for (var key in propsToPass) {
        if (!component.props || !(key in component.props)) {
          attrs[key] = propsToPass[key];
          delete propsToPass[key];
        }
      }
    }

    return h(component, data, children);
  }
};

function resolveProps(route, config) {
  switch (typeof config) {
    case 'undefined':
      return;

    case 'object':
      return config;

    case 'function':
      return config(route);

    case 'boolean':
      return config ? route.params : undefined;

    default:
      if (true) {
        warn(false, "props in \"" + route.path + "\" is a " + typeof config + ", " + "expecting an object, function or boolean.");
      }

  }
}
/*  */


var encodeReserveRE = /[!'()*]/g;

var encodeReserveReplacer = function (c) {
  return '%' + c.charCodeAt(0).toString(16);
};

var commaRE = /%2C/g; // fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas

var encode = function (str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

var decode = decodeURIComponent;

function resolveQuery(query, extraQuery, _parseQuery) {
  if (extraQuery === void 0) extraQuery = {};
  var parse = _parseQuery || parseQuery;
  var parsedQuery;

  try {
    parsedQuery = parse(query || '');
  } catch (e) {
     true && warn(false, e.message);
    parsedQuery = {};
  }

  for (var key in extraQuery) {
    parsedQuery[key] = extraQuery[key];
  }

  return parsedQuery;
}

function parseQuery(query) {
  var res = {};
  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });
  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }

        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&');
    }

    return encode(key) + '=' + encode(val);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : null;
  return res ? "?" + res : '';
}
/*  */


var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom, router) {
  var stringifyQuery$$1 = router && router.options.stringifyQuery;
  var query = location.query || {};

  try {
    query = clone(query);
  } catch (e) {}

  var route = {
    name: location.name || record && record.name,
    meta: record && record.meta || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: query,
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery$$1),
    matched: record ? formatMatch(record) : []
  };

  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);
  }

  return Object.freeze(route);
}

function clone(value) {
  if (Array.isArray(value)) {
    return value.map(clone);
  } else if (value && typeof value === 'object') {
    var res = {};

    for (var key in value) {
      res[key] = clone(value[key]);
    }

    return res;
  } else {
    return value;
  }
} // the starting route that represents the initial state


var START = createRoute(null, {
  path: '/'
});

function formatMatch(record) {
  var res = [];

  while (record) {
    res.unshift(record);
    record = record.parent;
  }

  return res;
}

function getFullPath(ref, _stringifyQuery) {
  var path = ref.path;
  var query = ref.query;
  if (query === void 0) query = {};
  var hash = ref.hash;
  if (hash === void 0) hash = '';
  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);
  } else if (a.name && b.name) {
    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {}; // handle null value #1566

  if (!a || !b) {
    return a === b;
  }

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);

  if (aKeys.length !== bKeys.length) {
    return false;
  }

  return aKeys.every(function (key) {
    var aVal = a[key];
    var bVal = b[key]; // check nested equality

    if (typeof aVal === 'object' && typeof bVal === 'object') {
      return isObjectEqual(aVal, bVal);
    }

    return String(aVal) === String(bVal);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }

  return true;
}
/*  */
// work around weird flow bug


var toTypes = [String, Object];
var eventTypes = [String, Array];
var Link = {
  name: 'RouterLink',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render(h) {
    var this$1 = this;
    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;
    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass; // Support global empty active class

    var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;
    var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;
    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;
    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;
    var compareTarget = location.path ? createRoute(null, location, null, router) : route;
    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = {
      click: guardEvent
    };

    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = {
        href: href
      };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);

      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {
    return;
  } // don't redirect when preventDefault called


  if (e.defaultPrevented) {
    return;
  } // don't redirect on right click


  if (e.button !== undefined && e.button !== 0) {
    return;
  } // don't redirect if `target="_blank"`


  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');

    if (/\b_blank\b/i.test(target)) {
      return;
    }
  } // this may be a Weex event which doesn't have this method


  if (e.preventDefault) {
    e.preventDefault();
  }

  return true;
}

function findAnchor(children) {
  if (children) {
    var child;

    for (var i = 0; i < children.length; i++) {
      child = children[i];

      if (child.tag === 'a') {
        return child;
      }

      if (child.children && (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed && _Vue === Vue) {
    return;
  }

  install.installed = true;
  _Vue = Vue;

  var isDef = function (v) {
    return v !== undefined;
  };

  var registerInstance = function (vm, callVal) {
    var i = vm.$options._parentVnode;

    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;

        this._router.init(this);

        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = this.$parent && this.$parent._routerRoot || this;
      }

      registerInstance(this, this);
    },
    destroyed: function destroyed() {
      registerInstance(this);
    }
  });
  Object.defineProperty(Vue.prototype, '$router', {
    get: function get() {
      return this._routerRoot._router;
    }
  });
  Object.defineProperty(Vue.prototype, '$route', {
    get: function get() {
      return this._routerRoot._route;
    }
  });
  Vue.component('RouterView', View);
  Vue.component('RouterLink', Link);
  var strats = Vue.config.optionMergeStrategies; // use the same hook merging strategy for route hooks

  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}
/*  */


var inBrowser = typeof window !== 'undefined';
/*  */

function resolvePath(relative, base, append) {
  var firstChar = relative.charAt(0);

  if (firstChar === '/') {
    return relative;
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative;
  }

  var stack = base.split('/'); // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)

  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  } // resolve relative path


  var segments = relative.replace(/^\//, '').split('/');

  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];

    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  } // ensure leading slash


  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/');
}

function parsePath(path) {
  var hash = '';
  var query = '';
  var hashIndex = path.indexOf('#');

  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');

  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, '/');
}

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};
/**
 * Expose `pathToRegexp`.
 */


var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;
/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */

var PATH_REGEXP = new RegExp([// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)', // Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');
/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */

function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length; // Ignore already escaped sequences.

    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7]; // Push the current path onto the tokens.

    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;
    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  } // Match any characters still remaining.


  if (index < str.length) {
    path += str.substr(index);
  } // If the path exists, push it onto the end.


  if (path) {
    tokens.push(path);
  }

  return tokens;
}
/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */


function compile(str, options) {
  return tokensToFunction(parse(str, options));
}
/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */


function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */


function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
/**
 * Expose a method for transforming tokens into the path function.
 */


function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length); // Compile all the patterns before compilation.

  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;
        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}
/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */


function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}
/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */


function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}
/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */


function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}
/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */


function flags(options) {
  return options.sensitive ? '' : 'i';
}
/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */


function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}
/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */


function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
  return attachKeys(regexp, keys);
}
/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */


function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */


function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options =
    /** @type {!Object} */
    keys || options;
    keys = [];
  }

  options = options || {};
  var strict = options.strict;
  var end = options.end !== false;
  var route = ''; // Iterate over the tokens and create our regexp string.

  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';
      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter; // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".

  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */


function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options =
    /** @type {!Object} */
    keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path,
    /** @type {!Array} */
    keys);
  }

  if (isarray(path)) {
    return arrayToRegexp(
    /** @type {!Array} */
    path,
    /** @type {!Array} */
    keys, options);
  }

  return stringToRegexp(
  /** @type {string} */
  path,
  /** @type {!Array} */
  keys, options);
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;
/*  */
// $flow-disable-line

var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = pathToRegexp_1.compile(path));
    return filler(params || {}, {
      pretty: true
    });
  } catch (e) {
    if (true) {
      warn(false, "missing param for " + routeMsg + ": " + e.message);
    }

    return '';
  }
}
/*  */


function createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || []; // $flow-disable-line

  var pathMap = oldPathMap || Object.create(null); // $flow-disable-line

  var nameMap = oldNameMap || Object.create(null);
  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  }); // ensure wildcard routes are always at the end

  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;

  if (true) {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(typeof route.component !== 'string', "route config \"component\" for path: " + String(path || name) + " cannot be a " + "string id. Use an actual component instead.");
  }

  var pathToRegexpOptions = route.pathToRegexpOptions || {};
  var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || {
      default: route.component
    },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : {
      default: route.props
    }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (true) {
      if (route.name && !route.redirect && route.children.some(function (child) {
        return /^\/?$/.test(child.path);
      })) {
        warn(false, "Named Route '" + route.name + "' has a default child route. " + "When navigating to this named route (:to=\"{name: '" + route.name + "'\"), " + "the default child route will not be rendered. Remove the name from " + "this route and use the name of the default child route for named " + "links instead.");
      }
    }

    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + "/" + child.path) : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];
    aliases.forEach(function (alias) {
      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs
      );
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if ( true && !matchAs) {
      warn(false, "Duplicate named routes definition: " + "{ name: \"" + name + "\", path: \"" + record.path + "\" }");
    }
  }
}

function compileRouteRegex(path, pathToRegexpOptions) {
  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);

  if (true) {
    var keys = Object.create(null);
    regex.keys.forEach(function (key) {
      warn(!keys[key.name], "Duplicate param keys in route with path: \"" + path + "\"");
      keys[key.name] = true;
    });
  }

  return regex;
}

function normalizePath(path, parent, strict) {
  if (!strict) {
    path = path.replace(/\/$/, '');
  }

  if (path[0] === '/') {
    return path;
  }

  if (parent == null) {
    return path;
  }

  return cleanPath(parent.path + "/" + path);
}
/*  */


function normalizeLocation(raw, current, append, router) {
  var next = typeof raw === 'string' ? {
    path: raw
  } : raw; // named target

  if (next.name || next._normalized) {
    return next;
  } // relative params


  if (!next.path && next.params && current) {
    next = extend({}, next);
    next._normalized = true;
    var params = extend(extend({}, current.params), next.params);

    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, "path " + current.path);
    } else if (true) {
      warn(false, "relative params navigation requires a current route.");
    }

    return next;
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = current && current.path || '/';
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;
  var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);
  var hash = next.hash || parsedPath.hash;

  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}
/*  */


function createMatcher(routes, router) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];

      if (true) {
        warn(record, "Route with name '" + name + "' does not exist");
      }

      if (!record) {
        return _createRoute(null, location);
      }

      var paramNames = record.regex.keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, "named route \"" + name + "\"");
        return _createRoute(record, location, redirectedFrom);
      }
    } else if (location.path) {
      location.params = {};

      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];

        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom);
        }
      }
    } // no match


    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = {
        path: redirect
      };
    }

    if (!redirect || typeof redirect !== 'object') {
      if (true) {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }

      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];

      if (true) {
        assert(targetRecord, "redirect failed: named route \"" + name + "\" not found.");
      }

      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record); // 2. resolve params

      var resolvedPath = fillParams(rawPath, params, "redirect route with path \"" + rawPath + "\""); // 3. rematch with existing query and hash

      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      if (true) {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }

      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, "aliased route with path \"" + matchAs + "\"");
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });

    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }

    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location);
    }

    if (record && record.matchAs) {
      return alias(record, location, record.matchAs);
    }

    return createRoute(record, location, redirectedFrom, router);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(regex, path, params) {
  var m = path.match(regex);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];

    if (key) {
      // Fix #1994: using * with props: true generates a param named 0
      params[key.name || 'pathMatch'] = val;
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true);
}
/*  */


var positionStore = Object.create(null);

function setupScroll() {
  // Fix for #1585 for Firefox
  // Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678
  window.history.replaceState({
    key: getStateKey()
  }, '', window.location.href.replace(window.location.origin, ''));
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();

    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;

  if (!behavior) {
    return;
  }

  if (true) {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  } // wait until re-render finishes before scrolling


  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior.call(router, to, from, isPop ? position : null);

    if (!shouldScroll) {
      return;
    }

    if (typeof shouldScroll.then === 'function') {
      shouldScroll.then(function (shouldScroll) {
        scrollToPosition(shouldScroll, position);
      }).catch(function (err) {
        if (true) {
          assert(false, err.toString());
        }
      });
    } else {
      scrollToPosition(shouldScroll, position);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();

  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition() {
  var key = getStateKey();

  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function normalizeOffset(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  };
}

function isNumber(v) {
  return typeof v === 'number';
}

function scrollToPosition(shouldScroll, position) {
  var isObject = typeof shouldScroll === 'object';

  if (isObject && typeof shouldScroll.selector === 'string') {
    var el = document.querySelector(shouldScroll.selector);

    if (el) {
      var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};
      offset = normalizeOffset(offset);
      position = getElementPosition(el, offset);
    } else if (isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }
  } else if (isObject && isValidPosition(shouldScroll)) {
    position = normalizePosition(shouldScroll);
  }

  if (position) {
    window.scrollTo(position.x, position.y);
  }
}
/*  */


var supportsPushState = inBrowser && function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }

  return window.history && 'pushState' in window.history;
}(); // use User Timing api (if present) for more accurate key precision


var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;

var _key = genKey();

function genKey() {
  return Time.now().toFixed(3);
}

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  _key = key;
}

function pushState(url, replace) {
  saveScrollPosition(); // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls

  var history = window.history;

  try {
    if (replace) {
      history.replaceState({
        key: _key
      }, '', url);
    } else {
      _key = genKey();
      history.pushState({
        key: _key
      }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}
/*  */


function runQueue(queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };

  step(0);
}
/*  */


function resolveAsyncComponents(matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;
    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;
        var resolve = once(function (resolvedDef) {
          if (isESModule(resolvedDef)) {
            resolvedDef = resolvedDef.default;
          } // save resolved on async factory in case it's used elsewhere


          def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;

          if (pending <= 0) {
            next();
          }
        });
        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
           true && warn(false, msg);

          if (!error) {
            error = isError(reason) ? reason : new Error(msg);
            next(error);
          }
        });
        var res;

        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }

        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;

            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) {
      next();
    }
  };
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

var hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

function isESModule(obj) {
  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === 'Module';
} // in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.


function once(fn) {
  var called = false;
  return function () {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    if (called) {
      return;
    }

    called = true;
    return fn.apply(this, args);
  };
}
/*  */


var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base); // start with a route object that stands for "nowhere"

  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);

    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError(errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;
  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL(); // fire ready cbs once

    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, function (err) {
    if (onAbort) {
      onAbort(err);
    }

    if (err && !this$1.ready) {
      this$1.ready = true;
      this$1.readyErrorCbs.forEach(function (cb) {
        cb(err);
      });
    }
  });
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;
  var current = this.current;

  var abort = function (err) {
    if (isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) {
          cb(err);
        });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }

    onAbort && onAbort(err);
  };

  if (isSameRoute(route, current) && // in the case the route map has been dynamically appended to
  route.matched.length === current.matched.length) {
    this.ensureURL();
    return abort();
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;
  var queue = [].concat( // in-component leave guards
  extractLeaveGuards(deactivated), // global before hooks
  this.router.beforeHooks, // in-component update hooks
  extractUpdateHooks(updated), // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }), // async components
  resolveAsyncComponents(activated));
  this.pending = route;

  var iterator = function (hook, next) {
    if (this$1.pending !== route) {
      return abort();
    }

    try {
      hook(route, current, function (to) {
        if (to === false || isError(to)) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(to);
        } else if (typeof to === 'string' || typeof to === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {
          // next('/') or next({ path: '/' }) -> redirect
          abort();

          if (typeof to === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];

    var isValid = function () {
      return this$1.current === route;
    }; // wait until async components are resolved before
    // extracting in-component enter guards


    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort();
      }

      this$1.pending = null;
      onComplete(route);

      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/'; // strip full URL origin

      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  } // make sure there's the starting slash


  if (base.charAt(0) !== '/') {
    base = '/' + base;
  } // remove trailing slash


  return base.replace(/\/$/, '');
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);

  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }

  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);

    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }

  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);
}

function bindGuard(guard, instance) {
  if (instance) {
    return function boundRouteGuard() {
      return guard.apply(instance, arguments);
    };
  }
}

function extractEnterGuards(activated, cbs, isValid) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid);
  });
}

function bindEnterGuard(guard, match, key, cbs, isValid) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);

      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    });
  };
}

function poll(cb, // somehow flow cannot infer this is a function
instances, key, isValid) {
  if (instances[key] && !instances[key]._isBeingDestroyed // do not reuse being destroyed instance
  ) {
      cb(instances[key]);
    } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}
/*  */


var HTML5History = function (History$$1) {
  function HTML5History(router, base) {
    var this$1 = this;
    History$$1.call(this, router, base);
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      setupScroll();
    }

    var initLocation = getLocation(this.base);
    window.addEventListener('popstate', function (e) {
      var current = this$1.current; // Avoiding first `popstate` event dispatched in some browsers but first
      // history route not updated since async guard at the same time.

      var location = getLocation(this$1.base);

      if (this$1.current === START && location === initLocation) {
        return;
      }

      this$1.transitionTo(location, function (route) {
        if (supportsScroll) {
          handleScroll(router, route, current, true);
        }
      });
    });
  }

  if (History$$1) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = decodeURI(window.location.pathname);

  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }

  return (path || '/') + window.location.search + window.location.hash;
}
/*  */


var HashHistory = function (History$$1) {
  function HashHistory(router, base, fallback) {
    History$$1.call(this, router, base); // check history fallback deeplinking

    if (fallback && checkFallback(this.base)) {
      return;
    }

    ensureSlash();
  }

  if (History$$1) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  HashHistory.prototype.constructor = HashHistory; // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early

  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;
    var router = this.router;
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      setupScroll();
    }

    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', function () {
      var current = this$1.current;

      if (!ensureSlash()) {
        return;
      }

      this$1.transitionTo(getHash(), function (route) {
        if (supportsScroll) {
          handleScroll(this$1.router, route, current, true);
        }

        if (!supportsPushState) {
          replaceHash(route.fullPath);
        }
      });
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;

    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);

  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();

  if (path.charAt(0) === '/') {
    return true;
  }

  replaceHash('/' + path);
  return false;
}

function getHash() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : decodeURI(href.slice(index + 1));
}

function getUrl(path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  return base + "#" + path;
}

function pushHash(path) {
  if (supportsPushState) {
    pushState(getUrl(path));
  } else {
    window.location.hash = path;
  }
}

function replaceHash(path) {
  if (supportsPushState) {
    replaceState(getUrl(path));
  } else {
    window.location.replace(getUrl(path));
  }
}
/*  */


var AbstractHistory = function (History$$1) {
  function AbstractHistory(router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History$$1) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;
    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;
    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;
    var targetIndex = this.index + n;

    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return;
    }

    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/';
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {// noop
  };

  return AbstractHistory;
}(History);
/*  */


var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};
  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);
  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;

  if (this.fallback) {
    mode = 'hash';
  }

  if (!inBrowser) {
    mode = 'abstract';
  }

  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break;

    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break;

    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break;

    default:
      if (true) {
        assert(false, "invalid mode: " + mode);
      }

  }
};

var prototypeAccessors = {
  currentRoute: {
    configurable: true
  }
};

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current;
};

VueRouter.prototype.init = function init(app
/* Vue component instance */
) {
  var this$1 = this;
   true && assert(install.installed, "not installed. Make sure to call `Vue.use(VueRouter)` " + "before creating root instance.");
  this.apps.push(app); // main app already initialized.

  if (this.app) {
    return;
  }

  this.app = app;
  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function () {
      history.setupListeners();
    };

    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  return registerHook(this.beforeHooks, fn);
};

VueRouter.prototype.beforeResolve = function beforeResolve(fn) {
  return registerHook(this.resolveHooks, fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  return registerHook(this.afterHooks, fn);
};

VueRouter.prototype.onReady = function onReady(cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError(errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;

  if (!route) {
    return [];
  }

  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  var location = normalizeLocation(to, current || this.history.current, append, this);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);

  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function registerHook(list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);

    if (i > -1) {
      list.splice(i, 1);
    }
  };
}

function createHref(base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path;
}

VueRouter.install = install;
VueRouter.version = '3.0.2';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

/* harmony default export */ __webpack_exports__["a"] = (VueRouter);

/***/ }),

/***/ "jbNc":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/var/toString.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./class2type */ "FDjK")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (class2type) {
  "use strict";

  return class2type.toString;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "jz24":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/core/camelCase.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict"; // Matches dashed string for camelizing

  var rmsPrefix = /^-ms-/,
      rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()

  function fcamelCase(all, letter) {
    return letter.toUpperCase();
  } // Convert dashed to camelCase; used by the css and data modules
  // Support: IE <=9 - 11, Edge 12 - 15
  // Microsoft forgot to hump their vendor prefix (#9572)


  function camelCase(string) {
    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
  }

  return camelCase;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "kKdo":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/css/var/getStyles.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return function (elem) {
    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    var view = elem.ownerDocument.defaultView;

    if (!view || !view.opener) {
      view = window;
    }

    return view.getComputedStyle(elem);
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "kRrN":
/*!**************************************************!*\
  !*** ./node_modules/jquery/src/ajax/parseXML.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict"; // Cross-browser xml parsing

  jQuery.parseXML = function (data) {
    var xml;

    if (!data || typeof data !== "string") {
      return null;
    } // Support: IE 9 - 11 only
    // IE throws on parseFromString with invalid input.


    try {
      xml = new window.DOMParser().parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }

    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }

    return xml;
  };

  return jQuery.parseXML;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "l58E":
/*!**************************************************!*\
  !*** ./node_modules/jquery/src/event/trigger.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../var/document */ "iprW"), __webpack_require__(/*! ../data/var/dataPriv */ "082X"), __webpack_require__(/*! ../data/var/acceptData */ "T3mA"), __webpack_require__(/*! ../var/hasOwn */ "D0Jr"), __webpack_require__(/*! ../var/isFunction */ "s44h"), __webpack_require__(/*! ../var/isWindow */ "16XX"), __webpack_require__(/*! ../event */ "Y7H9")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document, dataPriv, acceptData, hasOwn, isFunction, isWindow) {
  "use strict";

  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      stopPropagationCallback = function (e) {
    e.stopPropagation();
  };

  jQuery.extend(jQuery.event, {
    trigger: function (event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          lastElement,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes

      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      } // focus/blur morphs to focusin/out; ensure we're not firing them right now


      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }

      if (type.indexOf(".") > -1) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }

      ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

      event.result = undefined;

      if (!event.target) {
        event.target = elem;
      } // Clone any incoming data and prepend the event, creating the handler arg list


      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

      special = jQuery.event.special[type] || {};

      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      } // Determine event propagation path in advance, per W3C events spec (#9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
        bubbleType = special.delegateType || type;

        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }

        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        } // Only add window if we got to document (e.g., not plain obj or detached DOM)


        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      } // Fire handlers on the event path


      i = 0;

      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        lastElement = cur;
        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

        handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");

        if (handle) {
          handle.apply(cur, data);
        } // Native handler


        handle = ontype && cur[ontype];

        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);

          if (event.result === false) {
            event.preventDefault();
          }
        }
      }

      event.type = type; // If nobody prevented the default action, do it now

      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          // Call a native DOM method on the target with the same name as the event.
          // Don't do default actions on window, that's where global variables be (#6170)
          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ontype];

            if (tmp) {
              elem[ontype] = null;
            } // Prevent re-triggering of the same event, since we already bubbled it above


            jQuery.event.triggered = type;

            if (event.isPropagationStopped()) {
              lastElement.addEventListener(type, stopPropagationCallback);
            }

            elem[type]();

            if (event.isPropagationStopped()) {
              lastElement.removeEventListener(type, stopPropagationCallback);
            }

            jQuery.event.triggered = undefined;

            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }

      return event.result;
    },
    // Piggyback on a donor event to simulate a different one
    // Used only for `focus(in | out)` events
    simulate: function (type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
    }
  });
  jQuery.fn.extend({
    trigger: function (type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function (type, data) {
      var elem = this[0];

      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "lTfz":
/*!*******************************************!*\
  !*** ./node_modules/jquery/src/jquery.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./selector */ "dyyg"), __webpack_require__(/*! ./traversing */ "wkHr"), __webpack_require__(/*! ./callbacks */ "hX6M"), __webpack_require__(/*! ./deferred */ "G5n7"), __webpack_require__(/*! ./deferred/exceptionHook */ "o7dz"), __webpack_require__(/*! ./core/ready */ "vnkT"), __webpack_require__(/*! ./data */ "pEgf"), __webpack_require__(/*! ./queue */ "0VMG"), __webpack_require__(/*! ./queue/delay */ "4f4o"), __webpack_require__(/*! ./attributes */ "njZu"), __webpack_require__(/*! ./event */ "Y7H9"), __webpack_require__(/*! ./event/focusin */ "F7/y"), __webpack_require__(/*! ./manipulation */ "PRQw"), __webpack_require__(/*! ./manipulation/_evalUrl */ "dMnZ"), __webpack_require__(/*! ./wrap */ "7fyN"), __webpack_require__(/*! ./css */ "1wM/"), __webpack_require__(/*! ./css/hiddenVisibleSelectors */ "Snig"), __webpack_require__(/*! ./serialize */ "xrz1"), __webpack_require__(/*! ./ajax */ "06dU"), __webpack_require__(/*! ./ajax/xhr */ "06pk"), __webpack_require__(/*! ./ajax/script */ "Qlux"), __webpack_require__(/*! ./ajax/jsonp */ "Knyl"), __webpack_require__(/*! ./ajax/load */ "ZNX1"), __webpack_require__(/*! ./event/ajax */ "E9Km"), __webpack_require__(/*! ./effects */ "vY0G"), __webpack_require__(/*! ./effects/animatedSelector */ "w5up"), __webpack_require__(/*! ./offset */ "9Pyl"), __webpack_require__(/*! ./dimensions */ "lX2t"), __webpack_require__(/*! ./deprecated */ "NYe2"), __webpack_require__(/*! ./exports/amd */ "2Tf1"), __webpack_require__(/*! ./exports/global */ "T0SL")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "lX2t":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/dimensions.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./core/access */ "MT+g"), __webpack_require__(/*! ./var/isWindow */ "16XX"), __webpack_require__(/*! ./css */ "1wM/")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, access, isWindow) {
  "use strict"; // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

  jQuery.each({
    Height: "height",
    Width: "width"
  }, function (name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function (defaultExtra, funcName) {
      // Margin is only for outerHeight, outerWidth
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function (elem, type, value) {
          var doc;

          if (isWindow(elem)) {
            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
          } // Get document width or height


          if (elem.nodeType === 9) {
            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
            // whichever is greatest

            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }

          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
          jQuery.css(elem, type, extra) : // Set width or height on the element
          jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable);
      };
    });
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "m7xV":
/*!***********************************************************!*\
  !*** ./node_modules/vue-style-loader/lib/listToStyles.js ***!
  \***********************************************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return listToStyles; });
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles(parentId, list) {
  var styles = [];
  var newStyles = {};

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    };

    if (!newStyles[id]) {
      styles.push(newStyles[id] = {
        id: id,
        parts: [part]
      });
    } else {
      newStyles[id].parts.push(part);
    }
  }

  return styles;
}

/***/ }),

/***/ "mEBU":
/*!*****************************************!*\
  !*** ./node_modules/jquery/src/core.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./var/arr */ "xccy"), __webpack_require__(/*! ./var/document */ "iprW"), __webpack_require__(/*! ./var/getProto */ "zhKS"), __webpack_require__(/*! ./var/slice */ "QQxG"), __webpack_require__(/*! ./var/concat */ "4U/f"), __webpack_require__(/*! ./var/push */ "y2oz"), __webpack_require__(/*! ./var/indexOf */ "ePh3"), __webpack_require__(/*! ./var/class2type */ "FDjK"), __webpack_require__(/*! ./var/toString */ "jbNc"), __webpack_require__(/*! ./var/hasOwn */ "D0Jr"), __webpack_require__(/*! ./var/fnToString */ "HATn"), __webpack_require__(/*! ./var/ObjectFunctionString */ "+aR0"), __webpack_require__(/*! ./var/support */ "hFd1"), __webpack_require__(/*! ./var/isFunction */ "s44h"), __webpack_require__(/*! ./var/isWindow */ "16XX"), __webpack_require__(/*! ./core/DOMEval */ "+y+W"), __webpack_require__(/*! ./core/toType */ "VAby")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (arr, document, getProto, slice, concat, push, indexOf, class2type, toString, hasOwn, fnToString, ObjectFunctionString, support, isFunction, isWindow, DOMEval, toType) {
  "use strict";

  var version = "3.3.1",
      // Define a local copy of jQuery
  jQuery = function (selector, context) {
    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init(selector, context);
  },
      // Support: Android <=4.0 only
  // Make sure we trim BOM and NBSP
  rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

  jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,
    constructor: jQuery,
    // The default length of a jQuery object is 0
    length: 0,
    toArray: function () {
      return slice.call(this);
    },
    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function (num) {
      // Return all the elements in a clean array
      if (num == null) {
        return slice.call(this);
      } // Return just the one element from the set


      return num < 0 ? this[num + this.length] : this[num];
    },
    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function (elems) {
      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

      ret.prevObject = this; // Return the newly-formed element set

      return ret;
    },
    // Execute a callback for every element in the matched set.
    each: function (callback) {
      return jQuery.each(this, callback);
    },
    map: function (callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function () {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function () {
      return this.eq(0);
    },
    last: function () {
      return this.eq(-1);
    },
    eq: function (i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function () {
      return this.prevObject || this.constructor();
    },
    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };

  jQuery.extend = jQuery.fn.extend = function () {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false; // Handle a deep copy situation

    if (typeof target === "boolean") {
      deep = target; // Skip the boolean and the target

      target = arguments[i] || {};
      i++;
    } // Handle case when target is a string or something (possible in deep copy)


    if (typeof target !== "object" && !isFunction(target)) {
      target = {};
    } // Extend jQuery itself if only one argument is passed


    if (i === length) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          src = target[name];
          copy = options[name]; // Prevent never-ending loop

          if (target === copy) {
            continue;
          } // Recurse if we're merging plain objects or arrays


          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && Array.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            } // Never move original objects, clone them


            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    } // Return the modified object


    return target;
  };

  jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    // Assume jQuery is ready without the ready module
    isReady: true,
    error: function (msg) {
      throw new Error(msg);
    },
    noop: function () {},
    isPlainObject: function (obj) {
      var proto, Ctor; // Detect obvious negatives
      // Use toString instead of jQuery.type to catch host objects

      if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
      }

      proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

      if (!proto) {
        return true;
      } // Objects with prototype are plain iff they were constructed by a global Object function


      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
    },
    isEmptyObject: function (obj) {
      /* eslint-disable no-unused-vars */
      // See https://github.com/eslint/eslint/issues/6125
      var name;

      for (name in obj) {
        return false;
      }

      return true;
    },
    // Evaluates a script in a global context
    globalEval: function (code) {
      DOMEval(code);
    },
    each: function (obj, callback) {
      var length,
          i = 0;

      if (isArrayLike(obj)) {
        length = obj.length;

        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }

      return obj;
    },
    // Support: Android <=4.0 only
    trim: function (text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    // results is for internal usage only
    makeArray: function (arr, results) {
      var ret = results || [];

      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }

      return ret;
    },
    inArray: function (elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    // Support: Android <=4.0 only, PhantomJS 1 only
    // push.apply(_, arraylike) throws on ancient WebKit
    merge: function (first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;

      for (; j < len; j++) {
        first[i++] = second[j];
      }

      first.length = i;
      return first;
    },
    grep: function (elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert; // Go through the array, only saving the items
      // that pass the validator function

      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);

        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }

      return matches;
    },
    // arg is for internal usage only
    map: function (elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = []; // Go through the array, translating each of the items to their new values

      if (isArrayLike(elems)) {
        length = elems.length;

        for (; i < length; i++) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        } // Go through every key on the object,

      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        }
      } // Flatten any nested arrays


      return concat.apply([], ret);
    },
    // A global GUID counter for objects
    guid: 1,
    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
  });

  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  } // Populate the class2type map


  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

  function isArrayLike(obj) {
    // Support: real iOS 8.2 only (not reproducible in simulator)
    // `in` check used to prevent JIT error (gh-2145)
    // hasOwn isn't used here due to false negatives
    // regarding Nodelist length in IE
    var length = !!obj && "length" in obj && obj.length,
        type = toType(obj);

    if (isFunction(obj) || isWindow(obj)) {
      return false;
    }

    return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
  }

  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "lTfz")))

/***/ }),

/***/ "njZu":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/attributes.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./attributes/attr */ "q7bA"), __webpack_require__(/*! ./attributes/prop */ "8g73"), __webpack_require__(/*! ./attributes/classes */ "12ai"), __webpack_require__(/*! ./attributes/val */ "wLhr")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict"; // Return jQuery for attributes-only inclusion

  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "o7dz":
/*!***********************************************************!*\
  !*** ./node_modules/jquery/src/deferred/exceptionHook.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../deferred */ "G5n7")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict"; // These usually indicate a programmer mistake during development,
  // warn about them ASAP rather than swallowing them by default.

  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  jQuery.Deferred.exceptionHook = function (error, stack) {
    // Support: IE 8 - 9 only
    // Console exists when dev tools are open, which can happen at any time
    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
      window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "oCYn":
/*!******************************************!*\
  !*** ./node_modules/vue/dist/vue.esm.js ***!
  \******************************************/
/*! exports provided: default */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
 * Vue.js v2.6.10
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */

/*  */
var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}
/**
 * Check if value is primitive.
 */


function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
  typeof value === 'symbol' || typeof value === 'boolean';
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

function isPromise(val) {
  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
}
/**
 * Convert a value to a string that is actually rendered.
 */


function toString(val) {
  return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */


function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */

function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether an object has the property.
 */


var hasOwnProperty = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
/**
 * Capitalize a string.
 */

var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */

var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);

  while (i--) {
    ret[i] = list[i + start];
  }

  return ret;
}
/**
 * Mix properties into target object.
 */


function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */


function toObject(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */


function noop(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */


var identity = function (_) {
  return _;
};
/**
 * Generate a string containing static keys from compiler modules.
 */


function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */


function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var isObjectA = isObject(a);
  var isObjectB = isObject(b);

  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);

      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */


function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }

  return -1;
}
/**
 * Ensure a function is called only once.
 */


function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];
/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};
/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */

var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
/**
 * Check if a string starts with $ or _
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}
/**
 * Define a property.
 */


function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
/**
 * Parse simple path.
 */


var bailRE = new RegExp("[^" + unicodeRegExp.source + ".$_\\d]");

function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }

  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }

      obj = obj[segments[i]];
    }

    return obj;
  };
}
/*  */
// can we use __proto__?


var hasProto = '__proto__' in {}; // Browser environment sniffing

var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...

var nativeWatch = {}.watch;
var supportsPassive = false;

if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285

    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
} // this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV


var _isServer;

var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }

  return _isServer;
}; // detect devtools


var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */

function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */
// $flow-disable-line


if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set =
  /*@__PURE__*/
  function () {
    function Set() {
      this.set = Object.create(null);
    }

    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };

    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };

    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}
/*  */


var warn = noop;
var tip = noop;
var generateComponentTrace = noop; // work around flow check

var formatComponentName = noop;

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;

  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }

    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;

    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat = function (str, n) {
    var res = '';

    while (n) {
      if (n % 2 === 1) {
        res += str;
      }

      if (n > 1) {
        str += str;
      }

      n >>= 1;
    }

    return res;
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;

      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];

          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }

        tree.push(vm);
        vm = vm.$parent;
      }

      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}
/*  */


var uid = 0;
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */

var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();

  if ( true && !config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) {
      return a.id - b.id;
    });
  }

  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
}; // The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.


Dep.target = null;
var targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
/*  */


var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = {
  child: {
    configurable: true
  }
}; // DEPRECATED: alias for componentInstance for backwards compat.

/* istanbul ignore next */

prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
} // optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.


function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, // #7975
  // clone children array to avoid mutating original in case of cloning
  // a child.
  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */


var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);
var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
/**
 * Intercept mutating methods and emit events
 */

methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;

    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;

      case 'splice':
        inserted = args.slice(2);
        break;
    }

    if (inserted) {
      ob.observeArray(inserted);
    } // notify change


    ob.dep.notify();
    return result;
  });
});
/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */

var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */


var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);

  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }

    this.observeArray(value);
  } else {
    this.walk(value);
  }
};
/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */


Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};
/**
 * Observe a list of Array items.
 */


Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
}; // helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */


function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}
/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */

/* istanbul ignore next */


function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */


function observe(value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return;
  }

  var ob;

  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }

  if (asRootData && ob) {
    ob.vmCount++;
  }

  return ob;
}
/**
 * Define a reactive property on an Object.
 */


function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);

  if (property && property.configurable === false) {
    return;
  } // cater for pre-defined getter/setters


  var getter = property && property.get;
  var setter = property && property.set;

  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;

      if (Dep.target) {
        dep.depend();

        if (childOb) {
          childOb.dep.depend();

          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }

      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */

      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */


      if ( true && customSetter) {
        customSetter();
      } // #7981: for accessor properties without setter


      if (getter && !setter) {
        return;
      }

      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }

      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}
/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */


function set(target, key, val) {
  if ( true && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }

  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
     true && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }

  if (!ob) {
    target[key] = val;
    return val;
  }

  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}
/**
 * Delete a property and trigger change if necessary.
 */


function del(target, key) {
  if ( true && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
     true && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }

  if (!hasOwn(target, key)) {
    return;
  }

  delete target[key];

  if (!ob) {
    return;
  }

  ob.dep.notify();
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */


function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();

    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */


var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */

if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }

    return defaultStrat(parent, child);
  };
}
/**
 * Helper that recursively merges two data objects together.
 */


function mergeData(to, from) {
  if (!from) {
    return to;
  }

  var key, toVal, fromVal;
  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i]; // in case the object is already observed...

    if (key === '__ob__') {
      continue;
    }

    toVal = to[key];
    fromVal = from[key];

    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }

  return to;
}
/**
 * Data
 */


function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }

    if (!parentVal) {
      return childVal;
    } // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.


    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
       true && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }

    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */


function mergeHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}

function dedupeHooks(hooks) {
  var res = [];

  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }

  return res;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);

  if (childVal) {
     true && assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }

  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */


  if (!childVal) {
    return Object.create(parentVal || null);
  }

  if (true) {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = {};
  extend(ret, parentVal);

  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];

    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }

    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }

  return ret;
};
/**
 * Other object hashes.
 */


strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = Object.create(null);
  extend(ret, parentVal);

  if (childVal) {
    extend(ret, childVal);
  }

  return ret;
};

strats.provide = mergeDataOrFn;
/**
 * Default strategy.
 */

var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */


function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
  }

  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */


function normalizeProps(options, vm) {
  var props = options.props;

  if (!props) {
    return;
  }

  var res = {};
  var i, val, name;

  if (Array.isArray(props)) {
    i = props.length;

    while (i--) {
      val = props[i];

      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = {
          type: null
        };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : {
        type: val
      };
    }
  } else if (true) {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }

  options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */


function normalizeInject(options, vm) {
  var inject = options.inject;

  if (!inject) {
    return;
  }

  var normalized = options.inject = {};

  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = {
        from: inject[i]
      };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val) ? extend({
        from: key
      }, val) : {
        from: val
      };
    }
  } else if (true) {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}
/**
 * Normalize raw function directives into object format.
 */


function normalizeDirectives(options) {
  var dirs = options.directives;

  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];

      if (typeof def$$1 === 'function') {
        dirs[key] = {
          bind: def$$1,
          update: def$$1
        };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */


function mergeOptions(parent, child, vm) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child); // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.

  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }

    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;

  for (key in parent) {
    mergeField(key);
  }

  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }

  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }

  return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */


function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }

  var assets = options[type]; // check local registration variations first

  if (hasOwn(assets, id)) {
    return assets[id];
  }

  var camelizedId = camelize(id);

  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }

  var PascalCaseId = capitalize(camelizedId);

  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  } // fallback to prototype chain


  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

  if ( true && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }

  return res;
}
/*  */


function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key]; // boolean casting

  var booleanIndex = getTypeIndex(Boolean, prop.type);

  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);

      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  } // check default value


  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
    // make sure to observe it.

    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }

  if (true) {
    assertProp(prop, key, value, vm, absent);
  }

  return value;
}
/**
 * Get the default value of a prop.
 */


function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }

  var def = prop.default; // warn against non-factory defaults for Object & Array

  if ( true && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  } // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger


  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  } // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context


  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}
/**
 * Assert whether a prop is valid.
 */


function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }

  if (value == null && !prop.required) {
    return;
  }

  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];

  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }

    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }

  var validator = prop.validator;

  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);

  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */


function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }

  return -1;
}

function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }

  message += ", got " + receivedType + " "; // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }

  return message;
}

function styleValue(value, type) {
  if (type === 'String') {
    return "\"" + value + "\"";
  } else if (type === 'Number') {
    return "" + Number(value);
  } else {
    return "" + value;
  }
}

function isExplicable(value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) {
    return value.toLowerCase() === elem;
  });
}

function isBoolean() {
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}
/*  */


function handleError(err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();

  try {
    if (vm) {
      var cur = vm;

      while (cur = cur.$parent) {
        var hooks = cur.$options.errorCaptured;

        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;

              if (capture) {
                return;
              }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }

    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;

  try {
    res = args ? handler.apply(context, args) : handler.call(context);

    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) {
        return handleError(e, vm, info + " (Promise/async)");
      }); // issue #9511
      // avoid catch triggering multiple times when nested calls

      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }

  return res;
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }

  logError(err, vm, info);
}

function logError(err, vm, info) {
  if (true) {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */


  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}
/*  */


var isUsingMicroTask = false;
var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;

  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
} // Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).


var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:

/* istanbul ignore next, $flow-disable-line */

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();

  timerFunc = function () {
    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.

    if (isIOS) {
      setTimeout(noop);
    }
  };

  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === '[object MutationObserverConstructor]')) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });

  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };

  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Techinically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick(cb, ctx) {
  var _resolve;

  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });

  if (!pending) {
    pending = true;
    timerFunc();
  } // $flow-disable-line


  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}
/*  */


var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */

  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };

    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag); // perf.clearMeasures(name)
    };
  }
}
/* not type checking this file because flow doesn't play well with Proxy */


var initProxy;

if (true) {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var warnReservedPrefix = function (target, key) {
    warn("Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals' + 'See: https://vuejs.org/v2/api/#data', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);

      if (!has && !isAllowed) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return has || !isAllowed;
    }
  };
  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
/*  */


var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */

function traverse(val) {
  _traverse(val, seenObjects);

  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);

  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }

  if (val.__ob__) {
    var depId = val.__ob__.dep.id;

    if (seen.has(depId)) {
      return;
    }

    seen.add(depId);
  }

  if (isA) {
    i = val.length;

    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;

    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}
/*  */


var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns, vm) {
  function invoker() {
    var arguments$1 = arguments;
    var fns = invoker.fns;

    if (Array.isArray(fns)) {
      var cloned = fns.slice();

      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
    }
  }

  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
  var name, def$$1, cur, old, event;

  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);

    if (isUndef(cur)) {
       true && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }

      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }

      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }

  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}
/*  */


function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }

  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
    // and prevent memory leak

    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}
/*  */


function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;

  if (isUndef(propOptions)) {
    return;
  }

  var res = {};
  var attrs = data.attrs;
  var props = data.props;

  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);

      if (true) {
        var keyInLowerCase = key.toLowerCase();

        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }

      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }

  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];

      if (!preserve) {
        delete hash[key];
      }

      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];

      if (!preserve) {
        delete hash[altKey];
      }

      return true;
    }
  }

  return false;
}
/*  */
// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.


function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }

  return children;
} // 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.


function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;

  for (i = 0; i < children.length; i++) {
    c = children[i];

    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }

    lastIndex = res.length - 1;
    last = res[lastIndex]; //  nested

    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }

        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }

        res.push(c);
      }
    }
  }

  return res;
}
/*  */


function initProvide(vm) {
  var provide = vm.$options.provide;

  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);

  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive$$1(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {}
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]; // #6574 in case the inject object is observed...

      if (key === '__ob__') {
        continue;
      }

      var provideKey = inject[key].from;
      var source = vm;

      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }

        source = source.$parent;
      }

      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else if (true) {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }

    return result;
  }
}
/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */


function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }

  var slots = {};

  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    } // named slots should only be respected if the vnode was rendered in the
    // same context.


    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);

      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  } // ignore slots that contains only whitespace


  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }

  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}
/*  */


function normalizeScopedSlots(slots, normalSlots, prevSlots) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;

  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized;
  } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots;
  } else {
    res = {};

    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  } // expose normal slots on scopedSlots


  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  } // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error


  if (slots && Object.isExtensible(slots)) {
    slots._normalized = res;
  }

  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res;
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode
    : normalizeChildren(res);
    return res && (res.length === 0 || res.length === 1 && res[0].isComment // #9658
    ) ? undefined : res;
  }; // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.


  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }

  return normalized;
}

function proxyNormalSlot(slots, key) {
  return function () {
    return slots[key];
  };
}
/*  */

/**
 * Runtime helper for rendering v-for lists.
 */


function renderList(val, render) {
  var ret, i, l, keys, key;

  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);

    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);

    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();

      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);

      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }

  if (!isDef(ret)) {
    ret = [];
  }

  ret._isVList = true;
  return ret;
}
/*  */

/**
 * Runtime helper for rendering <slot>
 */


function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;

  if (scopedSlotFn) {
    // scoped slot
    props = props || {};

    if (bindObject) {
      if ( true && !isObject(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }

      props = extend(extend({}, bindObject), props);
    }

    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;

  if (target) {
    return this.$createElement('template', {
      slot: target
    }, nodes);
  } else {
    return nodes;
  }
}
/*  */

/**
 * Runtime helper for resolving filters
 */


function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}
/*  */


function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */


function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}
/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */


function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
       true && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }

      var hash;

      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }

        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);

        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});

            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }

  return data;
}
/*  */

/**
 * Runtime helper for rendering static trees.
 */


function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.

  if (tree && !isInFor) {
    return tree;
  } // otherwise, render a fresh tree.


  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */


function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
/*  */


function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
       true && warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};

      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }

  return data;
}
/*  */


function resolveScopedSlots(fns, // see flow/vnode
res, // the following are added in 2.6
hasDynamicKeys, contentHashKey) {
  res = res || {
    $stable: !hasDynamicKeys
  };

  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];

    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }

      res[slot.key] = slot.fn;
    }
  }

  if (contentHashKey) {
    res.$key = contentHashKey;
  }

  return res;
}
/*  */


function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];

    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if ( true && key !== '' && key !== null) {
      // null is a speical value for explicitly removing a binding
      warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
    }
  }

  return baseObj;
} // helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.


function prependModifier(value, symbol) {
  return typeof value === 'string' ? symbol + value : value;
}
/*  */


function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}
/*  */


function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var this$1 = this;
  var options = Ctor.options; // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check

  var contextVm;

  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent); // $flow-disable-line

    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent; // $flow-disable-line

    parent = parent._original;
  }

  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);

  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
    }

    return this$1.$slots;
  };

  Object.defineProperty(this, 'scopedSlots', {
    enumerable: true,
    get: function get() {
      return normalizeScopedSlots(data.scopedSlots, this.slots());
    }
  }); // support for compiled functional template

  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options; // pre-resolve slots for renderSlot()

    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);

      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }

      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;

  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }

    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);

    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }

    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;

  if (true) {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }

  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }

  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
/*  */

/*  */

/*  */

/*  */
// inline hooks to be invoked on component VNodes during patch


var componentVNodeHooks = {
  init: function init(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow

      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },
  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }

    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  },
  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base; // plain options object: turn it into a constructor

  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  } // if at this stage it's not a constructor or an async component factory,
  // reject.


  if (typeof Ctor !== 'function') {
    if (true) {
      warn("Invalid Component definition: " + String(Ctor), context);
    }

    return;
  } // async component


  var asyncFactory;

  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);

    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {}; // resolve constructor options in case global mixins are applied after
  // component constructor creation

  resolveConstructorOptions(Ctor); // transform component v-model data into props & events

  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  } // extract props


  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  } // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners


  var listeners = data.on; // replace with listeners with .native modifier
  // so it gets processed during parent component patch.

  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot
    // work around flow
    var slot = data.slot;
    data = {};

    if (slot) {
      data.slot = slot;
    }
  } // install component management hooks onto the placeholder node


  installComponentHooks(data); // return a placeholder vnode

  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
    Ctor: Ctor,
    propsData: propsData,
    listeners: listeners,
    tag: tag,
    children: children
  }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }; // check inline-template render functions

  var inlineTemplate = vnode.data.inlineTemplate;

  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }

  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});

  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];

    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1(f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };

  merged._merged = true;
  return merged;
} // transform component v-model info (value and callback) into
// prop and event handler respectively.


function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;

  if (isDef(existing)) {
    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
/*  */


var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
// without getting yelled at by flow

function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }

  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }

  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
     true && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  } // object syntax in v-bind


  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }

  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  } // warn against non-primitive key


  if ( true && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  } // support single function children as default scoped slot


  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = {
      default: children[0]
    };
    children.length = 0;
  }

  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }

  var vnode, ns;

  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }

  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }

    if (isDef(data)) {
      registerDeepBindings(data);
    }

    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;

  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }

  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];

      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
} // ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes


function registerDeepBindings(data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }

  if (isObject(data.class)) {
    traverse(data.class);
  }
}
/*  */


function initRender(vm) {
  vm._vnode = null; // the root of the child tree

  vm._staticTrees = null; // v-once cached trees

  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates

  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  }; // normalization is always applied for the public version, used in
  // user-written render functions.


  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  }; // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated


  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */

  if (true) {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {}
}

var currentRenderingInstance = null;

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
    } // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.


    vm.$vnode = _parentVnode; // render self

    var vnode;

    try {
      // There's no need to maintain a stack becaues all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render"); // return error render result,
      // or previous vnode to prevent render error causing blank component

      /* istanbul ignore else */

      if ( true && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    } // if the returned array contains only a single node, allow it


    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    } // return empty vnode in case the render function errored out


    if (!(vnode instanceof VNode)) {
      if ( true && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }

      vnode = createEmptyVNode();
    } // set parent


    vnode.parent = _parentVnode;
    return vnode;
  };
}
/*  */


function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }

  return isObject(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = {
    data: data,
    context: context,
    children: children,
    tag: tag
  };
  return node;
}

function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  var owner = currentRenderingInstance;

  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null;
    owner.$on('hook:destroyed', function () {
      return remove(owners, owner);
    });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;

        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }

        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)

      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });
    var reject = once(function (reason) {
       true && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });
    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);

          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;

              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;

            if (isUndef(factory.resolved)) {
              reject( true ? "timeout (" + res.timeout + "ms)" : undefined);
            }
          }, res.timeout);
        }
      }
    }

    sync = false; // return in case resolved synchronously

    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
/*  */


function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
/*  */


function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];

      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
/*  */

/*  */


function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false; // init parent attached events

  var listeners = vm.$options._parentListeners;

  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn) {
  target.$on(event, fn);
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function createOnceHandler(event, fn) {
  var _target = target;
  return function onceHandler() {
    var res = fn.apply(null, arguments);

    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;

  Vue.prototype.$on = function (event, fn) {
    var vm = this;

    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup

      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }

    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;

    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }

    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this; // all

    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    } // array of events


    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }

      return vm;
    } // specific event


    var cbs = vm._events[event];

    if (!cbs) {
      return vm;
    }

    if (!fn) {
      vm._events[event] = null;
      return vm;
    } // specific handler


    var cb;
    var i = cbs.length;

    while (i--) {
      cb = cbs[i];

      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }

    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;

    if (true) {
      var lowerCaseEvent = event.toLowerCase();

      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }

    var cbs = vm._events[event];

    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";

      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }

    return vm;
  };
}
/*  */


var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  };
}

function initLifecycle(vm) {
  var options = vm.$options; // locate first non-abstract parent

  var parent = options.parent;

  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }

    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.

    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
      /* removeOnly */
      );
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }

    restoreActiveInstance(); // update __vue__ reference

    if (prevEl) {
      prevEl.__vue__ = null;
    }

    if (vm.$el) {
      vm.$el.__vue__ = vm;
    } // if parent is an HOC, update its $el as well


    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    } // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.

  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;

    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;

    if (vm._isBeingDestroyed) {
      return;
    }

    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true; // remove self from parent

    var parent = vm.$parent;

    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    } // teardown watchers


    if (vm._watcher) {
      vm._watcher.teardown();
    }

    var i = vm._watchers.length;

    while (i--) {
      vm._watchers[i].teardown();
    } // remove reference from data ob
    // frozen object may not have observer.


    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    } // call the last hook...


    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

    vm.__patch__(vm._vnode, null); // fire destroyed hook


    callHook(vm, 'destroyed'); // turn off all instance listeners.

    vm.$off(); // remove __vue__ reference

    if (vm.$el) {
      vm.$el.__vue__ = null;
    } // release circular reference (#6759)


    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;

  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;

    if (true) {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }

  callHook(vm, 'beforeMount');
  var updateComponent;
  /* istanbul ignore if */

  if ( true && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;
      mark(startTag);

      var vnode = vm._render();

      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);
      mark(startTag);

      vm._update(vnode, hydrating);

      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  } // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined


  new Watcher(vm, updateComponent, noop, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true
  /* isRenderWatcher */
  );
  hydrating = false; // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook

  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }

  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (true) {
    isUpdatingChildComponent = true;
  } // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.
  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.


  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key); // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.

  var needsForceUpdate = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  hasDynamicScopedSlot);
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }

  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render

  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject; // update props

  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];

    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?

      props[key] = validateProp(key, propOptions, propsData, vm);
    }

    toggleObserving(true); // keep a copy of raw propsData

    vm.$options.propsData = propsData;
  } // update listeners


  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }

  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;

    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }

  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;

    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;

    if (isInInactiveTree(vm)) {
      return;
    }
  }

  if (!vm._inactive) {
    vm._inactive = true;

    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";

  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }

  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  popTarget();
}
/*  */


var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
/**
 * Reset the scheduler's state.
 */

function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};

  if (true) {
    circular = {};
  }

  waiting = flushing = false;
} // Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.


var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.

var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)

if (inBrowser && !isIE) {
  var performance = window.performance;

  if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () {
      return performance.now();
    };
  }
}
/**
 * Flush both queues and run the watchers.
 */


function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id; // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.

  queue.sort(function (a, b) {
    return a.id - b.id;
  }); // do not cache length because more watchers might be pushed
  // as we run existing watchers

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];

    if (watcher.before) {
      watcher.before();
    }

    id = watcher.id;
    has[id] = null;
    watcher.run(); // in dev build, check and stop circular updates.

    if ( true && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;

      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  } // keep copies of post queues before resetting state


  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState(); // call component updated and activated hooks

  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue); // devtool hook

  /* istanbul ignore if */

  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;

  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;

    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */


function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true
    /* true */
    );
  }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */


function queueWatcher(watcher) {
  var id = watcher.id;

  if (has[id] == null) {
    has[id] = true;

    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;

      while (i > index && queue[i].id > watcher.id) {
        i--;
      }

      queue.splice(i + 1, 0, watcher);
    } // queue the flush


    if (!waiting) {
      waiting = true;

      if ( true && !config.async) {
        flushSchedulerQueue();
        return;
      }

      nextTick(flushSchedulerQueue);
    }
  }
}
/*  */


var uid$2 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */

var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;

  if (isRenderWatcher) {
    vm._watcher = this;
  }

  vm._watchers.push(this); // options


  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }

  this.cb = cb;
  this.id = ++uid$2; // uid for batching

  this.active = true;
  this.dirty = this.lazy; // for lazy watchers

  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true ? expOrFn.toString() : undefined; // parse expression for getter

  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);

    if (!this.getter) {
      this.getter = noop;
       true && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }

  this.value = this.lazy ? undefined : this.get();
};
/**
 * Evaluate the getter, and re-collect dependencies.
 */


Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;

  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }

    popTarget();
    this.cleanupDeps();
  }

  return value;
};
/**
 * Add a dependency to this directive.
 */


Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;

  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);

    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};
/**
 * Clean up for dependency collection.
 */


Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var i = this.deps.length;

  while (i--) {
    var dep = this.deps[i];

    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }

  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};
/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */


Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */


Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();

    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;

      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};
/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */


Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};
/**
 * Depend on all deps collected by this watcher.
 */


Watcher.prototype.depend = function depend() {
  var i = this.deps.length;

  while (i--) {
    this.deps[i].depend();
  }
};
/**
 * Remove self from all dependencies' subscriber list.
 */


Watcher.prototype.teardown = function teardown() {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }

    var i = this.deps.length;

    while (i--) {
      this.deps[i].removeSub(this);
    }

    this.active = false;
  }
};
/*  */


var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };

  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;

  if (opts.props) {
    initProps(vm, opts.props);
  }

  if (opts.methods) {
    initMethods(vm, opts.methods);
  }

  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true
    /* asRootData */
    );
  }

  if (opts.computed) {
    initComputed(vm, opts.computed);
  }

  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.

  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent; // root instance props should be converted

  if (!isRoot) {
    toggleObserving(false);
  }

  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */

    if (true) {
      var hyphenatedKey = hyphenate(key);

      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }

      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {} // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.


    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);

  toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

  if (!isPlainObject(data)) {
    data = {};
     true && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  } // proxy data on instance


  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;

  while (i--) {
    var key = keys[i];

    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }

    if (props && hasOwn(props, key)) {
       true && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  } // observe data


  observe(data, true
  /* asRootData */
  );
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();

  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = {
  lazy: true
};

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;

    if ( true && getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    } // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.


    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();

  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }

  if ( true && sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];

    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }

      if (Dep.target) {
        watcher.depend();
      }

      return watcher.value;
    }
  };
}

function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;

  for (var key in methods) {
    if (true) {
      if (typeof methods[key] !== 'function') {
        warn("Method \"" + key + "\" has type \"" + typeof methods[key] + "\" in the component definition. " + "Did you reference the function correctly?", vm);
      }

      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }

      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }

    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];

    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }

  if (typeof handler === 'string') {
    handler = vm[handler];
  }

  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};

  dataDef.get = function () {
    return this._data;
  };

  var propsDef = {};

  propsDef.get = function () {
    return this._props;
  };

  if (true) {
    dataDef.set = function () {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };

    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }

  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);
  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;

    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }

    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);

    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, "callback for immediate watcher \"" + watcher.expression + "\"");
      }
    }

    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
/*  */


var uid$3 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this; // a uid

    vm._uid = uid$3++;
    var startTag, endTag;
    /* istanbul ignore if */

    if ( true && config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    } // a flag to avoid this being observed


    vm._isVue = true; // merge options

    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */


    if (true) {
      initProxy(vm);
    } else {} // expose real self


    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props

    initState(vm);
    initProvide(vm); // resolve provide after data/props

    callHook(vm, 'created');
    /* istanbul ignore if */

    if ( true && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;

  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;

    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }

  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;

  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }

      modified[key] = latest[key];
    }
  }

  return modified;
}

function Vue(options) {
  if ( true && !(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }

  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    } // additional parameters


    var args = toArray(arguments, 1);
    args.unshift(this);

    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }

    installedPlugins.push(plugin);
    return this;
  };
}
/*  */


function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
/*  */


function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;
  /**
   * Class inheritance
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;

    if ( true && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };

    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.

    if (Sub.options.props) {
      initProps$1(Sub);
    }

    if (Sub.options.computed) {
      initComputed$1(Sub);
    } // allow further extension/mixin/plugin usage


    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use; // create asset registers, so extended classes
    // can have their private assets too.

    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    }); // enable recursive self-lookup

    if (name) {
      Sub.options.components[name] = Sub;
    } // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.


    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options); // cache constructor

    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;

  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;

  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}
/*  */


function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if ( true && type === 'component') {
          validateComponentName(id);
        }

        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }

        if (type === 'directive' && typeof definition === 'function') {
          definition = {
            bind: definition,
            update: definition
          };
        }

        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}
/*  */


function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;

  for (var key in cache) {
    var cachedNode = cache[key];

    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);

      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];

  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }

  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: 'keep-alive',
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },
  destroyed: function destroyed() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },
  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;

    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;

      if ( // not included
      include && (!name || !matches(include, name)) || // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance; // make current key freshest

        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key); // prune oldest entry

        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }

    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive: KeepAlive
};
/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};

  configDef.get = function () {
    return config;
  };

  if (true) {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }

  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.

  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };
  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick; // 2.6 explicit observable API

  Vue.observable = function (obj) {
    observe(obj);
    return obj;
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  }); // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.

  Vue.options._base = Vue;
  extend(Vue.options.components, builtInComponents);
  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
}); // expose FunctionalRenderContext for ssr runtime helper installation

Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});
Vue.version = '2.6.10';
/*  */
// these are reserved for web because they are directly compiled away
// during template compilation

var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

var acceptValue = makeMap('input,textarea,option,select,progress');

var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable
  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
};

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};
/*  */


function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;

  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;

    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }

  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }

  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */


  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }

  if (isObject(value)) {
    return stringifyObject(value);
  }

  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */


  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;

  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }

      res += stringified;
    }
  }

  return res;
}

function stringifyObject(value) {
  var res = '';

  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }

      res += key;
    }
  }

  return res;
}
/*  */


var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
// contain child elements.

var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function (tag) {
  return tag === 'pre';
};

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  } // basic support for MathML
  // note it doesn't support other MathML elements being component roots


  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);

function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }

  if (isReservedTag(tag)) {
    return false;
  }

  tag = tag.toLowerCase();
  /* istanbul ignore if */

  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }

  var el = document.createElement(tag);

  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');
/*  */

/**
 * Query an element selector if it's not an element already.
 */

function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);

    if (!selected) {
       true && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }

    return selected;
  } else {
    return el;
  }
}
/*  */


function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);

  if (tagName !== 'select') {
    return elm;
  } // false or null will remove the attribute but undefined will not


  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }

  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps =
/*#__PURE__*/
Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});
/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;

  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;

  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */


var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }

  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};

  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;

    if (isDef(key)) {
      map[key] = i;
    }
  }

  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];

    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }

    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check

    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;

    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }

        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }

      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);
      /* istanbul ignore if */

      {
        createChildren(vnode, children, insertedVnodeQueue);

        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }

        insert(parentElm, vnode.elm, refElm);
      }

      if ( true && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;

    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false
        /* hydrating */
        );
      } // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.


      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);

        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }

        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }

    vnode.elm = vnode.componentInstance.$el;

    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode); // make sure to invoke the insert hook

      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i; // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.

    var innerNode = vnode;

    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;

      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }

        insertedVnodeQueue.push(innerNode);
        break;
      }
    } // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself


    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (true) {
        checkDuplicateKeys(children);
      }

      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }

    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }

    i = vnode.data.hook; // Reuse variable

    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }

      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  } // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.


  function setScope(vnode) {
    var i;

    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;

      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }

        ancestor = ancestor.parent;
      }
    } // for slot content they should also get the scopeId from the host instance.


    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }

      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }

    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];

      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;

      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } // recursively invoke hooks on child component root node


      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }

      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }

      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions

    var canMove = !removeOnly;

    if (true) {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }

        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];

          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }

        newStartVnode = newCh[++newStartIdx];
      }
    }

    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};

    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;

      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];

      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }

      return;
    } // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.


    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;

    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;

    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }

      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }

    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (true) {
          checkDuplicateKeys(ch);
        }

        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }

        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).

  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    } // assert node match


    if (true) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true
        /* hydrating */
        );
      }

      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }

    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ( true && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }

              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;

            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }

              childNode = childNode.nextSibling;
            } // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.


            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ( true && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }

              return false;
            }
          }
        }
      }

      if (isDef(data)) {
        var fullInvoke = false;

        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }

        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }

    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }

      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);

      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }

          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (true) {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          } // either not server-rendered, or hydration failed.
          // create an empty node and replace it


          oldVnode = emptyNodeAt(oldVnode);
        } // replacing existing element


        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm); // create new node

        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);

          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }

            ancestor.elm = vnode.elm;

            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              } // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.


              var insert = ancestor.data.hook.insert;

              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }

            ancestor = ancestor.parent;
          }
        } // destroy old node


        if (isDef(parentElm)) {
          removeVnodes(parentElm, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
/*  */


var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;

  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];

    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);

      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);

      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };

    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);

  if (!dirs) {
    // $flow-disable-line
    return res;
  }

  var i, dir;

  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];

    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }

    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  } // $flow-disable-line


  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];

  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];
/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;

  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }

  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }

  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];

    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  } // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max

  /* istanbul ignore if */


  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }

  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.

    /* istanbul ignore if */
    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };

      el.addEventListener('input', blocker); // $flow-disable-line

      el.__ieph = true;
      /* IE placeholder patched */
    }

    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode); // handle transition classes

  var transitionClass = el._transitionClasses;

  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  } // set the class


  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};
/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);

    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;
          break;
        // "

        case 0x27:
          inSingle = true;
          break;
        // '

        case 0x60:
          inTemplateString = true;
          break;
        // `

        case 0x28:
          paren++;
          break;
        // (

        case 0x29:
          paren--;
          break;
        // )

        case 0x5B:
          square++;
          break;
        // [

        case 0x5D:
          square--;
          break;
        // ]

        case 0x7B:
          curly++;
          break;
        // {

        case 0x7D:
          curly--;
          break;
        // }
      }

      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0; // find first non-whitespace prev char

        for (; j >= 0; j--) {
          p = exp.charAt(j);

          if (p !== ' ') {
            break;
          }
        }

        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');

  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
  }
}
/*  */

/* eslint-disable no-unused-vars */


function baseWarn(msg, range) {
  console.error("[Vue compiler]: " + msg);
}
/* eslint-enable no-unused-vars */


function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
}

function addAttr(el, name, value, range, dynamic) {
  var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);
  attrs.push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
} // add a raw attr (use this in preTransforms)


function addRawAttr(el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({
    name: name,
    value: value
  }, range));
}

function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker(symbol, name, dynamic) {
  return dynamic ? "_p(" + name + ",\"" + symbol + "\")" : symbol + name; // mark the event as captured
}

function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
  modifiers = modifiers || emptyObject; // warn prevent and passive modifier

  /* istanbul ignore if */

  if ( true && warn && modifiers.prevent && modifiers.passive) {
    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.', range);
  } // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.


  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  } // check capture modifier


  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }

  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */


  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;

  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({
    value: value.trim(),
    dynamic: dynamic
  }, range);

  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */

  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr(el, name) {
  return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);

  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);

    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
} // note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.


function getAndRemoveAttr(el, name, removeFromMap) {
  var val;

  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;

    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }

  if (removeFromMap) {
    delete el.attrsMap[name];
  }

  return val;
}

function getAndRemoveAttrByRegex(el, name) {
  var list = el.attrsList;

  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];

    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr;
    }
  }
}

function rangeSetItem(item, range) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }

    if (range.end != null) {
      item.end = range.end;
    }
  }

  return item;
}
/*  */

/**
 * Cross-platform code generation for component v-model
 */


function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;
  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;

  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var assignment = genAssignmentCode(value, valueExpression);
  el.model = {
    value: "(" + value + ")",
    expression: JSON.stringify(value),
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}
/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */


function genAssignmentCode(value, assignment) {
  var res = parseModel(value);

  if (res.key === null) {
    return value + "=" + assignment;
  } else {
    return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
  }
}
/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */


var len, str, chr, index$1, expressionPos, expressionEndPos;

function parseModel(val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');

    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      };
    } else {
      return {
        exp: val,
        key: null
      };
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */

    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;

  while (!eof()) {
    chr = next();

    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }

    if (chr === 0x5B) {
      inBracket++;
    }

    if (chr === 0x5D) {
      inBracket--;
    }

    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;

  while (!eof()) {
    chr = next();

    if (chr === stringQuote) {
      break;
    }
  }
}
/*  */


var warn$1; // in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.

var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (true) {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.", el.rawAttrsMap['v-model']);
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else if (true) {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);
  } // ensure runtime directive metadata


  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + genAssignmentCode(value, '$$a.concat([$$v])') + ")}" + "else{$$i>-1&&(" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ")}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";
  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type

  if (true) {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];

    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);
    }
  }

  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
  var valueExpression = '$event.target.value';

  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);

  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);

  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}
/*  */
// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.


function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  } // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4

  /* istanbul ignore if */


  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1(event, handler, capture) {
  var _target = target$1; // save current target element in closure

  return function onceHandler() {
    var res = handler.apply(null, arguments);

    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.


var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1(name, handler, capture, passive) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;

    handler = original._wrapper = function (e) {
      if ( // no bubbling, should always fire.
      // this is just a safety net in case event.timeStamp is unreliable in
      // certain weird environments...
      e.target === e.currentTarget || // event is fired after handler attachment
      e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations
      // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
      // #9681 QtWebEngine event.timeStamp is negative value
      e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page
      // electron/nw.js app, since event.timeStamp will be using a different
      // starting reference
      e.target.ownerDocument !== document) {
        return original.apply(this, arguments);
      }
    };
  }

  target$1.addEventListener(name, handler, supportsPassive ? {
    capture: capture,
    passive: passive
  } : capture);
}

function remove$2(name, handler, capture, _target) {
  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }

  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};
/*  */

var svgContainer;

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }

  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key]; // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)

    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }

      if (cur === oldProps[key]) {
        continue;
      } // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property


      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur; // avoid resetting cursor position when value is the same

      var strCur = isUndef(cur) ? '' : String(cur);

      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;

      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }

      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if ( // skip the update if old and new VDOM state is the same.
    // `value` is handled separately because the DOM value may be temporarily
    // out of sync with VDOM state due to focus, composition and modifiers.
    // This  #4521 by skipping the unnecesarry `checked` update.
    cur !== oldProps[key]) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
} // check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true; // #6157
  // work around IE bug when accessing document.activeElement in an iframe

  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}

  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime

  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }

    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }

  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};
/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
}); // merge static and dynamic style data on the same vnode

function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it

  return data.staticStyle ? extend(data.staticStyle, style) : style;
} // normalize possible array / string values into Object


function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }

  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }

  return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */


function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;

    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;

      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;

  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }

  return res;
}
/*  */


var cssVarRE = /^--/;
var importantRE = /\s*!important$/;

var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);

    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);

  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }

  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;

    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.

  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }

  for (name in newStyle) {
    cur = newStyle[name];

    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};
/*  */

var whitespaceRE = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */

function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";

    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */


function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }

    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';

    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }

    cur = cur.trim();

    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}
/*  */


function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */


  if (typeof def$$1 === 'object') {
    var res = {};

    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }

    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation'; // Transition property/event sniffing

var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';

if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }

  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
} // binding to window is necessary to make hot reload work in IE in strict mode


var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
/* istanbul ignore next */
function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }

  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;

  if (!type) {
    return cb();
  }

  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;

  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };

  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
/*  */


function enter(vnode, toggleDisplay) {
  var el = vnode.elm; // call leave callback now

  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;

    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data)) {
    return;
  }
  /* istanbul ignore if */


  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration; // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.

  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;

  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if ( true && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }

      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }

    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];

      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }

      enterHook && enterHook(el, cb);
    });
  } // start enter transition


  beforeEnterHook && beforeEnterHook(el);

  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);

      if (!cb.cancelled) {
        addTransitionClass(el, toClass);

        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm; // call enter callback now

  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;

    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  /* istanbul ignore if */


  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);
  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if ( true && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }

    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }

      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }

    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    } // record leaving element


    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }

    beforeLeave && beforeLeave(el);

    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);

        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);

          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    leave && leave(el, cb);

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
} // only used in dev mode


function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */


function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }

  var invokerFns = fn.fns;

  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [attrs, klass, events, domProps, style, transition];
/*  */
// the directive module should be applied last, after all
// built-in modules have been applied.

var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({
  nodeOps: nodeOps,
  modules: modules
});
/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */

if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;

    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }

      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;

      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.

        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */

        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.

      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);

      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */

  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;

  if (isMultiple && !Array.isArray(value)) {
     true && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }

  var selected, option;

  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];

    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;

      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }

        return;
      }
    }
  }

  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }

  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
/*  */
// recursively search for possible transition defined inside the component root


function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },
  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;
    /* istanbul ignore if */

    if (!value === !oldValue) {
      return;
    }

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;

    if (transition$$1) {
      vnode.data.show = true;

      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },
  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show: show
};
/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
}; // in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered

function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;

  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options; // props

  for (var key in options.propsData) {
    data[key] = comp[key];
  } // events.
  // extract listeners and pass them directly to the transition methods


  var listeners = options._parentListeners;

  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }

  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var isNotTextNode = function (c) {
  return c.tag || isAsyncPlaceholder(c);
};

var isVShowDirective = function (d) {
  return d.name === 'show';
};

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      return;
    } // filter out text nodes (possible whitespaces)


    children = children.filter(isNotTextNode);
    /* istanbul ignore if */

    if (!children.length) {
      return;
    } // warn multiple elements


    if ( true && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode; // warn invalid mode

    if ( true && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0]; // if this is a component root node and the component's
    // parent container node also has transition, skip.

    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    } // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive


    var child = getRealChild(rawChild);
    /* istanbul ignore if */

    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    } // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.


    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild); // mark v-show
    // so that the transition module can hand over the control to the directive

    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }

        var delayedLeave;

        var performLeave = function () {
          delayedLeave();
        };

        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};
/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props: props,
  beforeMount: function beforeMount() {
    var this$1 = this;
    var update = this._update;

    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass

      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );

      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },
  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];

      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];

      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();

        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }

      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },
  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';

    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    } // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.


    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation); // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line

    this._reflow = document.body.offsetHeight;
    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */


      if (this._hasMove) {
        return this._hasMove;
      } // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.


      var clone = el.cloneNode();

      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }

      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */


  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};
/*  */
// install platform specific utils

Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents); // install platform patch function

Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method

Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
}; // devtools global hook

/* istanbul ignore next */


if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (true) {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }

    if ( true && config.productionTip !== false && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}
/*  */


var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;

  if (!tagRE.test(text)) {
    return;
  }

  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;

  while (match = tagRE.exec(text)) {
    index = match.index; // push text token

    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    } // tag token


    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    rawTokens.push({
      '@binding': exp
    });
    lastIndex = index + match[0].length;
  }

  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }

  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  };
}
/*  */


function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');

  if ( true && staticClass) {
    var res = parseText(staticClass, options.delimiters);

    if (res) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap['class']);
    }
  }

  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }

  var classBinding = getBindingAttr(el, 'class', false
  /* getStatic */
  );

  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData(el) {
  var data = '';

  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }

  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }

  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};
/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');

  if (staticStyle) {
    /* istanbul ignore if */
    if (true) {
      var res = parseText(staticStyle, options.delimiters);

      if (res) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap['style']);
      }
    }

    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false
  /* getStatic */
  );

  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1(el) {
  var data = '';

  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }

  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }

  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};
/*  */

var decoder;
var he = {
  decode: function decode(html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent;
  }
};
/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open
// (and which close themselves)

var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content

var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');
/**
 * Not type-checking this file because it's mostly vendor code.
 */
// Regular Expressions for parsing tags and attributes

var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeRegExp.source + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp("^<" + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being pased as HTML comment when inlined in page

var comment = /^<!\--/;
var conditionalComment = /^<!\[/; // Special Elements (can contain anything)

var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};
var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992

var isIgnoreNewlineTag = makeMap('pre,textarea', true);

var shouldIgnoreFirstNewline = function (tag, html) {
  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
};

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;

  while (html) {
    last = html; // Make sure we're not in a plaintext content element like script/style

    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');

      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }

            advance(commentEnd + 3);
            continue;
          }
        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment


        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        } // Doctype:


        var doctypeMatch = html.match(doctype);

        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        } // End tag:


        var endTagMatch = html.match(endTag);

        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        } // Start tag:


        var startTagMatch = parseStartTag();

        if (startTagMatch) {
          handleStartTag(startTagMatch);

          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }

          continue;
        }
      }

      var text = void 0,
          rest = void 0,
          next = void 0;

      if (textEnd >= 0) {
        rest = html.slice(textEnd);

        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);

          if (next < 0) {
            break;
          }

          textEnd += next;
          rest = html.slice(textEnd);
        }

        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;

        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
          .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }

        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }

        if (options.chars) {
          options.chars(text);
        }

        return '';
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);

      if ( true && !stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"", {
          start: index + html.length
        });
      }

      break;
    }
  } // Clean up any remaining tags


  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);

    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;

      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }

      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }

      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;
    var l = match.attrs.length;
    var attrs = new Array(l);

    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };

      if ( true && options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length;
        attrs[i].end = args.end;
      }
    }

    if (!unary) {
      stack.push({
        tag: tagName,
        lowerCasedTag: tagName.toLowerCase(),
        attrs: attrs,
        start: match.start,
        end: match.end
      });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;

    if (start == null) {
      start = index;
    }

    if (end == null) {
      end = index;
    } // Find the closest opened tag of the same type


    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();

      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if ( true && (i > pos || !tagName) && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.", {
            start: stack[i].start,
            end: stack[i].end
          });
        }

        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      } // Remove the open elements from the stack


      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }

      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}
/*  */


var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;
var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;
var slotRE = /^v-slot(:|$)|^#/;
var lineBreakRE = /[\r\n]/;
var whitespaceRE$1 = /\s+/g;
var invalidAttributeRE = /[\s"'<>\/=]/;
var decodeHTMLCached = cached(he.decode);
var emptySlotScopeToken = "_empty_"; // configurable state

var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement(tag, attrs, parent) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  };
}
/**
 * Convert HTML string to AST.
 */


function parse(template, options) {
  warn$2 = options.warn || baseWarn;
  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;

  maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
  delimiters = options.delimiters;
  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg, range) {
    if (!warned) {
      warned = true;
      warn$2(msg, range);
    }
  }

  function closeElement(element) {
    trimEndingWhitespace(element);

    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    } // tree management


    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        if (true) {
          checkRootConstraints(element);
        }

        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else if (true) {
        warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.", {
          start: element.start
        });
      }
    }

    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"';
          (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }

        currentParent.children.push(element);
        element.parent = currentParent;
      }
    } // final children cleanup
    // filter out scoped slots


    element.children = element.children.filter(function (c) {
      return !c.slotScope;
    }); // remove trailing whitespace node again

    trimEndingWhitespace(element); // check pre state

    if (element.pre) {
      inVPre = false;
    }

    if (platformIsPreTag(element.tag)) {
      inPre = false;
    } // apply post-transforms


    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace(el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;

      while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints(el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.', {
        start: el.start
      });
    }

    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start(tag, attrs, unary, start$1, end) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug

      /* istanbul ignore if */

      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);

      if (ns) {
        element.ns = ns;
      }

      if (true) {
        if (options.outputSourceRange) {
          element.start = start$1;
          element.end = end;
          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated;
          }, {});
        }

        attrs.forEach(function (attr) {
          if (invalidAttributeRE.test(attr.name)) {
            warn$2("Invalid dynamic argument expression: attribute names cannot contain " + "spaces, quotes, <, >, / or =.", {
              start: attr.start + attr.name.indexOf("["),
              end: attr.start + attr.name.length
            });
          }
        });
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
         true && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.', {
          start: element.start
        });
      } // apply pre-transforms


      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);

        if (element.pre) {
          inVPre = true;
        }
      }

      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }

      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;

        if (true) {
          checkRootConstraints(root);
        }
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },
    end: function end(tag, start, end$1) {
      var element = stack[stack.length - 1]; // pop stack

      stack.length -= 1;
      currentParent = stack[stack.length - 1];

      if ( true && options.outputSourceRange) {
        element.end = end$1;
      }

      closeElement(element);
    },
    chars: function chars(text, start, end) {
      if (!currentParent) {
        if (true) {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.', {
              start: start
            });
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.", {
              start: start
            });
          }
        }

        return;
      } // IE textarea placeholder bug

      /* istanbul ignore if */


      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }

      var children = currentParent.children;

      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }

      if (text) {
        if (!inPre && whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE$1, ' ');
        }

        var res;
        var child;

        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }

        if (child) {
          if ( true && options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }

          children.push(child);
        }
      }
    },
    comment: function comment(text, start, end) {
      // adding anyting as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };

        if ( true && options.outputSourceRange) {
          child.start = start;
          child.end = end;
        }

        currentParent.children.push(child);
      }
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var list = el.attrsList;
  var len = list.length;

  if (len) {
    var attrs = el.attrs = new Array(len);

    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };

      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement(element, options) {
  processKey(element); // determine whether this is a plain element after
  // removing structural attributes

  element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;
  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);

  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }

  processAttrs(element);
  return element;
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');

  if (exp) {
    if (true) {
      if (el.tag === 'template') {
        warn$2("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, 'key'));
      }

      if (el.for) {
        var iterator = el.iterator2 || el.iterator1;
        var parent = el.parent;

        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
          warn$2("Do not use v-for index as key on <transition-group> children, " + "this is the same as not using keys.", getRawBindingAttr(el, 'key'), true
          /* tip */
          );
        }
      }
    }

    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');

  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;

  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var res = parseFor(exp);

    if (res) {
      extend(el, res);
    } else if (true) {
      warn$2("Invalid v-for expression: " + exp, el.rawAttrsMap['v-for']);
    }
  }
}

function parseFor(exp) {
  var inMatch = exp.match(forAliasRE);

  if (!inMatch) {
    return;
  }

  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);

  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();

    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }

  return res;
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');

  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }

    var elseif = getAndRemoveAttr(el, 'v-else-if');

    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);

  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (true) {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);
  }
}

function findPrevElement(children) {
  var i = children.length;

  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if ( true && children[i].text !== ' ') {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.", children[i]);
      }

      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }

  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');

  if (once$$1 != null) {
    el.once = true;
  }
} // handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">


function processSlotContent(el) {
  var slotScope;

  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */

    if ( true && slotScope) {
      warn$2("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", el.rawAttrsMap['scope'], true);
    }

    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
    /* istanbul ignore if */
    if ( true && el.attrsMap['v-for']) {
      warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", el.rawAttrsMap['slot-scope'], true);
    }

    el.slotScope = slotScope;
  } // slot="xxx"


  var slotTarget = getBindingAttr(el, 'slot');

  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.

    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  } // 2.6 v-slot syntax


  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding) {
        if (true) {
          if (el.slotTarget || el.slotScope) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.parent && !maybeComponent(el.parent)) {
            warn$2("<template v-slot> can only appear at the root level inside " + "the receiving the component", el);
          }
        }

        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding$1) {
        if (true) {
          if (!maybeComponent(el)) {
            warn$2("v-slot can only be used on components or <template>.", slotBinding$1);
          }

          if (el.slotScope || el.slotTarget) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.scopedSlots) {
            warn$2("To avoid scope ambiguity, the default slot should also use " + "<template> syntax when there are other named slots.", slotBinding$1);
          }
        } // add the component's children to its default slot


        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true;
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now

        el.children = []; // mark el non-plain so data gets generated

        el.plain = false;
      }
    }
  }
}

function getSlotName(binding) {
  var name = binding.name.replace(slotRE, '');

  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else if (true) {
      warn$2("v-slot shorthand syntax requires a slot name.", binding);
    }
  }

  return dynamicArgRE.test(name) // dynamic [name]
  ? {
    name: name.slice(1, -1),
    dynamic: true // static name

  } : {
    name: "\"" + name + "\"",
    dynamic: false
  };
} // handle <slot/> outlets


function processSlotOutlet(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');

    if ( true && el.key) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.", getRawBindingAttr(el, 'key'));
    }
  }
}

function processComponent(el) {
  var binding;

  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }

  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;

  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;

    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true; // modifiers

      modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier

      if (modifiers) {
        name = name.replace(modifierRE, '');
      }

      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        if ( true && value.trim().length === 0) {
          warn$2("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"");
        }

        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);

            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }

          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }

          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");

            if (!isDynamic) {
              addHandler(el, "update:" + camelize(name), syncGen, null, false, warn$2, list[i]);

              if (hyphenate(name) !== camelize(name)) {
                addHandler(el, "update:" + hyphenate(name), syncGen, null, false, warn$2, list[i]);
              }
            } else {
              // handler w/ dynamic event name
              addHandler(el, "\"update:\"+(" + name + ")", syncGen, null, false, warn$2, list[i], true // dynamic
              );
            }
          }
        }

        if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
      } else {
        // normal directives
        name = name.replace(dirRE, ''); // parse arg

        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;

        if (arg) {
          name = name.slice(0, -(arg.length + 1));

          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }

        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);

        if ( true && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (true) {
        var res = parseText(value, delimiters);

        if (res) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
        }
      }

      addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation

      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor(el) {
  var parent = el;

  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }

    parent = parent.parent;
  }

  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);

  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};

  for (var i = 0, l = attrs.length; i < l; i++) {
    if ( true && map[attrs[i].name] && !isIE && !isEdge) {
      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
    }

    map[attrs[i].name] = attrs[i].value;
  }

  return map;
} // for script (e.g. type="x/template") or style, do not decode content


function isTextTag(el) {
  return el.tag === 'script' || el.tag === 'style';
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;
/* istanbul ignore next */

function guardIESVGBug(attrs) {
  var res = [];

  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];

    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }

  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;

  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap['v-model']);
    }

    _el = _el.parent;
  }
}
/*  */


function preTransformNode(el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;

    if (!map['v-model']) {
      return;
    }

    var typeBinding;

    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }

    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + map['v-bind'] + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox

      var branch0 = cloneASTElement(el); // process for on the main node

      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed

      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      }); // 2. add radio else-if condition

      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      }); // 3. other

      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0;
    }
  }
}

function cloneASTElement(el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent);
}

var model$1 = {
  preTransformNode: preTransformNode
};
var modules$1 = [klass$1, style$1, model$1];
/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")", dir);
  }
}
/*  */


function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")", dir);
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};
/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};
/*  */

var isStaticKey;
var isPlatformReservedTag;
var genStaticKeysCached = cached(genStaticKeys$1);
/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */

function optimize(root, options) {
  if (!root) {
    return;
  }

  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.

  markStatic$1(root); // second pass: mark static roots.

  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);

  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }

    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);

      if (!child.static) {
        node.static = false;
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);

        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    } // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.


    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }

    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }

  if (node.type === 3) {
    // text
    return true;
  }

  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;

    if (node.tag !== 'template') {
      return false;
    }

    if (node.for) {
      return true;
    }
  }

  return false;
}
/*  */


var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*(?:[\w$]+)?\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; // KeyboardEvent.keyCode aliases

var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
}; // KeyboardEvent.key aliases

var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
}; // #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once

var genGuard = function (condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, isNative) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";

  for (var name in events) {
    var handlerCode = genHandler(events[name]);

    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }

  staticHandlers = "{" + staticHandlers.slice(0, -1) + "}";

  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + dynamicHandlers.slice(0, -1) + "])";
  } else {
    return prefix + staticHandlers;
  }
}

function genHandler(handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value;
    }

    return "function($event){" + (isFunctionInvocation ? "return " + handler.value : handler.value) + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];

    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key]; // left/right

        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = handler.modifiers;
        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
          return !modifiers[keyModifier];
        }).map(function (keyModifier) {
          return "$event." + keyModifier + "Key";
        }).join('||'));
      } else {
        keys.push(key);
      }
    }

    if (keys.length) {
      code += genKeyFilter(keys);
    } // Make sure modifiers like prevent and stop get executed after key filtering


    if (genModifierCode) {
      code += genModifierCode;
    }

    var handlerCode = isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : isFunctionInvocation ? "return " + handler.value : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return (// make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join('&&') + ")return null;"
  );
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);

  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }

  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
}
/*  */


function on(el, dir) {
  if ( true && dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }

  el.wrapListeners = function (code) {
    return "_g(" + code + "," + dir.value + ")";
  };
}
/*  */


function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
  };
}
/*  */


var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};
/*  */

var CodegenState = function CodegenState(options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;

  this.maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};

function generate(ast, options) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: state.staticRenderFns
  };
}

function genElement(el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // component or element
    var code;

    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;

      if (!el.plain || el.pre && state.maybeComponent(el)) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    } // module transforms


    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }

    return code;
  }
} // hoist static sub-trees out


function genStatic(el, state) {
  el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.

  var originalPreState = state.pre;

  if (el.pre) {
    state.pre = el.pre;
  }

  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
  state.pre = originalPreState;
  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
} // v-once


function genOnce(el, state) {
  el.onceProcessed = true;

  if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;

    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }

      parent = parent.parent;
    }

    if (!key) {
       true && state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap['v-once']);
      return genElement(el, state);
    }

    return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
  } else {
    return genStatic(el, state);
  }
}

function genIf(el, state, altGen, altEmpty) {
  el.ifProcessed = true; // avoid recursion

  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}

function genIfConditions(conditions, state, altGen, altEmpty) {
  if (!conditions.length) {
    return altEmpty || '_e()';
  }

  var condition = conditions.shift();

  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
  } else {
    return "" + genTernaryExp(condition.block);
  } // v-if with v-once should generate code like (a)?_m(0):_m(1)


  function genTernaryExp(el) {
    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
  }
}

function genFor(el, state, altGen, altHelper) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if ( true && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", el.rawAttrsMap['v-for'], true
    /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion

  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
}

function genData$2(el, state) {
  var data = '{'; // directives first.
  // directives may mutate the el's other properties before they are generated.

  var dirs = genDirectives(el, state);

  if (dirs) {
    data += dirs + ',';
  } // key


  if (el.key) {
    data += "key:" + el.key + ",";
  } // ref


  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }

  if (el.refInFor) {
    data += "refInFor:true,";
  } // pre


  if (el.pre) {
    data += "pre:true,";
  } // record original tag name for components using "is" attribute


  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  } // module data generation functions


  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  } // attributes


  if (el.attrs) {
    data += "attrs:" + genProps(el.attrs) + ",";
  } // DOM props


  if (el.props) {
    data += "domProps:" + genProps(el.props) + ",";
  } // event handlers


  if (el.events) {
    data += genHandlers(el.events, false) + ",";
  }

  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true) + ",";
  } // slot target
  // only for non-scoped slots


  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + el.slotTarget + ",";
  } // scoped slots


  if (el.scopedSlots) {
    data += genScopedSlots(el, el.scopedSlots, state) + ",";
  } // component v-model


  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  } // inline-template


  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);

    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }

  data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.

  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + el.tag + "\"," + genProps(el.dynamicAttrs) + ")";
  } // v-bind data wrap


  if (el.wrapData) {
    data = el.wrapData(data);
  } // v-on data wrap


  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }

  return data;
}

function genDirectives(el, state) {
  var dirs = el.directives;

  if (!dirs) {
    return;
  }

  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;

  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];

    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }

    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:" + (dir.isDynamicArg ? dir.arg : "\"" + dir.arg + "\"") : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }

  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el, state) {
  var ast = el.children[0];

  if ( true && (el.children.length !== 1 || ast.type !== 1)) {
    state.warn('Inline-template components must have exactly one child element.', {
      start: el.start
    });
  }

  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(el, slots, state) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    ;
  }); // #9534: if a component with scoped slots is inside a conditional branch,
  // it's possible for the same component to be reused but with different
  // compiled slot content. To avoid that, we generate a unique key based on
  // the generated code of all the slot contents.

  var needsKey = !!el.if; // OR when it is inside another scoped slot or v-for (the reactivity may be
  // disconnected due to the intermediate scope variable)
  // #9438, #9506
  // TODO: this can be further optimized by properly analyzing in-scope bindings
  // and skip force updating ones that do not actually use scope variables.

  if (!needsForceUpdate) {
    var parent = el.parent;

    while (parent) {
      if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent.for) {
        needsForceUpdate = true;
        break;
      }

      if (parent.if) {
        needsKey = true;
      }

      parent = parent.parent;
    }
  }

  var generatedSlots = Object.keys(slots).map(function (key) {
    return genScopedSlot(slots[key], state);
  }).join(',');
  return "scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? ",null,false," + hash(generatedSlots) : "") + ")";
}

function hash(str) {
  var hash = 5381;
  var i = str.length;

  while (i) {
    hash = hash * 33 ^ str.charCodeAt(--i);
  }

  return hash >>> 0;
}

function containsSlotChild(el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true;
    }

    return el.children.some(containsSlotChild);
  }

  return false;
}

function genScopedSlot(el, state) {
  var isLegacySyntax = el.attrsMap['slot-scope'];

  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null");
  }

  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot);
  }

  var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
  var fn = "function(" + slotScope + "){" + "return " + (el.tag === 'template' ? el.if && isLegacySyntax ? "(" + el.if + ")?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}"; // reverse proxy v-slot without scope on this.$slots

  var reverseProxy = slotScope ? "" : ",proxy:true";
  return "{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}";
}

function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
  var children = el.children;

  if (children.length) {
    var el$1 = children[0]; // optimize single v-for

    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      var normalizationType = checkSkip ? state.maybeComponent(el$1) ? ",1" : ",0" : "";
      return "" + (altGenElement || genElement)(el$1, state) + normalizationType;
    }

    var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
    var gen = altGenNode || genNode;
    return "[" + children.map(function (c) {
      return gen(c, state);
    }).join(',') + "]" + (normalizationType$1 ? "," + normalizationType$1 : '');
  }
} // determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed


function getNormalizationType(children, maybeComponent) {
  var res = 0;

  for (var i = 0; i < children.length; i++) {
    var el = children[i];

    if (el.type !== 1) {
      continue;
    }

    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }

    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }

  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function genNode(node, state) {
  if (node.type === 1) {
    return genElement(node, state);
  } else if (node.type === 3 && node.isComment) {
    return genComment(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genComment(comment) {
  return "_e(" + JSON.stringify(comment.text) + ")";
}

function genSlot(el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {
    return {
      // slot props are camelized
      name: camelize(attr.name),
      value: attr.value,
      dynamic: attr.dynamic
    };
  })) : null;
  var bind$$1 = el.attrsMap['v-bind'];

  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }

  if (attrs) {
    res += "," + attrs;
  }

  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }

  return res + ')';
} // componentName is el.component, take it as argument to shun flow's pessimistic refinement


function genComponent(componentName, el, state) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var staticProps = "";
  var dynamicProps = "";

  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);

    if (prop.dynamic) {
      dynamicProps += prop.name + "," + value + ",";
    } else {
      staticProps += "\"" + prop.name + "\":" + value + ",";
    }
  }

  staticProps = "{" + staticProps.slice(0, -1) + "}";

  if (dynamicProps) {
    return "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])";
  } else {
    return staticProps;
  }
} // #3895, #4268


function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}
/*  */
// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed


var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b'); // these unary operators should not be used as property/method names

var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)'); // strip strings in expressions

var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g; // detect problematic expressions in a template

function detectErrors(ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode(node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];

        if (value) {
          var range = node.rawAttrsMap[name];

          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", warn, range);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", warn, range);
          }
        }
      }
    }

    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent(exp, text, warn, range) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);

  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    warn("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim(), range);
  }

  checkExpression(exp, text, warn, range);
}

function checkFor(node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier(ident, type, text, warn, range) {
  if (typeof ident === 'string') {
    try {
      new Function("var " + ident + "=_");
    } catch (e) {
      warn("invalid " + type + " \"" + ident + "\" in expression: " + text.trim(), range);
    }
  }
}

function checkExpression(exp, text, warn, range) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);

    if (keywordMatch) {
      warn("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim(), range);
    } else {
      warn("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
    }
  }
}
/*  */


var range = 2;

function generateCodeFrame(source, start, end) {
  if (start === void 0) start = 0;
  if (end === void 0) end = source.length;
  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];

  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;

    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) {
          continue;
        }

        res.push("" + (j + 1) + repeat$1(" ", 3 - String(j + 1).length) + "|  " + lines[j]);
        var lineLength = lines[j].length;

        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat$1(" ", pad) + repeat$1("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat$1("^", length$1));
          }

          count += lineLength + 1;
        }
      }

      break;
    }
  }

  return res.join('\n');
}

function repeat$1(str, n) {
  var result = '';

  if (n > 0) {
    while (true) {
      // eslint-disable-line
      if (n & 1) {
        result += str;
      }

      n >>>= 1;

      if (n <= 0) {
        break;
      }

      str += str;
    }
  }

  return result;
}
/*  */


function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({
      err: err,
      code: code
    });
    return noop;
  }
}

function createCompileToFunctionFn(compile) {
  var cache = Object.create(null);
  return function compileToFunctions(template, options, vm) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;
    /* istanbul ignore if */

    if (true) {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    } // check cache


    var key = options.delimiters ? String(options.delimiters) + template : template;

    if (cache[key]) {
      return cache[key];
    } // compile


    var compiled = compile(template, options); // check compilation errors/tips

    if (true) {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn$$1("Error compiling template:\n\n" + e.msg + "\n\n" + generateCodeFrame(template, e.start, e.end), vm);
          });
        } else {
          warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
            return "- " + e;
          }).join('\n') + '\n', vm);
        }
      }

      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) {
            return tip(e.msg, vm);
          });
        } else {
          compiled.tips.forEach(function (msg) {
            return tip(msg, vm);
          });
        }
      }
    } // turn code into functions


    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors);
    }); // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use

    /* istanbul ignore if */

    if (true) {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;
          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }

    return cache[key] = res;
  };
}
/*  */


function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {
    function compile(template, options) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function (msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if ( true && options.outputSourceRange) {
          // $flow-disable-line
          var leadingSpaceLength = template.match(/^\s*/)[0].length;

          warn = function (msg, range, tip) {
            var data = {
              msg: msg
            };

            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength;
              }

              if (range.end != null) {
                data.end = range.end + leadingSpaceLength;
              }
            }

            (tip ? tips : errors).push(data);
          };
        } // merge custom modules


        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
        } // merge custom directives


        if (options.directives) {
          finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
        } // copy other options


        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;
      var compiled = baseCompile(template.trim(), finalOptions);

      if (true) {
        detectErrors(compiled.ast, warn);
      }

      compiled.errors = errors;
      compiled.tips = tips;
      return compiled;
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    };
  };
}
/*  */
// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.


var createCompiler = createCompilerCreator(function baseCompile(template, options) {
  var ast = parse(template.trim(), options);

  if (options.optimize !== false) {
    optimize(ast, options);
  }

  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
});
/*  */

var ref$1 = createCompiler(baseOptions);
var compile = ref$1.compile;
var compileToFunctions = ref$1.compileToFunctions;
/*  */
// check whether current browser encodes a char inside attribute values

var div;

function getShouldDecode(href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0;
} // #3663: IE encodes newlines inside attribute values while other browsers don't


var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]

var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;
/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});
var mount = Vue.prototype.$mount;

Vue.prototype.$mount = function (el, hydrating) {
  el = el && query(el);
  /* istanbul ignore if */

  if (el === document.body || el === document.documentElement) {
     true && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options; // resolve template/el and convert to render function

  if (!options.render) {
    var template = options.template;

    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */

          if ( true && !template) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (true) {
          warn('invalid template option:' + template, this);
        }

        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }

    if (template) {
      /* istanbul ignore if */
      if ( true && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        outputSourceRange: "development" !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;
      /* istanbul ignore if */

      if ( true && config.performance && mark) {
        mark('compile end');
        measure("vue " + this._name + " compile", 'compile', 'compile end');
      }
    }
  }

  return mount.call(this, el, hydrating);
};
/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */


function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue.compile = compileToFunctions;
/* harmony default export */ __webpack_exports__["default"] = (Vue);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "yLpj"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "URgk").setImmediate))

/***/ }),

/***/ "pEgf":
/*!*****************************************!*\
  !*** ./node_modules/jquery/src/data.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./core/access */ "MT+g"), __webpack_require__(/*! ./core/camelCase */ "jz24"), __webpack_require__(/*! ./data/var/dataPriv */ "082X"), __webpack_require__(/*! ./data/var/dataUser */ "aAjK")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, access, camelCase, dataPriv, dataUser) {
  "use strict"; //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;

  function getData(data) {
    if (data === "true") {
      return true;
    }

    if (data === "false") {
      return false;
    }

    if (data === "null") {
      return null;
    } // Only convert to a number if it doesn't change the string


    if (data === +data + "") {
      return +data;
    }

    if (rbrace.test(data)) {
      return JSON.parse(data);
    }

    return data;
  }

  function dataAttr(elem, key, data) {
    var name; // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute

    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);

      if (typeof data === "string") {
        try {
          data = getData(data);
        } catch (e) {} // Make sure we set the data so it isn't changed later


        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }

    return data;
  }

  jQuery.extend({
    hasData: function (elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function (elem, name, data) {
      return dataUser.access(elem, name, data);
    },
    removeData: function (elem, name) {
      dataUser.remove(elem, name);
    },
    // TODO: Now that all calls to _data and _removeData have been replaced
    // with direct calls to dataPriv methods, these can be deprecated.
    _data: function (elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function (elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function (key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes; // Gets all values

      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);

          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;

            while (i--) {
              // Support: IE 11 only
              // The attrs elements can be null (#14894)
              if (attrs[i]) {
                name = attrs[i].name;

                if (name.indexOf("data-") === 0) {
                  name = camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }

            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }

        return data;
      } // Sets multiple values


      if (typeof key === "object") {
        return this.each(function () {
          dataUser.set(this, key);
        });
      }

      return access(this, function (value) {
        var data; // The calling jQuery object (element matches) is not empty
        // (and therefore has an element appears at this[ 0 ]) and the
        // `value` parameter was not undefined. An empty jQuery object
        // will result in `undefined` for elem = this[ 0 ] which will
        // throw an exception if an attempt to read a data cache is made.

        if (elem && value === undefined) {
          // Attempt to get data from the cache
          // The key will always be camelCased in Data
          data = dataUser.get(elem, key);

          if (data !== undefined) {
            return data;
          } // Attempt to "discover" the data in
          // HTML5 custom data-* attrs


          data = dataAttr(elem, key);

          if (data !== undefined) {
            return data;
          } // We tried really hard, but the data doesn't exist.


          return;
        } // Set the data...


        this.each(function () {
          // We always store the camelCased key
          dataUser.set(this, key, value);
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function (key) {
      return this.each(function () {
        dataUser.remove(this, key);
      });
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "pj6h":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/css/var/swap.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict"; // A method for quickly swapping in/out CSS properties to get correct calculations.

  return function (elem, options, callback, args) {
    var ret,
        name,
        old = {}; // Remember the old values, and insert the new ones

    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }

    ret = callback.apply(elem, args || []); // Revert the old values

    for (name in options) {
      elem.style[name] = old[name];
    }

    return ret;
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "q7bA":
/*!****************************************************!*\
  !*** ./node_modules/jquery/src/attributes/attr.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../core/access */ "MT+g"), __webpack_require__(/*! ../core/nodeName */ "NKsO"), __webpack_require__(/*! ./support */ "F83J"), __webpack_require__(/*! ../var/rnothtmlwhite */ "VK0Q"), __webpack_require__(/*! ../selector */ "dyyg")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, access, nodeName, support, rnothtmlwhite) {
  "use strict";

  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function (name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function (name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function (elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      } // Fallback to prop when attributes are not supported


      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      } // Attribute hooks are determined by the lowercase version
      // Grab necessary hook if one is defined


      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }

      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }

        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        elem.setAttribute(name, value + "");
        return value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

      return ret == null ? undefined : ret;
    },
    attrHooks: {
      type: {
        set: function (elem, value) {
          if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);

            if (val) {
              elem.value = val;
            }

            return value;
          }
        }
      }
    },
    removeAttr: function (elem, value) {
      var name,
          i = 0,
          // Attribute names can contain non-HTML whitespace characters
      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
      attrNames = value && value.match(rnothtmlwhite);

      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          elem.removeAttribute(name);
        }
      }
    }
  }); // Hooks for boolean attributes

  boolHook = {
    set: function (elem, value, name) {
      if (value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }

      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;

    attrHandle[name] = function (elem, name, isXML) {
      var ret,
          handle,
          lowercaseName = name.toLowerCase();

      if (!isXML) {
        // Avoid an infinite loop by temporarily removing this function from the getter
        handle = attrHandle[lowercaseName];
        attrHandle[lowercaseName] = ret;
        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
        attrHandle[lowercaseName] = handle;
      }

      return ret;
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "qbCo":
/*!**************************************************!*\
  !*** ./node_modules/jquery/src/css/adjustCSS.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../var/rcssNum */ "FbHE")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, rcssNum) {
  "use strict";

  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale,
        maxIterations = 20,
        currentValue = tween ? function () {
      return tween.cur();
    } : function () {
      return jQuery.css(elem, prop, "");
    },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        // Starting value computation is required for potential unit mismatches
    initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

    if (initialInUnit && initialInUnit[3] !== unit) {
      // Support: Firefox <=54
      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
      initial = initial / 2; // Trust units reported by jQuery.css

      unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point

      initialInUnit = +initial || 1;

      while (maxIterations--) {
        // Evaluate and update our best guess (doubling guesses that zero out).
        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
        jQuery.style(elem, prop, initialInUnit + unit);

        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
          maxIterations = 0;
        }

        initialInUnit = initialInUnit / scale;
      }

      initialInUnit = initialInUnit * 2;
      jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on

      valueParts = valueParts || [];
    }

    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }

    return adjusted;
  }

  return adjustCSS;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "rwP8":
/*!********************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/getAll.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../core/nodeName */ "NKsO")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, nodeName) {
  "use strict";

  function getAll(context, tag) {
    // Support: IE <=9 - 11 only
    // Use typeof to avoid zero-argument method invocation on host objects (#15151)
    var ret;

    if (typeof context.getElementsByTagName !== "undefined") {
      ret = context.getElementsByTagName(tag || "*");
    } else if (typeof context.querySelectorAll !== "undefined") {
      ret = context.querySelectorAll(tag || "*");
    } else {
      ret = [];
    }

    if (tag === undefined || tag && nodeName(context, tag)) {
      return jQuery.merge([context], ret);
    }

    return ret;
  }

  return getAll;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "s44h":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/var/isFunction.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return function isFunction(obj) {
    // Support: Chrome <=57, Firefox <=52
    // In some browsers, typeof returns "function" for HTML <object> elements
    // (i.e., `typeof document.createElement( "object" ) === "function"`).
    // We don't want to classify *any* DOM node as a function.
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "sNS9":
/*!**************************************************!*\
  !*** ./node_modules/jquery/src/effects/Tween.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../css */ "1wM/")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }

  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function (elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function () {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function (percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];

      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }

      this.now = (this.end - this.start) * eased + this.start;

      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }

      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }

      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function (tween) {
        var result; // Use a property on the element directly when it is not a DOM element,
        // or when there is no matching style property that exists.

        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        } // Passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails.
        // Simple values such as "10px" are parsed to Float;
        // complex values such as "rotate(1rad)" are returned as-is.


        result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

        return !result || result === "auto" ? 0 : result;
      },
      set: function (tween) {
        // Use step hook for back compat.
        // Use cssHook if its there.
        // Use .style if available and use plain properties where available.
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  }; // Support: IE <=9 only
  // Panic based approach to setting things on disconnected nodes

  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function (tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.easing = {
    linear: function (p) {
      return p;
    },
    swing: function (p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point

  jQuery.fx.step = {};
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "tI8X":
/*!********************************************************!*\
  !*** ./node_modules/jquery/src/core/readyException.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  jQuery.readyException = function (error) {
    window.setTimeout(function () {
      throw error;
    });
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "tgXZ":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/url-escape.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function escape(url, needQuotes) {
  if (typeof url !== 'string') {
    return url;
  } // If url is already wrapped in quotes, remove them


  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]/.test(url) || needQuotes) {
    return '"' + url.replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"';
  }

  return url;
};

/***/ }),

/***/ "tx45":
/*!****************************************************!*\
  !*** ./node_modules/jquery/src/selector-sizzle.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ../external/sizzle/dist/sizzle */ "BK5V")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, Sizzle) {
  "use strict";

  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors; // Deprecated

  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "tz86":
/*!********************************************************!*\
  !*** ./node_modules/jquery/src/var/documentElement.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./document */ "iprW")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (document) {
  "use strict";

  return document.documentElement;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "vY0G":
/*!********************************************!*\
  !*** ./node_modules/jquery/src/effects.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./core/camelCase */ "jz24"), __webpack_require__(/*! ./var/document */ "iprW"), __webpack_require__(/*! ./var/isFunction */ "s44h"), __webpack_require__(/*! ./var/rcssNum */ "FbHE"), __webpack_require__(/*! ./var/rnothtmlwhite */ "VK0Q"), __webpack_require__(/*! ./css/var/cssExpand */ "P+Hb"), __webpack_require__(/*! ./css/var/isHiddenWithinTree */ "Lps/"), __webpack_require__(/*! ./css/var/swap */ "pj6h"), __webpack_require__(/*! ./css/adjustCSS */ "qbCo"), __webpack_require__(/*! ./data/var/dataPriv */ "082X"), __webpack_require__(/*! ./css/showHide */ "xuQa"), __webpack_require__(/*! ./core/init */ "MsD2"), __webpack_require__(/*! ./queue */ "0VMG"), __webpack_require__(/*! ./deferred */ "G5n7"), __webpack_require__(/*! ./traversing */ "wkHr"), __webpack_require__(/*! ./manipulation */ "PRQw"), __webpack_require__(/*! ./css */ "1wM/"), __webpack_require__(/*! ./effects/Tween */ "sNS9")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, camelCase, document, isFunction, rcssNum, rnothtmlwhite, cssExpand, isHiddenWithinTree, swap, adjustCSS, dataPriv, showHide) {
  "use strict";

  var fxNow,
      inProgress,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;

  function schedule() {
    if (inProgress) {
      if (document.hidden === false && window.requestAnimationFrame) {
        window.requestAnimationFrame(schedule);
      } else {
        window.setTimeout(schedule, jQuery.fx.interval);
      }

      jQuery.fx.tick();
    }
  } // Animations created synchronously will run synchronously


  function createFxNow() {
    window.setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = Date.now();
  } // Generate parameters to create a standard animation


  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {
      height: type
    }; // If we include width, step value is 1 to do all cssExpand values,
    // otherwise step value is 2 to skip over Left and Right

    includeWidth = includeWidth ? 1 : 0;

    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }

    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }

    return attrs;
  }

  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;

    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        // We're done with this property
        return tween;
      }
    }
  }

  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        hooks,
        oldfire,
        propTween,
        restoreDisplay,
        display,
        isBox = "width" in props || "height" in props,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHiddenWithinTree(elem),
        dataShow = dataPriv.get(elem, "fxshow"); // Queue-skipping animations hijack the fx hooks

    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");

      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;

        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }

      hooks.unqueued++;
      anim.always(function () {
        // Ensure the complete handler is called before this completes
        anim.always(function () {
          hooks.unqueued--;

          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    } // Detect show/hide animations


    for (prop in props) {
      value = props[prop];

      if (rfxtypes.test(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";

        if (value === (hidden ? "hide" : "show")) {
          // Pretend to be hidden if this is a "show" and
          // there is still data from a stopped show/hide
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true; // Ignore all other no-op show/hide data
          } else {
            continue;
          }
        }

        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    } // Bail out if this is a no-op like .hide().hide()


    propTween = !jQuery.isEmptyObject(props);

    if (!propTween && jQuery.isEmptyObject(orig)) {
      return;
    } // Restrict "overflow" and "display" styles during box animations


    if (isBox && elem.nodeType === 1) {
      // Support: IE <=9 - 11, Edge 12 - 15
      // Record all 3 overflow attributes because IE does not infer the shorthand
      // from identically-valued overflowX and overflowY and Edge just mirrors
      // the overflowX value there.
      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade

      restoreDisplay = dataShow && dataShow.display;

      if (restoreDisplay == null) {
        restoreDisplay = dataPriv.get(elem, "display");
      }

      display = jQuery.css(elem, "display");

      if (display === "none") {
        if (restoreDisplay) {
          display = restoreDisplay;
        } else {
          // Get nonempty value(s) by temporarily forcing visibility
          showHide([elem], true);
          restoreDisplay = elem.style.display || restoreDisplay;
          display = jQuery.css(elem, "display");
          showHide([elem]);
        }
      } // Animate inline elements as inline-block


      if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
        if (jQuery.css(elem, "float") === "none") {
          // Restore the original display value at the end of pure show/hide animations
          if (!propTween) {
            anim.done(function () {
              style.display = restoreDisplay;
            });

            if (restoreDisplay == null) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }

          style.display = "inline-block";
        }
      }
    }

    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    } // Implement show/hide animations


    propTween = false;

    for (prop in orig) {
      // General show/hide setup for this element animation
      if (!propTween) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access(elem, "fxshow", {
            display: restoreDisplay
          });
        } // Store hidden/visible for toggle so `.stop().toggle()` "reverses"


        if (toggle) {
          dataShow.hidden = !hidden;
        } // Show elements before animating them


        if (hidden) {
          showHide([elem], true);
        }
        /* eslint-disable no-loop-func */


        anim.done(function () {
          /* eslint-enable no-loop-func */
          // The final step of a "hide" animation is actually hiding the element
          if (!hidden) {
            showHide([elem]);
          }

          dataPriv.remove(elem, "fxshow");

          for (prop in orig) {
            jQuery.style(elem, prop, orig[prop]);
          }
        });
      } // Per-property setup


      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

      if (!(prop in dataShow)) {
        dataShow[prop] = propTween.start;

        if (hidden) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }

  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

    for (index in props) {
      name = camelCase(index);
      easing = specialEasing[name];
      value = props[index];

      if (Array.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }

      if (index !== name) {
        props[name] = value;
        delete props[index];
      }

      hooks = jQuery.cssHooks[name];

      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
        // Reusing 'index' because we have the correct "name"

        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }

  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function () {
      // Don't match elem in the :animated selector
      delete tick.elem;
    }),
        tick = function () {
      if (stopped) {
        return false;
      }

      var currentTime = fxNow || createFxNow(),
          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          // Support: Android 2.3 only
      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
      temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;

      for (; index < length; index++) {
        animation.tweens[index].run(percent);
      }

      deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield

      if (percent < 1 && length) {
        return remaining;
      } // If this was an empty animation, synthesize a final progress notification


      if (!length) {
        deferred.notifyWith(elem, [animation, 1, 0]);
      } // Resolve the animation and report its conclusion


      deferred.resolveWith(elem, [animation]);
      return false;
    },
        animation = deferred.promise({
      elem: elem,
      props: jQuery.extend({}, properties),
      opts: jQuery.extend(true, {
        specialEasing: {},
        easing: jQuery.easing._default
      }, options),
      originalProperties: properties,
      originalOptions: options,
      startTime: fxNow || createFxNow(),
      duration: options.duration,
      tweens: [],
      createTween: function (prop, end) {
        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
        animation.tweens.push(tween);
        return tween;
      },
      stop: function (gotoEnd) {
        var index = 0,
            // If we are going to the end, we want to run all the tweens
        // otherwise we skip this part
        length = gotoEnd ? animation.tweens.length : 0;

        if (stopped) {
          return this;
        }

        stopped = true;

        for (; index < length; index++) {
          animation.tweens[index].run(1);
        } // Resolve when we played the last frame; otherwise, reject


        if (gotoEnd) {
          deferred.notifyWith(elem, [animation, 1, 0]);
          deferred.resolveWith(elem, [animation, gotoEnd]);
        } else {
          deferred.rejectWith(elem, [animation, gotoEnd]);
        }

        return this;
      }
    }),
        props = animation.props;

    propFilter(props, animation.opts.specialEasing);

    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);

      if (result) {
        if (isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
        }

        return result;
      }
    }

    jQuery.map(props, createTween, animation);

    if (isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    } // Attach callbacks from options


    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation;
  }

  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {
      "*": [function (prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]
    },
    tweener: function (props, callback) {
      if (isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnothtmlwhite);
      }

      var prop,
          index = 0,
          length = props.length;

      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function (callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });

  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !isFunction(easing) && easing
    }; // Go to the end state if fx are off

    if (jQuery.fx.off) {
      opt.duration = 0;
    } else {
      if (typeof opt.duration !== "number") {
        if (opt.duration in jQuery.fx.speeds) {
          opt.duration = jQuery.fx.speeds[opt.duration];
        } else {
          opt.duration = jQuery.fx.speeds._default;
        }
      }
    } // Normalize opt.queue - true/undefined/null -> "fx"


    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    } // Queueing


    opt.old = opt.complete;

    opt.complete = function () {
      if (isFunction(opt.old)) {
        opt.old.call(this);
      }

      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };

    return opt;
  };

  jQuery.fn.extend({
    fadeTo: function (speed, to, easing, callback) {
      // Show any hidden elements after setting opacity to 0
      return this.filter(isHiddenWithinTree).css("opacity", 0).show() // Animate to the value specified
      .end().animate({
        opacity: to
      }, speed, easing, callback);
    },
    animate: function (prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function () {
        // Operate on a copy of prop so per-property easing won't be lost
        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

        if (empty || dataPriv.get(this, "finish")) {
          anim.stop(true);
        }
      };

      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function (type, clearQueue, gotoEnd) {
      var stopQueue = function (hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };

      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }

      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }

      return this.each(function () {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);

        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }

        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        } // Start the next in the queue if the last step wasn't forced.
        // Timers currently will call their complete callbacks, which
        // will dequeue but only if they were gotoEnd.


        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function (type) {
      if (type !== false) {
        type = type || "fx";
      }

      return this.each(function () {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0; // Enable finishing flag on private data

        data.finish = true; // Empty the queue first

        jQuery.queue(this, type, []);

        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        } // Look for any active animations, and finish them


        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        } // Look for any animations in the old queue and finish them


        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        } // Turn off finishing flag


        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function (i, name) {
    var cssFn = jQuery.fn[name];

    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  }); // Generate shortcuts for custom animations

  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];

  jQuery.fx.tick = function () {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = Date.now();

    for (; i < timers.length; i++) {
      timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)

      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }

    if (!timers.length) {
      jQuery.fx.stop();
    }

    fxNow = undefined;
  };

  jQuery.fx.timer = function (timer) {
    jQuery.timers.push(timer);
    jQuery.fx.start();
  };

  jQuery.fx.interval = 13;

  jQuery.fx.start = function () {
    if (inProgress) {
      return;
    }

    inProgress = true;
    schedule();
  };

  jQuery.fx.stop = function () {
    inProgress = null;
  };

  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
  };
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "vnkT":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/core/ready.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../var/document */ "iprW"), __webpack_require__(/*! ../core/readyException */ "tI8X"), __webpack_require__(/*! ../deferred */ "G5n7")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document) {
  "use strict"; // The deferred used on DOM ready

  var readyList = jQuery.Deferred();

  jQuery.fn.ready = function (fn) {
    readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
    // happens at the time of error handling instead of callback
    // registration.
    .catch(function (error) {
      jQuery.readyException(error);
    });
    return this;
  };

  jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,
    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,
    // Handle when the DOM is ready
    ready: function (wait) {
      // Abort if there are pending holds or we're already ready
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      } // Remember that the DOM is ready


      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      } // If there are functions bound, to execute


      readyList.resolveWith(document, [jQuery]);
    }
  });
  jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  } // Catch cases where $(document).ready() is called
  // after the browser event has already occurred.
  // Support: IE <=9 - 10 only
  // Older IE sometimes signals "interactive" too soon


  if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
    // Handle it asynchronously to allow scripts the opportunity to delay ready
    window.setTimeout(jQuery.ready);
  } else {
    // Use the handy event callback
    document.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

    window.addEventListener("load", completed);
  }
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "w5up":
/*!*************************************************************!*\
  !*** ./node_modules/jquery/src/effects/animatedSelector.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../selector */ "dyyg"), __webpack_require__(/*! ../effects */ "vY0G")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  jQuery.expr.pseudos.animated = function (elem) {
    return jQuery.grep(jQuery.timers, function (fn) {
      return elem === fn.elem;
    }).length;
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "wLhr":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/attributes/val.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../core/stripAndCollapse */ "3PRc"), __webpack_require__(/*! ./support */ "F83J"), __webpack_require__(/*! ../core/nodeName */ "NKsO"), __webpack_require__(/*! ../var/isFunction */ "s44h"), __webpack_require__(/*! ../core/init */ "MsD2")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, stripAndCollapse, support, nodeName, isFunction) {
  "use strict";

  var rreturn = /\r/g;
  jQuery.fn.extend({
    val: function (value) {
      var hooks,
          ret,
          valueIsFunction,
          elem = this[0];

      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }

          ret = elem.value; // Handle most common string cases

          if (typeof ret === "string") {
            return ret.replace(rreturn, "");
          } // Handle cases where value is null/undef or number


          return ret == null ? "" : ret;
        }

        return;
      }

      valueIsFunction = isFunction(value);
      return this.each(function (i) {
        var val;

        if (this.nodeType !== 1) {
          return;
        }

        if (valueIsFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        } // Treat null/undefined as ""; convert numbers to string


        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (Array.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? "" : value + "";
          });
        }

        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function (elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : // Support: IE <=10 - 11 only
          // option.text throws exceptions (#14686, #14858)
          // Strip and collapse whitespace
          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
          stripAndCollapse(jQuery.text(elem));
        }
      },
      select: {
        get: function (elem) {
          var value,
              option,
              i,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one",
              values = one ? null : [],
              max = one ? index + 1 : options.length;

          if (index < 0) {
            i = max;
          } else {
            i = one ? index : 0;
          } // Loop through all the selected options


          for (; i < max; i++) {
            option = options[i]; // Support: IE <=9 only
            // IE8-9 doesn't update selected after form reset (#2551)

            if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
              // Get the specific value for the option
              value = jQuery(option).val(); // We don't need an array for one selects

              if (one) {
                return value;
              } // Multi-Selects return an array


              values.push(value);
            }
          }

          return values;
        },
        set: function (elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;

          while (i--) {
            option = options[i];
            /* eslint-disable no-cond-assign */

            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
            /* eslint-enable no-cond-assign */

          } // Force browsers to behave consistently when non-matching value is set


          if (!optionSet) {
            elem.selectedIndex = -1;
          }

          return values;
        }
      }
    }
  }); // Radios and checkboxes getter/setter

  jQuery.each(["radio", "checkbox"], function () {
    jQuery.valHooks[this] = {
      set: function (elem, value) {
        if (Array.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
        }
      }
    };

    if (!support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "wkHr":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/traversing.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./var/indexOf */ "ePh3"), __webpack_require__(/*! ./traversing/var/dir */ "KsYY"), __webpack_require__(/*! ./traversing/var/siblings */ "75f9"), __webpack_require__(/*! ./traversing/var/rneedsContext */ "65MQ"), __webpack_require__(/*! ./core/nodeName */ "NKsO"), __webpack_require__(/*! ./core/init */ "MsD2"), __webpack_require__(/*! ./traversing/findFilter */ "R026"), __webpack_require__(/*! ./selector */ "dyyg")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, indexOf, dir, siblings, rneedsContext, nodeName) {
  "use strict";

  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      // Methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };
  jQuery.fn.extend({
    has: function (target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function () {
        var i = 0;

        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function (selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

      if (!rneedsContext.test(selectors)) {
        for (; i < l; i++) {
          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
            // Always skip document fragments
            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
              matched.push(cur);
              break;
            }
          }
        }
      }

      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    // Determine the position of an element within the set
    index: function (elem) {
      // No argument, return index in parent
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      } // Index in selector


      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      } // Locate the position of the desired element


      return indexOf.call(this, // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem);
    },
    add: function (selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function (selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });

  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}

    return cur;
  }

  jQuery.each({
    parent: function (elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function (elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function (elem, i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function (elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function (elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function (elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function (elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function (elem, i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function (elem, i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function (elem) {
      return siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function (elem) {
      return siblings(elem.firstChild);
    },
    contents: function (elem) {
      if (nodeName(elem, "iframe")) {
        return elem.contentDocument;
      } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
      // Treat the template element as a regular one in browsers that
      // don't support it.


      if (nodeName(elem, "template")) {
        elem = elem.content || elem;
      }

      return jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var matched = jQuery.map(this, fn, until);

      if (name.slice(-5) !== "Until") {
        selector = until;
      }

      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }

      if (this.length > 1) {
        // Remove duplicates
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        } // Reverse order for parents* and prev-derivatives


        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }

      return this.pushStack(matched);
    };
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "wqe2":
/*!*********************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/wrapMap.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict"; // We have to close these tags to support XHTML (#13200)

  var wrapMap = {
    // Support: IE <=9 only
    option: [1, "<select multiple='multiple'>", "</select>"],
    // XHTML parsers do not magically insert elements in the
    // same way that tag soup parsers do. So we cannot shorten
    // this by omitting <tbody> or other required elements.
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  }; // Support: IE <=9 only

  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  return wrapMap;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "xLti":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/css/var/rnumnonpx.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../../var/pnum */ "UQHn")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (pnum) {
  "use strict";

  return new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "xccy":
/*!********************************************!*\
  !*** ./node_modules/jquery/src/var/arr.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return [];
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "xrz1":
/*!**********************************************!*\
  !*** ./node_modules/jquery/src/serialize.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "mEBU"), __webpack_require__(/*! ./core/toType */ "VAby"), __webpack_require__(/*! ./manipulation/var/rcheckableType */ "+PHv"), __webpack_require__(/*! ./var/isFunction */ "s44h"), __webpack_require__(/*! ./core/init */ "MsD2"), __webpack_require__(/*! ./traversing */ "wkHr"), // filter
__webpack_require__(/*! ./attributes/prop */ "8g73")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, toType, rcheckableType, isFunction) {
  "use strict";

  var rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams(prefix, obj, traditional, add) {
    var name;

    if (Array.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);
        } else {
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && toType(obj) === "object") {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  } // Serialize an array of form elements or a set of
  // key/values into a query string


  jQuery.param = function (a, traditional) {
    var prefix,
        s = [],
        add = function (key, valueOrFunction) {
      // If value is a function, invoke it and use its return value
      var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
      s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
    }; // If an array was passed in, assume that it is an array of form elements.


    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      // Serialize the form elements
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    } // Return the resulting serialization


    return s.join("&");
  };

  jQuery.fn.extend({
    serialize: function () {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function (i, elem) {
        var val = jQuery(this).val();

        if (val == null) {
          return null;
        }

        if (Array.isArray(val)) {
          return jQuery.map(val, function (val) {
            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          });
        }

        return {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "xuQa":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/css/showHide.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "mEBU"), __webpack_require__(/*! ../data/var/dataPriv */ "082X"), __webpack_require__(/*! ../css/var/isHiddenWithinTree */ "Lps/")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, dataPriv, isHiddenWithinTree) {
  "use strict";

  var defaultDisplayMap = {};

  function getDefaultDisplay(elem) {
    var temp,
        doc = elem.ownerDocument,
        nodeName = elem.nodeName,
        display = defaultDisplayMap[nodeName];

    if (display) {
      return display;
    }

    temp = doc.body.appendChild(doc.createElement(nodeName));
    display = jQuery.css(temp, "display");
    temp.parentNode.removeChild(temp);

    if (display === "none") {
      display = "block";
    }

    defaultDisplayMap[nodeName] = display;
    return display;
  }

  function showHide(elements, show) {
    var display,
        elem,
        values = [],
        index = 0,
        length = elements.length; // Determine new display value for elements that need to change

    for (; index < length; index++) {
      elem = elements[index];

      if (!elem.style) {
        continue;
      }

      display = elem.style.display;

      if (show) {
        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
        // check is required in this first loop unless we have a nonempty display value (either
        // inline or about-to-be-restored)
        if (display === "none") {
          values[index] = dataPriv.get(elem, "display") || null;

          if (!values[index]) {
            elem.style.display = "";
          }
        }

        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
          values[index] = getDefaultDisplay(elem);
        }
      } else {
        if (display !== "none") {
          values[index] = "none"; // Remember what we're overwriting

          dataPriv.set(elem, "display", display);
        }
      }
    } // Set the display of the elements in a second loop to avoid constant reflow


    for (index = 0; index < length; index++) {
      if (values[index] != null) {
        elements[index].style.display = values[index];
      }
    }

    return elements;
  }

  jQuery.fn.extend({
    show: function () {
      return showHide(this, true);
    },
    hide: function () {
      return showHide(this);
    },
    toggle: function (state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }

      return this.each(function () {
        if (isHiddenWithinTree(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  return showHide;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "y2oz":
/*!*********************************************!*\
  !*** ./node_modules/jquery/src/var/push.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./arr */ "xccy")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (arr) {
  "use strict";

  return arr.push;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "yLpj":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "yPcJ":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/core/support.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/document */ "iprW"), __webpack_require__(/*! ../var/support */ "hFd1")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (document, support) {
  "use strict"; // Support: Safari 8 only
  // In Safari 8 documents created via document.implementation.createHTMLDocument
  // collapse sibling forms: the second one becomes a child of the first one.
  // Because of that, this security measure has to be disabled in Safari 8.
  // https://bugs.webkit.org/show_bug.cgi?id=137337

  support.createHTMLDocument = function () {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  }();

  return support;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "zhKS":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/var/getProto.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return Object.getPrototypeOf;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9tYW5pcHVsYXRpb24vdmFyL3JjaGVja2FibGVUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL3Zhci9PYmplY3RGdW5jdGlvblN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9jb3JlL0RPTUV2YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvYWpheC92YXIvbm9uY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvYWpheC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9hamF4L3hoci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9kYXRhL3Zhci9kYXRhUHJpdi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9xdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9hdHRyaWJ1dGVzL2NsYXNzZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvdmFyL2lzV2luZG93LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2Nzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9leHBvcnRzL2FtZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9jb3JlL3N0cmlwQW5kQ29sbGFwc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvdmFyL2NvbmNhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9xdWV1ZS9kZWxheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9tYW5pcHVsYXRpb24vc2V0R2xvYmFsRXZhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy90cmF2ZXJzaW5nL3Zhci9ybmVlZHNDb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL3RyYXZlcnNpbmcvdmFyL3NpYmxpbmdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pcy1kb20tbm9kZS1saXN0L2Rpc3QvaXMtZG9tLW5vZGUtbGlzdC5lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy93cmFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2F0dHJpYnV0ZXMvcHJvcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZWFsaWdodC9kaXN0L3RlYWxpZ2h0LmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL29mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pcy1kb20tbm9kZS9kaXN0L2lzLWRvbS1ub2RlLmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvZXh0ZXJuYWwvc2l6emxlL2Rpc3Qvc2l6emxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL3Zhci9oYXNPd24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvYWpheC92YXIvcnF1ZXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2V2ZW50L2FqYXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvZXZlbnQvZm9jdXNpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9hdHRyaWJ1dGVzL3N1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvdmFyL2NsYXNzMnR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvdmFyL3Jjc3NOdW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvZGVmZXJyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvbWFuaXB1bGF0aW9uL3N1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvdmFyL2ZuVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9tYW5pcHVsYXRpb24vdmFyL3J0YWdOYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvYWpheC9qc29ucC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy90cmF2ZXJzaW5nL3Zhci9kaXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvY3NzL3Zhci9pc0hpZGRlbldpdGhpblRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvY29yZS9hY2Nlc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvY29yZS9pbml0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2NvcmUvbm9kZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvZGVwcmVjYXRlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9jc3MvdmFyL2Nzc0V4cGFuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9tYW5pcHVsYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvdmFyL3NsaWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2FqYXgvc2NyaXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2Nzcy9jdXJDU1MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvdHJhdmVyc2luZy9maW5kRmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2V2ZW50L3N1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvbWFuaXB1bGF0aW9uL3Zhci9yc2NyaXB0VHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2Nzcy9oaWRkZW5WaXNpYmxlU2VsZWN0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2V4cG9ydHMvZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2RhdGEvdmFyL2FjY2VwdERhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvY3NzL3N1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvdmFyL3BudW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvY29yZS90b1R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvdmFyL3Jub3RodG1sd2hpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvZGF0YS9EYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9taW5pcmFmL2Rpc3QvbWluaXJhZi5lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9ldmVudC9hbGlhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvYWpheC92YXIvbG9jYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvYWpheC9sb2FkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2RhdGEvdmFyL2RhdGFVc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9jb3JlL3BhcnNlSFRNTC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVtYXRyaXgvZGlzdC9yZW1hdHJpeC5lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2Nyb2xscmV2ZWFsL2Rpc3Qvc2Nyb2xscmV2ZWFsLmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL21hbmlwdWxhdGlvbi9fZXZhbFVybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9tYW5pcHVsYXRpb24vYnVpbGRGcmFnbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9zZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy92YXIvaW5kZXhPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9jb3JlL3Zhci9yc2luZ2xlVGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2Nzcy9hZGRHZXRIb29rSWYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvdmFyL3N1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvY2FsbGJhY2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2Nzcy92YXIvcmJveFN0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL3Zhci9kb2N1bWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL3Zhci90b1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9jb3JlL2NhbWVsQ2FzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9jc3MvdmFyL2dldFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9hamF4L3BhcnNlWE1MLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2V2ZW50L3RyaWdnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvanF1ZXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2RpbWVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvZGVmZXJyZWQvZXhjZXB0aW9uSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9kYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2Nzcy92YXIvc3dhcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9hdHRyaWJ1dGVzL2F0dHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvY3NzL2FkanVzdENTUy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9tYW5pcHVsYXRpb24vZ2V0QWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL3Zhci9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2VmZmVjdHMvVHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvY29yZS9yZWFkeUV4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvdXJsLWVzY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9zZWxlY3Rvci1zaXp6bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvdmFyL2RvY3VtZW50RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9lZmZlY3RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2NvcmUvcmVhZHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvZWZmZWN0cy9hbmltYXRlZFNlbGVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL2F0dHJpYnV0ZXMvdmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL3RyYXZlcnNpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvbWFuaXB1bGF0aW9uL3dyYXBNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvY3NzL3Zhci9ybnVtbm9ucHguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvdmFyL2Fyci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L3NyYy9zZXJpYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvY3NzL3Nob3dIaWRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL3Zhci9wdXNoLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9zcmMvY29yZS9zdXBwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvc3JjL3Zhci9nZXRQcm90by5qcyJdLCJuYW1lcyI6WyJkZWZpbmUiLCJmblRvU3RyaW5nIiwiY2FsbCIsIk9iamVjdCIsImRvY3VtZW50IiwicHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyIsInR5cGUiLCJzcmMiLCJub01vZHVsZSIsIkRPTUV2YWwiLCJjb2RlIiwiZG9jIiwibm9kZSIsImkiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50IiwidGV4dCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIkRhdGUiLCJub3ciLCJqUXVlcnkiLCJpc0Z1bmN0aW9uIiwicm5vdGh0bWx3aGl0ZSIsImxvY2F0aW9uIiwibm9uY2UiLCJycXVlcnkiLCJyMjAiLCJyaGFzaCIsInJhbnRpQ2FjaGUiLCJyaGVhZGVycyIsInJsb2NhbFByb3RvY29sIiwicm5vQ29udGVudCIsInJwcm90b2NvbCIsInByZWZpbHRlcnMiLCJ0cmFuc3BvcnRzIiwiYWxsVHlwZXMiLCJjb25jYXQiLCJvcmlnaW5BbmNob3IiLCJocmVmIiwiYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzIiwic3RydWN0dXJlIiwiZGF0YVR5cGVFeHByZXNzaW9uIiwiZnVuYyIsImRhdGFUeXBlIiwiZGF0YVR5cGVzIiwidG9Mb3dlckNhc2UiLCJtYXRjaCIsInNsaWNlIiwidW5zaGlmdCIsInB1c2giLCJpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyIsIm9wdGlvbnMiLCJvcmlnaW5hbE9wdGlvbnMiLCJqcVhIUiIsImluc3BlY3RlZCIsInNlZWtpbmdUcmFuc3BvcnQiLCJpbnNwZWN0Iiwic2VsZWN0ZWQiLCJlYWNoIiwiXyIsInByZWZpbHRlck9yRmFjdG9yeSIsImRhdGFUeXBlT3JUcmFuc3BvcnQiLCJhamF4RXh0ZW5kIiwidGFyZ2V0Iiwia2V5IiwiZGVlcCIsImZsYXRPcHRpb25zIiwiYWpheFNldHRpbmdzIiwidW5kZWZpbmVkIiwiZXh0ZW5kIiwiYWpheEhhbmRsZVJlc3BvbnNlcyIsInMiLCJyZXNwb25zZXMiLCJjdCIsImZpbmFsRGF0YVR5cGUiLCJmaXJzdERhdGFUeXBlIiwiY29udGVudHMiLCJzaGlmdCIsIm1pbWVUeXBlIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJ0ZXN0IiwiY29udmVydGVycyIsImFqYXhDb252ZXJ0IiwicmVzcG9uc2UiLCJpc1N1Y2Nlc3MiLCJjb252MiIsImN1cnJlbnQiLCJjb252IiwidG1wIiwicHJldiIsInJlc3BvbnNlRmllbGRzIiwiZGF0YUZpbHRlciIsInNwbGl0IiwidGhyb3dzIiwiZSIsInN0YXRlIiwiZXJyb3IiLCJkYXRhIiwiYWN0aXZlIiwibGFzdE1vZGlmaWVkIiwiZXRhZyIsInVybCIsImlzTG9jYWwiLCJwcm90b2NvbCIsImdsb2JhbCIsInByb2Nlc3NEYXRhIiwiYXN5bmMiLCJjb250ZW50VHlwZSIsImFjY2VwdHMiLCJodG1sIiwieG1sIiwianNvbiIsIlN0cmluZyIsIkpTT04iLCJwYXJzZSIsInBhcnNlWE1MIiwiY29udGV4dCIsImFqYXhTZXR1cCIsInNldHRpbmdzIiwiYWpheFByZWZpbHRlciIsImFqYXhUcmFuc3BvcnQiLCJhamF4IiwidHJhbnNwb3J0IiwiY2FjaGVVUkwiLCJyZXNwb25zZUhlYWRlcnNTdHJpbmciLCJyZXNwb25zZUhlYWRlcnMiLCJ0aW1lb3V0VGltZXIiLCJ1cmxBbmNob3IiLCJjb21wbGV0ZWQiLCJmaXJlR2xvYmFscyIsInVuY2FjaGVkIiwiY2FsbGJhY2tDb250ZXh0IiwiZ2xvYmFsRXZlbnRDb250ZXh0Iiwibm9kZVR5cGUiLCJqcXVlcnkiLCJldmVudCIsImRlZmVycmVkIiwiRGVmZXJyZWQiLCJjb21wbGV0ZURlZmVycmVkIiwiQ2FsbGJhY2tzIiwic3RhdHVzQ29kZSIsInJlcXVlc3RIZWFkZXJzIiwicmVxdWVzdEhlYWRlcnNOYW1lcyIsInN0ckFib3J0IiwicmVhZHlTdGF0ZSIsImV4ZWMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzZXRSZXF1ZXN0SGVhZGVyIiwibmFtZSIsInZhbHVlIiwib3ZlcnJpZGVNaW1lVHlwZSIsIm1hcCIsImFsd2F5cyIsInN0YXR1cyIsImFib3J0Iiwic3RhdHVzVGV4dCIsImZpbmFsVGV4dCIsImRvbmUiLCJwcm9taXNlIiwicmVwbGFjZSIsIm1ldGhvZCIsImNyb3NzRG9tYWluIiwiaG9zdCIsInBhcmFtIiwidHJhZGl0aW9uYWwiLCJ0cmlnZ2VyIiwidG9VcHBlckNhc2UiLCJoYXNDb250ZW50IiwibGVuZ3RoIiwiY2FjaGUiLCJpbmRleE9mIiwiaWZNb2RpZmllZCIsImhlYWRlcnMiLCJiZWZvcmVTZW5kIiwiYWRkIiwiY29tcGxldGUiLCJzdWNjZXNzIiwiZmFpbCIsInRpbWVvdXQiLCJ3aW5kb3ciLCJzZXRUaW1lb3V0Iiwic2VuZCIsIm5hdGl2ZVN0YXR1c1RleHQiLCJtb2RpZmllZCIsImNsZWFyVGltZW91dCIsInJlc29sdmVXaXRoIiwicmVqZWN0V2l0aCIsImZpcmVXaXRoIiwiZ2V0SlNPTiIsImNhbGxiYWNrIiwiZ2V0IiwiZ2V0U2NyaXB0IiwiaXNQbGFpbk9iamVjdCIsInN1cHBvcnQiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInhoclN1Y2Nlc3NTdGF0dXMiLCJ4aHJTdXBwb3J0ZWQiLCJjb3JzIiwiZXJyb3JDYWxsYmFjayIsIm9wZW4iLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwieGhyRmllbGRzIiwib25sb2FkIiwib25lcnJvciIsIm9uYWJvcnQiLCJvbnRpbWVvdXQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZVRleHQiLCJiaW5hcnkiLCJEYXRhIiwiZGF0YVByaXYiLCJxdWV1ZSIsImVsZW0iLCJBcnJheSIsImlzQXJyYXkiLCJhY2Nlc3MiLCJtYWtlQXJyYXkiLCJkZXF1ZXVlIiwic3RhcnRMZW5ndGgiLCJmbiIsImhvb2tzIiwiX3F1ZXVlSG9va3MiLCJuZXh0Iiwic3RvcCIsImVtcHR5IiwiZmlyZSIsInJlbW92ZSIsInNldHRlciIsImFyZ3VtZW50cyIsImNsZWFyUXVldWUiLCJvYmoiLCJjb3VudCIsImRlZmVyIiwiZWxlbWVudHMiLCJyZXNvbHZlIiwic3RyaXBBbmRDb2xsYXBzZSIsImdldENsYXNzIiwiZ2V0QXR0cmlidXRlIiwiY2xhc3Nlc1RvQXJyYXkiLCJhZGRDbGFzcyIsImNsYXNzZXMiLCJjdXIiLCJjdXJWYWx1ZSIsImNsYXp6IiwiaiIsImZpbmFsVmFsdWUiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVDbGFzcyIsImF0dHIiLCJ0b2dnbGVDbGFzcyIsInN0YXRlVmFsIiwiaXNWYWxpZFZhbHVlIiwiY2xhc3NOYW1lIiwic2VsZiIsImNsYXNzTmFtZXMiLCJoYXNDbGFzcyIsInNldCIsInNlbGVjdG9yIiwiaXNXaW5kb3ciLCJwbnVtIiwiY2FtZWxDYXNlIiwicmNzc051bSIsInJudW1ub25weCIsImNzc0V4cGFuZCIsImdldFN0eWxlcyIsInN3YXAiLCJjdXJDU1MiLCJhZGp1c3RDU1MiLCJhZGRHZXRIb29rSWYiLCJyZGlzcGxheXN3YXAiLCJyY3VzdG9tUHJvcCIsImNzc1Nob3ciLCJwb3NpdGlvbiIsInZpc2liaWxpdHkiLCJkaXNwbGF5IiwiY3NzTm9ybWFsVHJhbnNmb3JtIiwibGV0dGVyU3BhY2luZyIsImZvbnRXZWlnaHQiLCJjc3NQcmVmaXhlcyIsImVtcHR5U3R5bGUiLCJzdHlsZSIsInZlbmRvclByb3BOYW1lIiwiY2FwTmFtZSIsImZpbmFsUHJvcE5hbWUiLCJyZXQiLCJjc3NQcm9wcyIsInNldFBvc2l0aXZlTnVtYmVyIiwic3VidHJhY3QiLCJtYXRjaGVzIiwiTWF0aCIsIm1heCIsImJveE1vZGVsQWRqdXN0bWVudCIsImRpbWVuc2lvbiIsImJveCIsImlzQm9yZGVyQm94Iiwic3R5bGVzIiwiY29tcHV0ZWRWYWwiLCJleHRyYSIsImRlbHRhIiwiY3NzIiwiY2VpbCIsImdldFdpZHRoT3JIZWlnaHQiLCJ2YWwiLCJ2YWx1ZUlzQm9yZGVyQm94IiwiYm94U2l6aW5nUmVsaWFibGUiLCJwYXJzZUZsb2F0IiwiY3NzSG9va3MiLCJvcGFjaXR5IiwiY29tcHV0ZWQiLCJjc3NOdW1iZXIiLCJvcmlnTmFtZSIsImlzQ3VzdG9tUHJvcCIsImNsZWFyQ2xvbmVTdHlsZSIsInNldFByb3BlcnR5IiwibnVtIiwiaXNGaW5pdGUiLCJnZXRDbGllbnRSZWN0cyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwic2Nyb2xsYm94U2l6ZSIsIm1hcmdpbkxlZnQiLCJyZWxpYWJsZU1hcmdpbkxlZnQiLCJsZWZ0IiwibWFyZ2luIiwicGFkZGluZyIsImJvcmRlciIsInByZWZpeCIsInN1ZmZpeCIsImV4cGFuZCIsImV4cGFuZGVkIiwicGFydHMiLCJsZW4iLCJ0b2tlbnMiLCJqb2luIiwiYXJyIiwiZGVsYXkiLCJ0aW1lIiwiZngiLCJzcGVlZHMiLCJzZXRHbG9iYWxFdmFsIiwiZWxlbXMiLCJyZWZFbGVtZW50cyIsImwiLCJleHByIiwibmVlZHNDb250ZXh0IiwibiIsIm1hdGNoZWQiLCJuZXh0U2libGluZyIsImlzRG9tTm9kZUxpc3QiLCJ4IiwicHJvdG90eXBlVG9TdHJpbmciLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsInJlZ2V4IiwiTm9kZUxpc3QiLCJpc0RvbU5vZGUiLCJ3cmFwQWxsIiwid3JhcCIsIm93bmVyRG9jdW1lbnQiLCJlcSIsImNsb25lIiwiaW5zZXJ0QmVmb3JlIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJhcHBlbmQiLCJ3cmFwSW5uZXIiLCJodG1sSXNGdW5jdGlvbiIsInVud3JhcCIsInBhcmVudCIsIm5vdCIsInJlcGxhY2VXaXRoIiwiY2hpbGROb2RlcyIsInJmb2N1c2FibGUiLCJyY2xpY2thYmxlIiwicHJvcCIsInJlbW92ZVByb3AiLCJwcm9wRml4IiwiblR5cGUiLCJpc1hNTERvYyIsInByb3BIb29rcyIsInRhYkluZGV4IiwidGFiaW5kZXgiLCJmaW5kIiwicGFyc2VJbnQiLCJub2RlTmFtZSIsIm9wdFNlbGVjdGVkIiwic2VsZWN0ZWRJbmRleCIsInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkl0ZW0iLCJhcnJheSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsInRlYWxpZ2h0IiwiZmlsdGVyIiwicXVlcnkiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZXJyIiwiZG9jdW1lbnRFbGVtZW50Iiwib2Zmc2V0Iiwic2V0T2Zmc2V0IiwiY3VyUG9zaXRpb24iLCJjdXJMZWZ0IiwiY3VyQ1NTVG9wIiwiY3VyVG9wIiwiY3VyT2Zmc2V0IiwiY3VyQ1NTTGVmdCIsImNhbGN1bGF0ZVBvc2l0aW9uIiwiY3VyRWxlbSIsInByb3BzIiwidG9wIiwidXNpbmciLCJyZWN0Iiwid2luIiwiZGVmYXVsdFZpZXciLCJwYWdlWU9mZnNldCIsInBhZ2VYT2Zmc2V0Iiwib2Zmc2V0UGFyZW50IiwicGFyZW50T2Zmc2V0IiwiYm9keSIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJzY3JvbGxUbyIsInBpeGVsUG9zaXRpb24iLCJiYXNlVXJsIiwiY3VycmVudERpciIsInBhdGhuYW1lIiwiZml4ZWRDc3MiLCJmdWxsTWF0Y2giLCJvcmlnVXJsIiwidW5xdW90ZWRPcmlnVXJsIiwidHJpbSIsIm8iLCIkMSIsIm5ld1VybCIsInN0cmluZ2lmeSIsIk5vZGUiLCJFeHByIiwiZ2V0VGV4dCIsImlzWE1MIiwidG9rZW5pemUiLCJjb21waWxlIiwic2VsZWN0Iiwib3V0ZXJtb3N0Q29udGV4dCIsInNvcnRJbnB1dCIsImhhc0R1cGxpY2F0ZSIsInNldERvY3VtZW50IiwiZG9jRWxlbSIsImRvY3VtZW50SXNIVE1MIiwicmJ1Z2d5UVNBIiwicmJ1Z2d5TWF0Y2hlcyIsImNvbnRhaW5zIiwiZXhwYW5kbyIsInByZWZlcnJlZERvYyIsImRpcnJ1bnMiLCJjbGFzc0NhY2hlIiwiY3JlYXRlQ2FjaGUiLCJ0b2tlbkNhY2hlIiwiY29tcGlsZXJDYWNoZSIsInNvcnRPcmRlciIsImEiLCJiIiwiaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJwb3AiLCJwdXNoX25hdGl2ZSIsImxpc3QiLCJib29sZWFucyIsIndoaXRlc3BhY2UiLCJpZGVudGlmaWVyIiwiYXR0cmlidXRlcyIsInBzZXVkb3MiLCJyd2hpdGVzcGFjZSIsIlJlZ0V4cCIsInJ0cmltIiwicmNvbW1hIiwicmNvbWJpbmF0b3JzIiwicmF0dHJpYnV0ZVF1b3RlcyIsInJwc2V1ZG8iLCJyaWRlbnRpZmllciIsIm1hdGNoRXhwciIsInJpbnB1dHMiLCJyaGVhZGVyIiwicm5hdGl2ZSIsInJxdWlja0V4cHIiLCJyc2libGluZyIsInJ1bmVzY2FwZSIsImZ1bmVzY2FwZSIsImVzY2FwZWQiLCJlc2NhcGVkV2hpdGVzcGFjZSIsImhpZ2giLCJmcm9tQ2hhckNvZGUiLCJyY3NzZXNjYXBlIiwiZmNzc2VzY2FwZSIsImNoIiwiYXNDb2RlUG9pbnQiLCJjaGFyQ29kZUF0IiwidW5sb2FkSGFuZGxlciIsImRpc2FibGVkQW5jZXN0b3IiLCJhZGRDb21iaW5hdG9yIiwiZGlzYWJsZWQiLCJlbHMiLCJTaXp6bGUiLCJyZXN1bHRzIiwic2VlZCIsIm0iLCJuaWQiLCJncm91cHMiLCJuZXdTZWxlY3RvciIsIm5ld0NvbnRleHQiLCJnZXRFbGVtZW50QnlJZCIsImlkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwicXNhIiwidG9TZWxlY3RvciIsInRlc3RDb250ZXh0IiwicXNhRXJyb3IiLCJyZW1vdmVBdHRyaWJ1dGUiLCJrZXlzIiwiY2FjaGVMZW5ndGgiLCJtYXJrRnVuY3Rpb24iLCJhc3NlcnQiLCJlbCIsImFkZEhhbmRsZSIsImF0dHJzIiwiaGFuZGxlciIsImF0dHJIYW5kbGUiLCJzaWJsaW5nQ2hlY2siLCJkaWZmIiwic291cmNlSW5kZXgiLCJjcmVhdGVJbnB1dFBzZXVkbyIsImNyZWF0ZUJ1dHRvblBzZXVkbyIsImNyZWF0ZURpc2FibGVkUHNldWRvIiwiaXNEaXNhYmxlZCIsImNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8iLCJhcmd1bWVudCIsIm1hdGNoSW5kZXhlcyIsImhhc0NvbXBhcmUiLCJzdWJXaW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJjcmVhdGVDb21tZW50IiwiZ2V0QnlJZCIsImdldEVsZW1lbnRzQnlOYW1lIiwiYXR0cklkIiwiZ2V0QXR0cmlidXRlTm9kZSIsInRhZyIsImlubmVySFRNTCIsImlucHV0IiwibWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwib01hdGNoZXNTZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwiZGlzY29ubmVjdGVkTWF0Y2giLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsImFkb3duIiwiYnVwIiwiY29tcGFyZSIsInNvcnREZXRhY2hlZCIsImF1cCIsImFwIiwiYnAiLCJzcGVjaWZpZWQiLCJlc2NhcGUiLCJzZWwiLCJtc2ciLCJ1bmlxdWVTb3J0IiwiZHVwbGljYXRlcyIsImRldGVjdER1cGxpY2F0ZXMiLCJzb3J0U3RhYmxlIiwic29ydCIsInNwbGljZSIsInRleHRDb250ZW50IiwiZmlyc3RDaGlsZCIsIm5vZGVWYWx1ZSIsInNlbGVjdG9ycyIsImNyZWF0ZVBzZXVkbyIsInJlbGF0aXZlIiwiZmlyc3QiLCJwcmVGaWx0ZXIiLCJleGNlc3MiLCJ1bnF1b3RlZCIsIm5vZGVOYW1lU2VsZWN0b3IiLCJwYXR0ZXJuIiwib3BlcmF0b3IiLCJjaGVjayIsInJlc3VsdCIsIndoYXQiLCJsYXN0Iiwic2ltcGxlIiwiZm9yd2FyZCIsIm9mVHlwZSIsInVuaXF1ZUNhY2hlIiwib3V0ZXJDYWNoZSIsIm5vZGVJbmRleCIsInN0YXJ0IiwidXNlQ2FjaGUiLCJsYXN0Q2hpbGQiLCJ1bmlxdWVJRCIsInBzZXVkbyIsInNldEZpbHRlcnMiLCJpZHgiLCJtYXRjaGVyIiwidW5tYXRjaGVkIiwiaW5uZXJUZXh0IiwibGFuZyIsImVsZW1MYW5nIiwiaGFzaCIsImFjdGl2ZUVsZW1lbnQiLCJoYXNGb2N1cyIsImNoZWNrZWQiLCJyYWRpbyIsImNoZWNrYm94IiwiZmlsZSIsImltYWdlIiwic3VibWl0IiwicmVzZXQiLCJmaWx0ZXJzIiwicGFyc2VPbmx5Iiwic29GYXIiLCJwcmVGaWx0ZXJzIiwiY2FjaGVkIiwiY29tYmluYXRvciIsImJhc2UiLCJza2lwIiwiY2hlY2tOb25FbGVtZW50cyIsImRvbmVOYW1lIiwib2xkQ2FjaGUiLCJuZXdDYWNoZSIsImVsZW1lbnRNYXRjaGVyIiwibWF0Y2hlcnMiLCJtdWx0aXBsZUNvbnRleHRzIiwiY29udGV4dHMiLCJjb25kZW5zZSIsIm5ld1VubWF0Y2hlZCIsIm1hcHBlZCIsInNldE1hdGNoZXIiLCJwb3N0RmlsdGVyIiwicG9zdEZpbmRlciIsInBvc3RTZWxlY3RvciIsInRlbXAiLCJwcmVNYXAiLCJwb3N0TWFwIiwicHJlZXhpc3RpbmciLCJtYXRjaGVySW4iLCJtYXRjaGVyT3V0IiwibWF0Y2hlckZyb21Ub2tlbnMiLCJjaGVja0NvbnRleHQiLCJsZWFkaW5nUmVsYXRpdmUiLCJpbXBsaWNpdFJlbGF0aXZlIiwibWF0Y2hDb250ZXh0IiwibWF0Y2hBbnlDb250ZXh0IiwibWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzIiwiZWxlbWVudE1hdGNoZXJzIiwic2V0TWF0Y2hlcnMiLCJieVNldCIsImJ5RWxlbWVudCIsInN1cGVyTWF0Y2hlciIsIm91dGVybW9zdCIsIm1hdGNoZWRDb3VudCIsInNldE1hdGNoZWQiLCJjb250ZXh0QmFja3VwIiwiZGlycnVuc1VuaXF1ZSIsInJhbmRvbSIsInRva2VuIiwiY29tcGlsZWQiLCJkZWZhdWx0VmFsdWUiLCJfc2l6emxlIiwibm9Db25mbGljdCIsImNsYXNzMnR5cGUiLCJmb2N1c2luIiwiZm9jdXMiLCJibHVyIiwib3JpZyIsImZpeCIsInNpbXVsYXRlIiwic3BlY2lhbCIsInNldHVwIiwiYXR0YWNoZXMiLCJ0ZWFyZG93biIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvcHQiLCJjaGVja09uIiwicmFkaW9WYWx1ZSIsIklkZW50aXR5IiwidiIsIlRocm93ZXIiLCJleCIsImFkb3B0VmFsdWUiLCJyZWplY3QiLCJub1ZhbHVlIiwidGhlbiIsInR1cGxlcyIsInBpcGUiLCJmbnMiLCJuZXdEZWZlciIsInR1cGxlIiwicmV0dXJuZWQiLCJwcm9ncmVzcyIsIm5vdGlmeSIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsIm9uUHJvZ3Jlc3MiLCJtYXhEZXB0aCIsImRlcHRoIiwidGhhdCIsIm1pZ2h0VGhyb3ciLCJUeXBlRXJyb3IiLCJub3RpZnlXaXRoIiwiZXhjZXB0aW9uSG9vayIsInN0YWNrVHJhY2UiLCJnZXRTdGFja0hvb2siLCJzdGF0ZVN0cmluZyIsImRpc2FibGUiLCJsb2NrIiwid2hlbiIsInNpbmdsZVZhbHVlIiwicmVtYWluaW5nIiwicmVzb2x2ZUNvbnRleHRzIiwicmVzb2x2ZVZhbHVlcyIsIm1hc3RlciIsInVwZGF0ZUZ1bmMiLCJmcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJkaXYiLCJjaGVja0Nsb25lIiwiY2xvbmVOb2RlIiwibm9DbG9uZUNoZWNrZWQiLCJ1c2VTb3VyY2VNYXAiLCJpdGVtIiwiY29udGVudCIsImNzc1dpdGhNYXBwaW5nVG9TdHJpbmciLCJtb2R1bGVzIiwibWVkaWFRdWVyeSIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIm9sZENhbGxiYWNrcyIsInJqc29ucCIsImpzb25wIiwianNvbnBDYWxsYmFjayIsIm9yaWdpbmFsU2V0dGluZ3MiLCJjYWxsYmFja05hbWUiLCJvdmVyd3JpdHRlbiIsInJlc3BvbnNlQ29udGFpbmVyIiwianNvblByb3AiLCJ1bnRpbCIsInRydW5jYXRlIiwiaXMiLCJ0b1R5cGUiLCJjaGFpbmFibGUiLCJlbXB0eUdldCIsInJhdyIsImJ1bGsiLCJyc2luZ2xlVGFnIiwicm9vdGpRdWVyeSIsImluaXQiLCJyb290IiwibWVyZ2UiLCJwYXJzZUhUTUwiLCJjb25zdHJ1Y3RvciIsInJlYWR5IiwiYmluZCIsInR5cGVzIiwidW5iaW5kIiwiZGVsZWdhdGUiLCJ1bmRlbGVnYXRlIiwicHJveHkiLCJndWlkIiwiaG9sZFJlYWR5IiwiaG9sZCIsInJlYWR5V2FpdCIsInBhcnNlSlNPTiIsImlzTnVtZXJpYyIsImlzTmFOIiwicmNoZWNrYWJsZVR5cGUiLCJydGFnTmFtZSIsInJzY3JpcHRUeXBlIiwid3JhcE1hcCIsImdldEFsbCIsImJ1aWxkRnJhZ21lbnQiLCJkYXRhVXNlciIsImFjY2VwdERhdGEiLCJyeGh0bWxUYWciLCJybm9Jbm5lcmh0bWwiLCJyY2hlY2tlZCIsInJjbGVhblNjcmlwdCIsIm1hbmlwdWxhdGlvblRhcmdldCIsImNoaWxkcmVuIiwiZGlzYWJsZVNjcmlwdCIsInJlc3RvcmVTY3JpcHQiLCJjbG9uZUNvcHlFdmVudCIsImRlc3QiLCJwZGF0YU9sZCIsInBkYXRhQ3VyIiwidWRhdGFPbGQiLCJ1ZGF0YUN1ciIsImV2ZW50cyIsImhhc0RhdGEiLCJoYW5kbGUiLCJmaXhJbnB1dCIsImRvbU1hbmlwIiwiY29sbGVjdGlvbiIsImlnbm9yZWQiLCJzY3JpcHRzIiwiaGFzU2NyaXB0cyIsImlOb0Nsb25lIiwidmFsdWVJc0Z1bmN0aW9uIiwiaW5kZXgiLCJfZXZhbFVybCIsImtlZXBEYXRhIiwibm9kZXMiLCJjbGVhbkRhdGEiLCJodG1sUHJlZmlsdGVyIiwiZGF0YUFuZEV2ZW50cyIsImRlZXBEYXRhQW5kRXZlbnRzIiwic3JjRWxlbWVudHMiLCJkZXN0RWxlbWVudHMiLCJpblBhZ2UiLCJyZW1vdmVFdmVudCIsImRldGFjaCIsInByZXBlbmQiLCJiZWZvcmUiLCJhZnRlciIsImluQXJyYXkiLCJyZXBsYWNlQ2hpbGQiLCJhcHBlbmRUbyIsInByZXBlbmRUbyIsImluc2VydEFmdGVyIiwicmVwbGFjZUFsbCIsIm9yaWdpbmFsIiwiaW5zZXJ0IiwicHVzaFN0YWNrIiwiZ2xvYmFsRXZhbCIsImNoYXJzZXQiLCJzY3JpcHRDaGFyc2V0IiwiZXZ0IiwicmJveFN0eWxlIiwibWluV2lkdGgiLCJtYXhXaWR0aCIsImdldFByb3BlcnR5VmFsdWUiLCJwaXhlbEJveFN0eWxlcyIsInJuZWVkc0NvbnRleHQiLCJ3aW5ub3ciLCJxdWFsaWZpZXIiLCJncmVwIiwiaGlkZGVuIiwidmlzaWJsZSIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0Iiwibm9HbG9iYWwiLCJfalF1ZXJ5IiwiXyQiLCIkIiwib3duZXIiLCJjb21wdXRlU3R5bGVUZXN0cyIsImNvbnRhaW5lciIsImNzc1RleHQiLCJkaXZTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJwaXhlbFBvc2l0aW9uVmFsIiwicmVsaWFibGVNYXJnaW5MZWZ0VmFsIiwicm91bmRQaXhlbE1lYXN1cmVzIiwicmlnaHQiLCJwaXhlbEJveFN0eWxlc1ZhbCIsImJveFNpemluZ1JlbGlhYmxlVmFsIiwic2Nyb2xsYm94U2l6ZVZhbCIsIm1lYXN1cmUiLCJyb3VuZCIsImJhY2tncm91bmRDbGlwIiwic2NvcGUiLCJGdW5jdGlvbiIsIlRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJjbG9zZSIsImNsZWFyRm4iLCJfaWQiLCJfY2xlYXJGbiIsInVucmVmIiwicmVmIiwiZW5yb2xsIiwibXNlY3MiLCJfaWRsZVRpbWVvdXRJZCIsIl9pZGxlVGltZW91dCIsInVuZW5yb2xsIiwiX3VucmVmQWN0aXZlIiwib25UaW1lb3V0IiwiX29uVGltZW91dCIsInJlcXVpcmUiLCJzZXRJbW1lZGlhdGUiLCJjbGVhckltbWVkaWF0ZSIsInVpZCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiaXNFbXB0eU9iamVjdCIsInBvbHlmaWxsIiwiY2xvY2siLCJjdXJyZW50VGltZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJrZXlFdmVudCIsInJtb3VzZUV2ZW50IiwicnR5cGVuYW1lc3BhY2UiLCJyZXR1cm5UcnVlIiwicmV0dXJuRmFsc2UiLCJzYWZlQWN0aXZlRWxlbWVudCIsIm9uZSIsIm9yaWdGbiIsImhhbmRsZU9iakluIiwiZXZlbnRIYW5kbGUiLCJ0IiwiaGFuZGxlT2JqIiwiaGFuZGxlcnMiLCJuYW1lc3BhY2VzIiwib3JpZ1R5cGUiLCJlbGVtRGF0YSIsInRyaWdnZXJlZCIsImRpc3BhdGNoIiwiZGVsZWdhdGVUeXBlIiwiYmluZFR5cGUiLCJuYW1lc3BhY2UiLCJkZWxlZ2F0ZUNvdW50IiwibWFwcGVkVHlwZXMiLCJvcmlnQ291bnQiLCJuYXRpdmVFdmVudCIsImhhbmRsZXJRdWV1ZSIsImRlbGVnYXRlVGFyZ2V0IiwicHJlRGlzcGF0Y2giLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImN1cnJlbnRUYXJnZXQiLCJpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCIsInJuYW1lc3BhY2UiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsInBvc3REaXNwYXRjaCIsIm1hdGNoZWRIYW5kbGVycyIsIm1hdGNoZWRTZWxlY3RvcnMiLCJidXR0b24iLCJhZGRQcm9wIiwiaG9vayIsIkV2ZW50IiwiZW51bWVyYWJsZSIsIm9yaWdpbmFsRXZlbnQiLCJ3cml0YWJsZSIsImxvYWQiLCJub0J1YmJsZSIsImNsaWNrIiwiX2RlZmF1bHQiLCJiZWZvcmV1bmxvYWQiLCJyZXR1cm5WYWx1ZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJyZWxhdGVkVGFyZ2V0IiwidGltZVN0YW1wIiwiaXNTaW11bGF0ZWQiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJhbHRLZXkiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImNoYW5nZWRUb3VjaGVzIiwiY3RybEtleSIsImRldGFpbCIsImV2ZW50UGhhc2UiLCJtZXRhS2V5IiwicGFnZVgiLCJwYWdlWSIsInNoaWZ0S2V5IiwidmlldyIsImNoYXJDb2RlIiwia2V5Q29kZSIsImJ1dHRvbnMiLCJjbGllbnRYIiwiY2xpZW50WSIsIm9mZnNldFgiLCJvZmZzZXRZIiwicG9pbnRlcklkIiwicG9pbnRlclR5cGUiLCJzY3JlZW5YIiwic2NyZWVuWSIsInRhcmdldFRvdWNoZXMiLCJ0b0VsZW1lbnQiLCJ0b3VjaGVzIiwid2hpY2giLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsInBvaW50ZXJlbnRlciIsInBvaW50ZXJsZWF2ZSIsInJlbGF0ZWQiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsInJlZ2lzdGVySW1tZWRpYXRlIiwidGFzayIsInJ1bklmUHJlc2VudCIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsImltcG9ydFNjcmlwdHMiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwib25tZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4Iiwib25HbG9iYWxNZXNzYWdlIiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsImdldFByb3RvdHlwZU9mIiwiaG92ZXIiLCJmbk92ZXIiLCJmbk91dCIsIlZ1ZSIsImNyZWF0ZSIsIl9fVlVFX0hPVF9NQVBfXyIsImluc3RhbGxlZCIsImlzQnJvd3NlcmlmeSIsImluaXRIb29rTmFtZSIsImluc3RhbGwiLCJ2dWUiLCJicm93c2VyaWZ5IiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJOdW1iZXIiLCJjb25maWciLCJfbGlmZWN5Y2xlSG9va3MiLCJjb21wYXRpYmxlIiwiY29uc29sZSIsIndhcm4iLCJjcmVhdGVSZWNvcmQiLCJDdG9yIiwibWFrZU9wdGlvbnNIb3QiLCJpbnN0YW5jZXMiLCJpc1JlY29yZGVkIiwiZnVuY3Rpb25hbCIsInJlbmRlciIsImgiLCJjdHgiLCJpbmplY3RIb29rIiwicmVjb3JkIiwiZXhpc3RpbmciLCJ0cnlXcmFwIiwiYXJnIiwidXBkYXRlT3B0aW9ucyIsIm9sZE9wdGlvbnMiLCJuZXdPcHRpb25zIiwia2V5JDEiLCJyZXJlbmRlciIsImZvckVhY2giLCJpbnN0YW5jZSIsIiRmb3JjZVVwZGF0ZSIsInN0YXRpY1JlbmRlckZucyIsIiRvcHRpb25zIiwiX3N0YXRpY1RyZWVzIiwicmVzdG9yZSIsInBhdGNoU2NvcGVkU2xvdHMiLCIkbmV4dFRpY2siLCJpbmplY3RTdHlsZXMiLCJfaW5qZWN0U3R5bGVzIiwiX0N0b3IiLCJyZWxvYWQiLCJleHRlbmRPcHRpb25zIiwibmV3Q3RvciIsInN1cGVyIiwiY2lkIiwicmVsZWFzZSIsIiR2bm9kZSIsIl91Iiwic2xvdHMiLCJwYXJhbXMiLCJrZWVwU2NyaXB0cyIsInBhcnNlZCIsImNyZWF0ZUhUTUxEb2N1bWVudCIsImltcGxlbWVudGF0aW9uIiwiZm9ybWF0IiwibWF0cml4IiwiaWRlbnRpdHkiLCJSYW5nZUVycm9yIiwiaW52ZXJzZSIsInMwIiwiczEiLCJzMiIsInMzIiwiczQiLCJzNSIsImM1IiwiYzQiLCJjMyIsImMyIiwiYzEiLCJjMCIsImRldGVybWluYW50IiwiSW5maW5pdHkiLCJtdWx0aXBseSIsImZtIiwicHJvZHVjdCIsInJvdyIsImsiLCJjb2wiLCJyb3RhdGUiLCJhbmdsZSIsInJvdGF0ZVoiLCJyb3RhdGVYIiwidGhldGEiLCJQSSIsImNvcyIsInNpbiIsInJvdGF0ZVkiLCJzY2FsZSIsInNjYWxhciIsInNjYWxhclkiLCJzY2FsZVgiLCJzY2FsZVkiLCJzY2FsZVoiLCJza2V3IiwiYW5nbGVYIiwiYW5nbGVZIiwidGhldGFYIiwidGFuIiwidGhldGFZIiwic2tld1giLCJza2V3WSIsInRyYW5zbGF0ZSIsImRpc3RhbmNlWCIsImRpc3RhbmNlWSIsInRyYW5zbGF0ZVgiLCJkaXN0YW5jZSIsInRyYW5zbGF0ZVkiLCJ0cmFuc2xhdGVaIiwiZGVmYXVsdHMiLCJkdXJhdGlvbiIsImVhc2luZyIsImludGVydmFsIiwib3JpZ2luIiwieSIsInoiLCJjbGVhbnVwIiwiZGVza3RvcCIsIm1vYmlsZSIsInVzZURlbGF5Iiwidmlld0ZhY3RvciIsInZpZXdPZmZzZXQiLCJib3R0b20iLCJhZnRlclJlc2V0IiwiYWZ0ZXJSZXZlYWwiLCJiZWZvcmVSZXNldCIsImJlZm9yZVJldmVhbCIsImZhaWx1cmUiLCJjbGFzc0xpc3QiLCJjbGVhbiIsImRlc3Ryb3kiLCJyZXZlYWwiLCJzeW5jIiwiaGVpZ2h0IiwibW91bnQiLCJpc09iamVjdCIsImxvZ2dlciIsIm1lc3NhZ2UiLCJkZXRhaWxzIiwiZGVidWciLCJyZXBvcnQiLCJsb2ciLCJyaW5zZSIsInRoaXMkMSIsInN0cnVjdCIsInN0YWxlIiwiZWxlbWVudElkcyIsInNlcXVlbmNlSWRzIiwiY29udGFpbmVySWRzIiwic3RvcmUiLCJlbGVtZW50Iiwic3RhbGVJZCIsImNvbnRhaW5lcklkIiwic2VxdWVuY2UiLCJjb250YWluZXJzIiwic2VxdWVuY2VzIiwiZGlydHkiLCJjYWxsYmFja1RpbWVyIiwiaW5saW5lIiwiZ2VuZXJhdGVkIiwiaGlzdG9yeSIsImdldFByZWZpeGVkQ3NzUHJvcCIsInByb3BlcnRpZXMiLCJnZXRQcmVmaXhlZENzc1Byb3BlcnR5IiwiY2xlYXJDYWNoZSIsImlubGluZVN0eWxlIiwiaW5saW5lTWF0Y2giLCJzb21lIiwiY29tcHV0ZWRPcGFjaXR5IiwiY29uZmlnT3BhY2l0eSIsInRyYW5zZm9ybWF0aW9ucyIsImF4aXMiLCJzdWJzdHIiLCJ1bml0IiwiZm9udFNpemUiLCJ0cmFuc2Zvcm0iLCJwcm9wZXJ0eSIsInJlZHVjZSIsImluaXRpYWwiLCJmaW5hbCIsInRyYW5zaXRpb24iLCJmcmFnbWVudHMiLCJkZWxheWVkIiwiaW5zdGFudCIsImNvbXBvc2VkIiwiY29tcG9zaXRpb24iLCJhbmltYXRlIiwiZm9yY2UiLCJwcmlzdGluZSIsInNlZW4iLCJzaG91bGRSZXZlYWwiLCJyZXZlYWxlZCIsInNob3VsZFJlc2V0IiwidHJpZ2dlclJldmVhbCIsInRyaWdnZXJSZXNldCIsInJlZ2lzdGVyQ2FsbGJhY2tzIiwiaXNEZWxheWVkIiwiYmVmb3JlQ2FsbGJhY2siLCJhZnRlckNhbGxiYWNrIiwiZWxhcHNlZCIsIm5leHRVbmlxdWVJZCIsInNlcSIsIlNlcXVlbmNlTW9kZWwiLCJtb2RlbHMiLCJuZXh0SWQiLCJtZW1iZXJzIiwibmV4dEVsZW1lbnQiLCJjdWUiLCJibG9ja2VkIiwiZm9vdCIsIlNlcXVlbmNlIiwiYWJzIiwiZGlyZWN0aW9uIiwiaW5pdGlhbGl6ZSIsImluaXRUaW1lb3V0IiwiaXNNb2JpbGUiLCJhZ2VudCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImRlZXBBc3NpZ24iLCJzeW5jaW5nIiwiY29udGFpbmVyQnVmZmVyIiwic2VxdWVuY2UkJDEiLCJlbGVtZW50QnVmZmVyIiwiZWxlbWVudE5vZGUiLCJleGlzdGluZ0lkIiwiY29udGFpbmVyTm9kZSIsImdldENvbnRhaW5lcklkIiwiY29sbGVjdGlvbnMiLCJtYXRoU2lnbiIsInNpZ24iLCJnZXRHZW9tZXRyeSIsImlzQ29udGFpbmVyIiwiY2xpZW50SGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0IiwiYm91bmRzIiwiZ2V0U2Nyb2xsZWQiLCJpc0VsZW1lbnRWaXNpYmxlIiwibWluIiwiZWxlbWVudEJvdW5kcyIsImdlb21ldHJ5IiwiY29udGFpbmVyQm91bmRzIiwic2Nyb2xsIiwicmFmIiwidHJhbnNmb3JtU3VwcG9ydGVkIiwidHJhbnNpdGlvblN1cHBvcnRlZCIsImJvdW5kRGVsZWdhdGUiLCJib3VuZERlc3Ryb3kiLCJib3VuZFJldmVhbCIsImJvdW5kQ2xlYW4iLCJib3VuZFN5bmMiLCJTY3JvbGxSZXZlYWwiLCJpbnZva2VkV2l0aG91dE5ldyIsImlzU3VwcG9ydGVkIiwiYnVmZmVyIiwicmh0bWwiLCJzZWxlY3Rpb24iLCJjcmVhdGVUZXh0Tm9kZSIsImNvbmRpdGlvbkZuIiwiaG9va0ZuIiwiY3JlYXRlT3B0aW9ucyIsIm9iamVjdCIsImZsYWciLCJmaXJpbmciLCJtZW1vcnkiLCJmaXJlZCIsImxvY2tlZCIsImZpcmluZ0luZGV4Iiwic3RvcE9uRmFsc2UiLCJ1bmlxdWUiLCJoYXMiLCJjb25kaXRpb24iLCJpc0Vycm9yIiwiVmlldyIsInJvdXRlclZpZXciLCIkY3JlYXRlRWxlbWVudCIsInJvdXRlIiwiJHJvdXRlIiwiX3JvdXRlclZpZXdDYWNoZSIsImluYWN0aXZlIiwiX3JvdXRlclJvb3QiLCJfaW5hY3RpdmUiLCIkcGFyZW50Iiwicm91dGVyVmlld0RlcHRoIiwiY29tcG9uZW50IiwiY29tcG9uZW50cyIsInJlZ2lzdGVyUm91dGVJbnN0YW5jZSIsInZtIiwicHJlcGF0Y2giLCJ2bm9kZSIsImNvbXBvbmVudEluc3RhbmNlIiwicHJvcHNUb1Bhc3MiLCJyZXNvbHZlUHJvcHMiLCJwYXRoIiwiZW5jb2RlUmVzZXJ2ZVJFIiwiZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyIiwiYyIsImNvbW1hUkUiLCJlbmNvZGUiLCJzdHIiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJyZXNvbHZlUXVlcnkiLCJleHRyYVF1ZXJ5IiwiX3BhcnNlUXVlcnkiLCJwYXJzZVF1ZXJ5IiwicGFyc2VkUXVlcnkiLCJyZXMiLCJzdHJpbmdpZnlRdWVyeSIsInZhbDIiLCJ0cmFpbGluZ1NsYXNoUkUiLCJjcmVhdGVSb3V0ZSIsInJlZGlyZWN0ZWRGcm9tIiwicm91dGVyIiwic3RyaW5naWZ5UXVlcnkkJDEiLCJtZXRhIiwiZnVsbFBhdGgiLCJnZXRGdWxsUGF0aCIsImZvcm1hdE1hdGNoIiwiZnJlZXplIiwiU1RBUlQiLCJfc3RyaW5naWZ5UXVlcnkiLCJpc1NhbWVSb3V0ZSIsImlzT2JqZWN0RXF1YWwiLCJhS2V5cyIsImJLZXlzIiwiZXZlcnkiLCJhVmFsIiwiYlZhbCIsImlzSW5jbHVkZWRSb3V0ZSIsInF1ZXJ5SW5jbHVkZXMiLCJ0b1R5cGVzIiwiZXZlbnRUeXBlcyIsIkxpbmsiLCJ0byIsInJlcXVpcmVkIiwiZXhhY3QiLCJCb29sZWFuIiwiYWN0aXZlQ2xhc3MiLCJleGFjdEFjdGl2ZUNsYXNzIiwiJHJvdXRlciIsImdsb2JhbEFjdGl2ZUNsYXNzIiwibGlua0FjdGl2ZUNsYXNzIiwiZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyIsImxpbmtFeGFjdEFjdGl2ZUNsYXNzIiwiYWN0aXZlQ2xhc3NGYWxsYmFjayIsImV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFjayIsImNvbXBhcmVUYXJnZXQiLCJndWFyZEV2ZW50IiwiY2xhc3MiLCJmaW5kQW5jaG9yIiwiJHNsb3RzIiwiaXNTdGF0aWMiLCJhRGF0YSIsImFBdHRycyIsImNoaWxkIiwiX1Z1ZSIsImlzRGVmIiwicmVnaXN0ZXJJbnN0YW5jZSIsImNhbGxWYWwiLCJfcGFyZW50Vm5vZGUiLCJtaXhpbiIsImJlZm9yZUNyZWF0ZSIsIl9yb3V0ZXIiLCJ1dGlsIiwiZGVmaW5lUmVhY3RpdmUiLCJkZXN0cm95ZWQiLCJfcm91dGUiLCJzdHJhdHMiLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJiZWZvcmVSb3V0ZUVudGVyIiwiYmVmb3JlUm91dGVMZWF2ZSIsImJlZm9yZVJvdXRlVXBkYXRlIiwiY3JlYXRlZCIsImluQnJvd3NlciIsInJlc29sdmVQYXRoIiwiZmlyc3RDaGFyIiwiY2hhckF0Iiwic3RhY2siLCJzZWdtZW50cyIsInNlZ21lbnQiLCJwYXJzZVBhdGgiLCJoYXNoSW5kZXgiLCJxdWVyeUluZGV4IiwiY2xlYW5QYXRoIiwiaXNhcnJheSIsInBhdGhUb1JlZ2V4cF8xIiwicGF0aFRvUmVnZXhwIiwicGFyc2VfMSIsImNvbXBpbGVfMSIsInRva2Vuc1RvRnVuY3Rpb25fMSIsInRva2Vuc1RvRnVuY3Rpb24iLCJ0b2tlbnNUb1JlZ0V4cF8xIiwidG9rZW5zVG9SZWdFeHAiLCJQQVRIX1JFR0VYUCIsImRlZmF1bHREZWxpbWl0ZXIiLCJkZWxpbWl0ZXIiLCJjYXB0dXJlIiwiZ3JvdXAiLCJtb2RpZmllciIsImFzdGVyaXNrIiwicGFydGlhbCIsInJlcGVhdCIsIm9wdGlvbmFsIiwiZXNjYXBlR3JvdXAiLCJlc2NhcGVTdHJpbmciLCJlbmNvZGVVUklDb21wb25lbnRQcmV0dHkiLCJlbmNvZGVVUkkiLCJlbmNvZGVBc3RlcmlzayIsIm9wdHMiLCJwcmV0dHkiLCJhdHRhY2hLZXlzIiwicmUiLCJmbGFncyIsInNlbnNpdGl2ZSIsInJlZ2V4cFRvUmVnZXhwIiwiYXJyYXlUb1JlZ2V4cCIsInJlZ2V4cCIsInN0cmluZ1RvUmVnZXhwIiwic3RyaWN0IiwiZW5kIiwiZW5kc1dpdGhEZWxpbWl0ZXIiLCJyZWdleHBDb21waWxlQ2FjaGUiLCJmaWxsUGFyYW1zIiwicm91dGVNc2ciLCJmaWxsZXIiLCJjcmVhdGVSb3V0ZU1hcCIsInJvdXRlcyIsIm9sZFBhdGhMaXN0Iiwib2xkUGF0aE1hcCIsIm9sZE5hbWVNYXAiLCJwYXRoTGlzdCIsInBhdGhNYXAiLCJuYW1lTWFwIiwiYWRkUm91dGVSZWNvcmQiLCJtYXRjaEFzIiwicGF0aFRvUmVnZXhwT3B0aW9ucyIsIm5vcm1hbGl6ZWRQYXRoIiwibm9ybWFsaXplUGF0aCIsImNhc2VTZW5zaXRpdmUiLCJjb21waWxlUm91dGVSZWdleCIsInJlZGlyZWN0IiwiYmVmb3JlRW50ZXIiLCJjaGlsZE1hdGNoQXMiLCJhbGlhcyIsImFsaWFzZXMiLCJhbGlhc1JvdXRlIiwibm9ybWFsaXplTG9jYXRpb24iLCJfbm9ybWFsaXplZCIsInJhd1BhdGgiLCJwYXJzZWRQYXRoIiwiYmFzZVBhdGgiLCJjcmVhdGVNYXRjaGVyIiwiYWRkUm91dGVzIiwiY3VycmVudFJvdXRlIiwiX2NyZWF0ZVJvdXRlIiwicGFyYW1OYW1lcyIsInJlY29yZCQxIiwibWF0Y2hSb3V0ZSIsIm9yaWdpbmFsUmVkaXJlY3QiLCJ0YXJnZXRSZWNvcmQiLCJyZXNvbHZlUmVjb3JkUGF0aCIsInJlc29sdmVkUGF0aCIsImFsaWFzZWRQYXRoIiwiYWxpYXNlZE1hdGNoIiwiYWxpYXNlZFJlY29yZCIsInBvc2l0aW9uU3RvcmUiLCJzZXR1cFNjcm9sbCIsInJlcGxhY2VTdGF0ZSIsImdldFN0YXRlS2V5Iiwic2F2ZVNjcm9sbFBvc2l0aW9uIiwic2V0U3RhdGVLZXkiLCJoYW5kbGVTY3JvbGwiLCJmcm9tIiwiaXNQb3AiLCJhcHAiLCJiZWhhdmlvciIsInNjcm9sbEJlaGF2aW9yIiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJzaG91bGRTY3JvbGwiLCJzY3JvbGxUb1Bvc2l0aW9uIiwiY2F0Y2giLCJnZXRFbGVtZW50UG9zaXRpb24iLCJkb2NFbCIsImRvY1JlY3QiLCJlbFJlY3QiLCJpc1ZhbGlkUG9zaXRpb24iLCJpc051bWJlciIsIm5vcm1hbGl6ZVBvc2l0aW9uIiwibm9ybWFsaXplT2Zmc2V0IiwicXVlcnlTZWxlY3RvciIsInN1cHBvcnRzUHVzaFN0YXRlIiwidWEiLCJUaW1lIiwicGVyZm9ybWFuY2UiLCJfa2V5IiwiZ2VuS2V5IiwidG9GaXhlZCIsInB1c2hTdGF0ZSIsInJ1blF1ZXVlIiwiY2IiLCJzdGVwIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50cyIsImhhc0FzeW5jIiwicGVuZGluZyIsImZsYXRNYXBDb21wb25lbnRzIiwiZGVmIiwicmVzb2x2ZWREZWYiLCJpc0VTTW9kdWxlIiwicmVzb2x2ZWQiLCJyZWFzb24iLCJjb21wIiwiZmxhdHRlbiIsImhhc1N5bWJvbCIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiY2FsbGVkIiwiSGlzdG9yeSIsIm5vcm1hbGl6ZUJhc2UiLCJyZWFkeUNicyIsInJlYWR5RXJyb3JDYnMiLCJlcnJvckNicyIsImxpc3RlbiIsIm9uUmVhZHkiLCJlcnJvckNiIiwib25FcnJvciIsInRyYW5zaXRpb25UbyIsIm9uQ29tcGxldGUiLCJvbkFib3J0IiwiY29uZmlybVRyYW5zaXRpb24iLCJ1cGRhdGVSb3V0ZSIsImVuc3VyZVVSTCIsInJlc29sdmVRdWV1ZSIsInVwZGF0ZWQiLCJkZWFjdGl2YXRlZCIsImFjdGl2YXRlZCIsImV4dHJhY3RMZWF2ZUd1YXJkcyIsImJlZm9yZUhvb2tzIiwiZXh0cmFjdFVwZGF0ZUhvb2tzIiwiaXRlcmF0b3IiLCJwb3N0RW50ZXJDYnMiLCJpc1ZhbGlkIiwiZW50ZXJHdWFyZHMiLCJleHRyYWN0RW50ZXJHdWFyZHMiLCJyZXNvbHZlSG9va3MiLCJhZnRlckhvb2tzIiwiYmFzZUVsIiwiZXh0cmFjdEd1YXJkcyIsInJlY29yZHMiLCJyZXZlcnNlIiwiZ3VhcmRzIiwiZ3VhcmQiLCJleHRyYWN0R3VhcmQiLCJiaW5kR3VhcmQiLCJib3VuZFJvdXRlR3VhcmQiLCJjYnMiLCJiaW5kRW50ZXJHdWFyZCIsInJvdXRlRW50ZXJHdWFyZCIsInBvbGwiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsIkhUTUw1SGlzdG9yeSIsIkhpc3RvcnkkJDEiLCJleHBlY3RTY3JvbGwiLCJzdXBwb3J0c1Njcm9sbCIsImluaXRMb2NhdGlvbiIsImdldExvY2F0aW9uIiwiX19wcm90b19fIiwiZ28iLCJmcm9tUm91dGUiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJkZWNvZGVVUkkiLCJzZWFyY2giLCJIYXNoSGlzdG9yeSIsImZhbGxiYWNrIiwiY2hlY2tGYWxsYmFjayIsImVuc3VyZVNsYXNoIiwic2V0dXBMaXN0ZW5lcnMiLCJnZXRIYXNoIiwicmVwbGFjZUhhc2giLCJwdXNoSGFzaCIsImdldFVybCIsIkFic3RyYWN0SGlzdG9yeSIsInRhcmdldEluZGV4IiwiVnVlUm91dGVyIiwiYXBwcyIsIm1vZGUiLCJwcm90b3R5cGVBY2Nlc3NvcnMiLCJzZXR1cEhhc2hMaXN0ZW5lciIsImJlZm9yZUVhY2giLCJyZWdpc3Rlckhvb2siLCJiZWZvcmVSZXNvbHZlIiwiYWZ0ZXJFYWNoIiwiYmFjayIsImdldE1hdGNoZWRDb21wb25lbnRzIiwiY3JlYXRlSHJlZiIsIm5vcm1hbGl6ZWRUbyIsImRlZmluZVByb3BlcnRpZXMiLCJ1c2UiLCJybXNQcmVmaXgiLCJyZGFzaEFscGhhIiwiZmNhbWVsQ2FzZSIsImFsbCIsImxldHRlciIsInN0cmluZyIsIm9wZW5lciIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsInJmb2N1c01vcnBoIiwic3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2siLCJvbmx5SGFuZGxlcnMiLCJidWJibGVUeXBlIiwib250eXBlIiwibGFzdEVsZW1lbnQiLCJldmVudFBhdGgiLCJpc1RyaWdnZXIiLCJwYXJlbnRXaW5kb3ciLCJ0cmlnZ2VySGFuZGxlciIsIkhlaWdodCIsIldpZHRoIiwiZGVmYXVsdEV4dHJhIiwiZnVuY05hbWUiLCJsaXN0VG9TdHlsZXMiLCJwYXJlbnRJZCIsIm5ld1N0eWxlcyIsIm1lZGlhIiwicGFydCIsImdldFByb3RvIiwiT2JqZWN0RnVuY3Rpb25TdHJpbmciLCJ0b0FycmF5IiwicHJldk9iamVjdCIsImNvcHkiLCJjb3B5SXNBcnJheSIsImlzUmVhZHkiLCJwcm90byIsImlzQXJyYXlMaWtlIiwic2Vjb25kIiwiaW52ZXJ0IiwiY2FsbGJhY2tJbnZlcnNlIiwiY2FsbGJhY2tFeHBlY3QiLCJyZXJyb3JOYW1lcyIsImVtcHR5T2JqZWN0IiwiaXNVbmRlZiIsImlzVHJ1ZSIsImlzRmFsc2UiLCJpc1ByaW1pdGl2ZSIsIl90b1N0cmluZyIsInRvUmF3VHlwZSIsImlzUmVnRXhwIiwiaXNWYWxpZEFycmF5SW5kZXgiLCJmbG9vciIsImlzUHJvbWlzZSIsInRvTnVtYmVyIiwibWFrZU1hcCIsImV4cGVjdHNMb3dlckNhc2UiLCJpc0J1aWx0SW5UYWciLCJpc1Jlc2VydmVkQXR0cmlidXRlIiwiY2FjaGVkRm4iLCJoaXQiLCJjYW1lbGl6ZVJFIiwiY2FtZWxpemUiLCJjYXBpdGFsaXplIiwiaHlwaGVuYXRlUkUiLCJoeXBoZW5hdGUiLCJwb2x5ZmlsbEJpbmQiLCJib3VuZEZuIiwiX2xlbmd0aCIsIm5hdGl2ZUJpbmQiLCJfZnJvbSIsInRvT2JqZWN0Iiwibm8iLCJnZW5TdGF0aWNLZXlzIiwic3RhdGljS2V5cyIsImxvb3NlRXF1YWwiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJpc0FycmF5QSIsImlzQXJyYXlCIiwiZ2V0VGltZSIsImtleXNBIiwia2V5c0IiLCJsb29zZUluZGV4T2YiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsImRldnRvb2xzIiwiZXJyb3JIYW5kbGVyIiwid2FybkhhbmRsZXIiLCJpZ25vcmVkRWxlbWVudHMiLCJrZXlDb2RlcyIsImlzUmVzZXJ2ZWRUYWciLCJpc1Jlc2VydmVkQXR0ciIsImlzVW5rbm93bkVsZW1lbnQiLCJnZXRUYWdOYW1lc3BhY2UiLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsIm11c3RVc2VQcm9wIiwidW5pY29kZVJlZ0V4cCIsImlzUmVzZXJ2ZWQiLCJiYWlsUkUiLCJoYXNQcm90byIsImluV2VleCIsIldYRW52aXJvbm1lbnQiLCJwbGF0Zm9ybSIsIndlZXhQbGF0Zm9ybSIsIlVBIiwiaXNJRSIsImlzSUU5IiwiaXNFZGdlIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZSIsImlzUGhhbnRvbUpTIiwiaXNGRiIsIm5hdGl2ZVdhdGNoIiwid2F0Y2giLCJzdXBwb3J0c1Bhc3NpdmUiLCJfaXNTZXJ2ZXIiLCJpc1NlcnZlclJlbmRlcmluZyIsIlZVRV9FTlYiLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaXNOYXRpdmUiLCJSZWZsZWN0Iiwib3duS2V5cyIsIl9TZXQiLCJTZXQiLCJjbGVhciIsInRpcCIsImdlbmVyYXRlQ29tcG9uZW50VHJhY2UiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNsYXNzaWZ5UkUiLCJjbGFzc2lmeSIsInRyYWNlIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsIl9pc1Z1ZSIsIl9jb21wb25lbnRUYWciLCJfX2ZpbGUiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwiRGVwIiwic3VicyIsImFkZFN1YiIsInN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsImFkZERlcCIsInVwZGF0ZSIsInRhcmdldFN0YWNrIiwicHVzaFRhcmdldCIsInBvcFRhcmdldCIsIlZOb2RlIiwiZWxtIiwiY29tcG9uZW50T3B0aW9ucyIsImFzeW5jRmFjdG9yeSIsIm5zIiwiZm5Db250ZXh0IiwiZm5PcHRpb25zIiwiZm5TY29wZUlkIiwiaXNSb290SW5zZXJ0IiwiaXNDb21tZW50IiwiaXNDbG9uZWQiLCJpc09uY2UiLCJhc3luY01ldGEiLCJpc0FzeW5jUGxhY2Vob2xkZXIiLCJjcmVhdGVFbXB0eVZOb2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsImNsb25lZCIsImFycmF5UHJvdG8iLCJhcnJheU1ldGhvZHMiLCJtZXRob2RzVG9QYXRjaCIsIm11dGF0b3IiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInNob3VsZE9ic2VydmUiLCJ0b2dnbGVPYnNlcnZpbmciLCJPYnNlcnZlciIsInZtQ291bnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIml0ZW1zIiwib2JzZXJ2ZSIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJzaGFsbG93IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0dGVyIiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsImRlbCIsInByb3BzRGF0YSIsImRlZmF1bHRTdHJhdCIsIm1lcmdlRGF0YSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJkZWR1cGVIb29rcyIsIm1lcmdlQXNzZXRzIiwiYXNzZXJ0T2JqZWN0VHlwZSIsIm1ldGhvZHMiLCJpbmplY3QiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwidmFsaWRhdGVDb21wb25lbnROYW1lIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwiZGVmJCQxIiwibWVyZ2VPcHRpb25zIiwiX2Jhc2UiLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwiYWJzZW50IiwiYm9vbGVhbkluZGV4IiwiZ2V0VHlwZUluZGV4Iiwic3RyaW5nSW5kZXgiLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZE9ic2VydmUiLCJhc3NlcnRQcm9wIiwiX3Byb3BzIiwiZ2V0VHlwZSIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJnZXRJbnZhbGlkVHlwZU1lc3NhZ2UiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwiaXNTYW1lVHlwZSIsInJlY2VpdmVkVHlwZSIsImV4cGVjdGVkVmFsdWUiLCJzdHlsZVZhbHVlIiwicmVjZWl2ZWRWYWx1ZSIsImlzRXhwbGljYWJsZSIsImlzQm9vbGVhbiIsImV4cGxpY2l0VHlwZXMiLCJoYW5kbGVFcnJvciIsImluZm8iLCJlcnJvckNhcHR1cmVkIiwiZ2xvYmFsSGFuZGxlRXJyb3IiLCJpbnZva2VXaXRoRXJyb3JIYW5kbGluZyIsIl9oYW5kbGVkIiwibG9nRXJyb3IiLCJpc1VzaW5nTWljcm9UYXNrIiwiY2FsbGJhY2tzIiwiZmx1c2hDYWxsYmFja3MiLCJjb3BpZXMiLCJ0aW1lckZ1bmMiLCJQcm9taXNlIiwicCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJjb3VudGVyIiwib2JzZXJ2ZXIiLCJ0ZXh0Tm9kZSIsImNoYXJhY3RlckRhdGEiLCJfcmVzb2x2ZSIsIm1hcmsiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJ3YXJuUmVzZXJ2ZWRQcmVmaXgiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiJGRhdGEiLCJnZXRIYW5kbGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsInNlZW5PYmplY3RzIiwidHJhdmVyc2UiLCJfdHJhdmVyc2UiLCJpc0EiLCJpc0Zyb3plbiIsImRlcElkIiwibm9ybWFsaXplRXZlbnQiLCJwYXNzaXZlIiwib25jZSQkMSIsImNyZWF0ZUZuSW52b2tlciIsImludm9rZXIiLCJhcmd1bWVudHMkMSIsInVwZGF0ZUxpc3RlbmVycyIsIm9sZE9uIiwicmVtb3ZlJCQxIiwiY3JlYXRlT25jZUhhbmRsZXIiLCJvbGQiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwia2V5SW5Mb3dlckNhc2UiLCJjaGVja1Byb3AiLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwibGFzdEluZGV4IiwiX2lzVkxpc3QiLCJpbml0UHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwicmVzb2x2ZUluamVjdCIsInByb3ZpZGVLZXkiLCJwcm92aWRlRGVmYXVsdCIsInJlc29sdmVTbG90cyIsInNsb3QiLCJuYW1lJDEiLCJpc1doaXRlc3BhY2UiLCJub3JtYWxpemVTY29wZWRTbG90cyIsIm5vcm1hbFNsb3RzIiwicHJldlNsb3RzIiwiaGFzTm9ybWFsU2xvdHMiLCJpc1N0YWJsZSIsIiRzdGFibGUiLCIka2V5IiwiJGhhc05vcm1hbCIsIm5vcm1hbGl6ZVNjb3BlZFNsb3QiLCJrZXkkMiIsInByb3h5Tm9ybWFsU2xvdCIsInJlbmRlckxpc3QiLCJyZW5kZXJTbG90IiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsIiRzY29wZWRTbG90cyIsInJlc29sdmVGaWx0ZXIiLCJpc0tleU5vdE1hdGNoIiwiZXhwZWN0IiwiYWN0dWFsIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5LZXlDb2RlIiwiZXZlbnRLZXlOYW1lIiwiYnVpbHRJbktleU5hbWUiLCJtYXBwZWRLZXlDb2RlIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwibG9vcCIsImRvbVByb3BzIiwiY2FtZWxpemVkS2V5IiwiaHlwaGVuYXRlZEtleSIsIiRldmVudCIsInJlbmRlclN0YXRpYyIsImlzSW5Gb3IiLCJtYXJrU3RhdGljIiwibWFya09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImJpbmRPYmplY3RMaXN0ZW5lcnMiLCJvdXJzIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiaGFzRHluYW1pY0tleXMiLCJjb250ZW50SGFzaEtleSIsImJpbmREeW5hbWljS2V5cyIsImJhc2VPYmoiLCJ2YWx1ZXMiLCJwcmVwZW5kTW9kaWZpZXIiLCJzeW1ib2wiLCJpbnN0YWxsUmVuZGVySGVscGVycyIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX2ciLCJfZCIsIl9wIiwiRnVuY3Rpb25hbFJlbmRlckNvbnRleHQiLCJjb250ZXh0Vm0iLCJfb3JpZ2luYWwiLCJpc0NvbXBpbGVkIiwiX2NvbXBpbGVkIiwibmVlZE5vcm1hbGl6YXRpb24iLCJpbmplY3Rpb25zIiwic2NvcGVkU2xvdHMiLCJfc2NvcGVJZCIsIl9jIiwiZCIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJtZXJnZVByb3BzIiwicmVuZGVyQ29udGV4dCIsImNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQiLCJ2bm9kZXMiLCJkZXZ0b29sc01ldGEiLCJjb21wb25lbnRWTm9kZUhvb2tzIiwiaHlkcmF0aW5nIiwiX2lzRGVzdHJveWVkIiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiYWN0aXZlSW5zdGFuY2UiLCIkbW91bnQiLCJvbGRWbm9kZSIsInVwZGF0ZUNoaWxkQ29tcG9uZW50IiwiX2lzTW91bnRlZCIsImNhbGxIb29rIiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiJGRlc3Ryb3kiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJiYXNlQ3RvciIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsIm5hdGl2ZU9uIiwiYWJzdHJhY3QiLCJpbnN0YWxsQ29tcG9uZW50SG9va3MiLCJfaXNDb21wb25lbnQiLCJpbmxpbmVUZW1wbGF0ZSIsInRvTWVyZ2UiLCJfbWVyZ2VkIiwibWVyZ2VIb29rJDEiLCJmMSIsImYyIiwiU0lNUExFX05PUk1BTElaRSIsIkFMV0FZU19OT1JNQUxJWkUiLCJub3JtYWxpemF0aW9uVHlwZSIsImFsd2F5c05vcm1hbGl6ZSIsIl9jcmVhdGVFbGVtZW50IiwicHJlIiwiYXBwbHlOUyIsInJlZ2lzdGVyRGVlcEJpbmRpbmdzIiwiaW5pdFJlbmRlciIsIl92bm9kZSIsInBhcmVudFZub2RlIiwiX3JlbmRlckNoaWxkcmVuIiwicGFyZW50RGF0YSIsImlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCIsIl9wYXJlbnRMaXN0ZW5lcnMiLCJjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UiLCJyZW5kZXJNaXhpbiIsIl9yZW5kZXIiLCJyZW5kZXJFcnJvciIsImVuc3VyZUN0b3IiLCJmYWN0b3J5IiwiZXJyb3JDb21wIiwib3duZXJzIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwidGltZXJMb2FkaW5nIiwidGltZXJUaW1lb3V0IiwiJG9uIiwiZm9yY2VSZW5kZXIiLCJyZW5kZXJDb21wbGV0ZWQiLCJnZXRGaXJzdENvbXBvbmVudENoaWxkIiwiaW5pdEV2ZW50cyIsIl9ldmVudHMiLCJfaGFzSG9va0V2ZW50IiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwicmVtb3ZlJDEiLCIkb2ZmIiwiX3RhcmdldCIsIm9uY2VIYW5kbGVyIiwib2xkTGlzdGVuZXJzIiwiZXZlbnRzTWl4aW4iLCJob29rUkUiLCIkb25jZSIsImkkMSIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJzZXRBY3RpdmVJbnN0YW5jZSIsInByZXZBY3RpdmVJbnN0YW5jZSIsImluaXRMaWZlY3ljbGUiLCIkY2hpbGRyZW4iLCIkcmVmcyIsIl93YXRjaGVyIiwiX2RpcmVjdEluYWN0aXZlIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwicmVzdG9yZUFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX192dWVfXyIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIldhdGNoZXIiLCJyZW5kZXJDaGlsZHJlbiIsIm5ld1Njb3BlZFNsb3RzIiwib2xkU2NvcGVkU2xvdHMiLCJoYXNEeW5hbWljU2NvcGVkU2xvdCIsIm5lZWRzRm9yY2VVcGRhdGUiLCIkYXR0cnMiLCIkbGlzdGVuZXJzIiwicHJvcEtleXMiLCJfcHJvcEtleXMiLCJpc0luSW5hY3RpdmVUcmVlIiwiZGlyZWN0IiwiTUFYX1VQREFURV9DT1VOVCIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiY3VycmVudEZsdXNoVGltZXN0YW1wIiwiZ2V0Tm93IiwiY3JlYXRlRXZlbnQiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInVzZXIiLCJleHByZXNzaW9uIiwiYWN0aXZhdGVkUXVldWUiLCJ1cGRhdGVkUXVldWUiLCJjYWxsQWN0aXZhdGVkSG9va3MiLCJjYWxsVXBkYXRlZEhvb2tzIiwicXVldWVXYXRjaGVyIiwidWlkJDIiLCJleHBPckZuIiwiaXNSZW5kZXJXYXRjaGVyIiwibGF6eSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwiY2xlYW51cERlcHMiLCJvbGRWYWx1ZSIsImV2YWx1YXRlIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwic291cmNlS2V5IiwicHJveHlHZXR0ZXIiLCJwcm94eVNldHRlciIsImluaXRTdGF0ZSIsImluaXRQcm9wcyIsImluaXRNZXRob2RzIiwiaW5pdERhdGEiLCJpbml0Q29tcHV0ZWQiLCJpbml0V2F0Y2giLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJpc1NTUiIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsInNob3VsZENhY2hlIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVHZXR0ZXJJbnZva2VyIiwiY29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVXYXRjaGVyIiwiJHdhdGNoIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwidWlkJDMiLCJpbml0TWl4aW4iLCJfaW5pdCIsImluaXRJbnRlcm5hbENvbXBvbmVudCIsIl9zZWxmIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImxhdGVzdCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJpbml0VXNlIiwicGx1Z2luIiwiaW5zdGFsbGVkUGx1Z2lucyIsIl9pbnN0YWxsZWRQbHVnaW5zIiwiaW5pdE1peGluJDEiLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJTdWIiLCJWdWVDb21wb25lbnQiLCJpbml0UHJvcHMkMSIsImluaXRDb21wdXRlZCQxIiwiQ29tcCIsImluaXRBc3NldFJlZ2lzdGVycyIsImRlZmluaXRpb24iLCJnZXRDb21wb25lbnROYW1lIiwicHJ1bmVDYWNoZSIsImtlZXBBbGl2ZUluc3RhbmNlIiwiY2FjaGVkTm9kZSIsInBydW5lQ2FjaGVFbnRyeSIsImNhY2hlZCQkMSIsInBhdHRlcm5UeXBlcyIsIktlZXBBbGl2ZSIsImluY2x1ZGUiLCJleGNsdWRlIiwibW91bnRlZCIsInJlZiQxIiwiYnVpbHRJbkNvbXBvbmVudHMiLCJpbml0R2xvYmFsQVBJIiwiY29uZmlnRGVmIiwiZGVsZXRlIiwib2JzZXJ2YWJsZSIsInNzckNvbnRleHQiLCJhY2NlcHRWYWx1ZSIsImlzRW51bWVyYXRlZEF0dHIiLCJpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUiLCJjb252ZXJ0RW51bWVyYXRlZFZhbHVlIiwiaXNGYWxzeUF0dHJWYWx1ZSIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImdlbkNsYXNzRm9yVm5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJkeW5hbWljQ2xhc3MiLCJzdHJpbmdpZnlDbGFzcyIsInN0cmluZ2lmeUFycmF5Iiwic3RyaW5naWZ5T2JqZWN0Iiwic3RyaW5naWZpZWQiLCJuYW1lc3BhY2VNYXAiLCJzdmciLCJtYXRoIiwiaXNIVE1MVGFnIiwiaXNTVkciLCJpc1ByZVRhZyIsInVua25vd25FbGVtZW50Q2FjaGUiLCJIVE1MVW5rbm93bkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzVGV4dElucHV0VHlwZSIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJtdWx0aXBsZSIsImNyZWF0ZUVsZW1lbnROUyIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwic2V0VGV4dENvbnRlbnQiLCJzZXRTdHlsZVNjb3BlIiwic2NvcGVJZCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaXNVbmtub3duRWxlbWVudCQkMSIsImluVlByZSIsImlnbm9yZSIsImNyZWF0aW5nRWxtSW5WUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwicGFyZW50RWxtIiwicmVmRWxtIiwibmVzdGVkIiwib3duZXJBcnJheSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsImFjdGl2YXRlIiwicmVmJCQxIiwiY2hlY2tEdXBsaWNhdGVLZXlzIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInJtIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwicmVtb3ZlT25seSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwidm5vZGVUb01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImZpbmRJZHhJbk9sZCIsInNlZW5LZXlzIiwiaHlkcmF0ZSIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJoeWRyYXRpb25CYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImNoaWxkcmVuTWF0Y2giLCJmdWxsSW52b2tlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJvbGRFbG0iLCJfbGVhdmVDYiIsInBhdGNoYWJsZSIsImkkMiIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJjYWxsSG9vayQxIiwib2xkQXJnIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsImluaGVyaXRBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiYmFzZVNldEF0dHIiLCJzZXRBdHRyaWJ1dGVOUyIsIl9faWVwaCIsImJsb2NrZXIiLCJ1cGRhdGVDbGFzcyIsIm9sZERhdGEiLCJjbHMiLCJ0cmFuc2l0aW9uQ2xhc3MiLCJfdHJhbnNpdGlvbkNsYXNzZXMiLCJfcHJldkNsYXNzIiwia2xhc3MiLCJ2YWxpZERpdmlzaW9uQ2hhclJFIiwicGFyc2VGaWx0ZXJzIiwiZXhwIiwiaW5TaW5nbGUiLCJpbkRvdWJsZSIsImluVGVtcGxhdGVTdHJpbmciLCJpblJlZ2V4IiwiY3VybHkiLCJzcXVhcmUiLCJwYXJlbiIsImxhc3RGaWx0ZXJJbmRleCIsInB1c2hGaWx0ZXIiLCJ3cmFwRmlsdGVyIiwiYmFzZVdhcm4iLCJyYW5nZSIsInBsdWNrTW9kdWxlRnVuY3Rpb24iLCJkeW5hbWljIiwicmFuZ2VTZXRJdGVtIiwicGxhaW4iLCJhZGRBdHRyIiwiZHluYW1pY0F0dHJzIiwiYWRkUmF3QXR0ciIsImF0dHJzTWFwIiwiYXR0cnNMaXN0IiwiYWRkRGlyZWN0aXZlIiwiaXNEeW5hbWljQXJnIiwicHJlcGVuZE1vZGlmaWVyTWFya2VyIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsInByZXZlbnQiLCJtaWRkbGUiLCJuYXRpdmUiLCJuYXRpdmVFdmVudHMiLCJuZXdIYW5kbGVyIiwiZ2V0UmF3QmluZGluZ0F0dHIiLCJyYXdBdHRyc01hcCIsImdldEJpbmRpbmdBdHRyIiwiZ2V0U3RhdGljIiwiZHluYW1pY1ZhbHVlIiwiZ2V0QW5kUmVtb3ZlQXR0ciIsInN0YXRpY1ZhbHVlIiwicmVtb3ZlRnJvbU1hcCIsImdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4IiwiZ2VuQ29tcG9uZW50TW9kZWwiLCJudW1iZXIiLCJiYXNlVmFsdWVFeHByZXNzaW9uIiwidmFsdWVFeHByZXNzaW9uIiwiYXNzaWdubWVudCIsImdlbkFzc2lnbm1lbnRDb2RlIiwicGFyc2VNb2RlbCIsImNociIsImluZGV4JDEiLCJleHByZXNzaW9uUG9zIiwiZXhwcmVzc2lvbkVuZFBvcyIsImxhc3RJbmRleE9mIiwiZW9mIiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0IiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJ3YXJuJDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiX3dhcm4iLCJnZW5TZWxlY3QiLCJnZW5DaGVja2JveE1vZGVsIiwiZ2VuUmFkaW9Nb2RlbCIsImdlbkRlZmF1bHRNb2RlbCIsInZhbHVlQmluZGluZyIsInRydWVWYWx1ZUJpbmRpbmciLCJmYWxzZVZhbHVlQmluZGluZyIsInNlbGVjdGVkVmFsIiwidmFsdWUkMSIsInR5cGVCaW5kaW5nIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJjaGFuZ2UiLCJ0YXJnZXQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyJDEiLCJyZW1vdmUkMiIsInVzZU1pY3JvdGFza0ZpeCIsImFkZCQxIiwiYXR0YWNoZWRUaW1lc3RhbXAiLCJfd3JhcHBlciIsInVwZGF0ZURPTUxpc3RlbmVycyIsInN2Z0NvbnRhaW5lciIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNOb3RJbkZvY3VzQW5kRGlydHkiLCJpc0RpcnR5V2l0aE1vZGlmaWVycyIsIm5vdEluRm9jdXMiLCJfdk1vZGlmaWVycyIsInBhcnNlU3R5bGVUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsIm5vcm1hbGl6ZWROYW1lIiwibm9ybWFsaXplIiwidmVuZG9yTmFtZXMiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsIndoaXRlc3BhY2VSRSIsInRhciIsInJlc29sdmVUcmFuc2l0aW9uIiwiYXV0b0Nzc1RyYW5zaXRpb24iLCJlbnRlckNsYXNzIiwiZW50ZXJUb0NsYXNzIiwiZW50ZXJBY3RpdmVDbGFzcyIsImxlYXZlQ2xhc3MiLCJsZWF2ZVRvQ2xhc3MiLCJsZWF2ZUFjdGl2ZUNsYXNzIiwiaGFzVHJhbnNpdGlvbiIsIlRSQU5TSVRJT04iLCJBTklNQVRJT04iLCJ0cmFuc2l0aW9uUHJvcCIsInRyYW5zaXRpb25FbmRFdmVudCIsImFuaW1hdGlvblByb3AiLCJhbmltYXRpb25FbmRFdmVudCIsIm9udHJhbnNpdGlvbmVuZCIsIm9ud2Via2l0dHJhbnNpdGlvbmVuZCIsIm9uYW5pbWF0aW9uZW5kIiwib253ZWJraXRhbmltYXRpb25lbmQiLCJuZXh0RnJhbWUiLCJhZGRUcmFuc2l0aW9uQ2xhc3MiLCJ0cmFuc2l0aW9uQ2xhc3NlcyIsInJlbW92ZVRyYW5zaXRpb25DbGFzcyIsIndoZW5UcmFuc2l0aW9uRW5kcyIsImdldFRyYW5zaXRpb25JbmZvIiwicHJvcENvdW50IiwiZW5kZWQiLCJvbkVuZCIsInRyYW5zZm9ybVJFIiwidHJhbnNpdGlvbkRlbGF5cyIsInRyYW5zaXRpb25EdXJhdGlvbnMiLCJ0cmFuc2l0aW9uVGltZW91dCIsImdldFRpbWVvdXQiLCJhbmltYXRpb25EZWxheXMiLCJhbmltYXRpb25EdXJhdGlvbnMiLCJhbmltYXRpb25UaW1lb3V0IiwiaGFzVHJhbnNmb3JtIiwiZGVsYXlzIiwiZHVyYXRpb25zIiwidG9NcyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJhZnRlckVudGVyIiwiZW50ZXJDYW5jZWxsZWQiLCJiZWZvcmVBcHBlYXIiLCJhcHBlYXIiLCJhZnRlckFwcGVhciIsImFwcGVhckNhbmNlbGxlZCIsInRyYW5zaXRpb25Ob2RlIiwiaXNBcHBlYXIiLCJzdGFydENsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwiZGlyZWN0aXZlIiwiX3ZPcHRpb25zIiwic2V0U2VsZWN0ZWQiLCJnZXRWYWx1ZSIsIm9uQ29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25FbmQiLCJwcmV2T3B0aW9ucyIsImN1ck9wdGlvbnMiLCJuZWVkUmVzZXQiLCJoYXNOb01hdGNoaW5nT3B0aW9uIiwiYWN0dWFsbHlTZXRTZWxlY3RlZCIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJnZXRSZWFsQ2hpbGQiLCJjb21wT3B0aW9ucyIsImV4dHJhY3RUcmFuc2l0aW9uRGF0YSIsInBsYWNlaG9sZGVyIiwicmF3Q2hpbGQiLCJoYXNQYXJlbnRUcmFuc2l0aW9uIiwiaXNTYW1lQ2hpbGQiLCJvbGRDaGlsZCIsImlzTm90VGV4dE5vZGUiLCJpc1ZTaG93RGlyZWN0aXZlIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJiZWZvcmVNb3VudCIsImtlcHQiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwicmVtb3ZlZCIsImMkMSIsInBvcyIsImhhc01vdmUiLCJjYWxsUGVuZGluZ0NicyIsInJlY29yZFBvc2l0aW9uIiwiYXBwbHlUcmFuc2xhdGlvbiIsIl9yZWZsb3ciLCJtb3ZlZCIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwiZHkiLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJwYXJzZVRleHQiLCJ0YWdSRSIsInJhd1Rva2VucyIsInRva2VuVmFsdWUiLCJ0cmFuc2Zvcm1Ob2RlIiwiY2xhc3NCaW5kaW5nIiwiZ2VuRGF0YSIsImtsYXNzJDEiLCJ0cmFuc2Zvcm1Ob2RlJDEiLCJzdHlsZUJpbmRpbmciLCJnZW5EYXRhJDEiLCJzdHlsZSQxIiwiZGVjb2RlciIsImhlIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYXR0cmlidXRlIiwiZHluYW1pY0FyZ0F0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsImlzUGxhaW5UZXh0RWxlbWVudCIsInJlQ2FjaGUiLCJkZWNvZGluZ01hcCIsImVuY29kZWRBdHRyIiwiZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMiLCJpc0lnbm9yZU5ld2xpbmVUYWciLCJzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUiLCJkZWNvZGVBdHRyIiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJleHBlY3RIVE1MIiwiaXNVbmFyeVRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJzaG91bGRLZWVwQ29tbWVudCIsInN1YnN0cmluZyIsImFkdmFuY2UiLCJjb25kaXRpb25hbEVuZCIsImRvY3R5cGVNYXRjaCIsImVuZFRhZ01hdGNoIiwiY3VySW5kZXgiLCJwYXJzZUVuZFRhZyIsInN0YXJ0VGFnTWF0Y2giLCJwYXJzZVN0YXJ0VGFnIiwiaGFuZGxlU3RhcnRUYWciLCJyZXN0IiwiY2hhcnMiLCJlbmRUYWdMZW5ndGgiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwicmVzdCQxIiwidW5hcnlTbGFzaCIsInVuYXJ5Iiwic2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmIiwib3V0cHV0U291cmNlUmFuZ2UiLCJsb3dlckNhc2VkVGFnIiwibG93ZXJDYXNlZFRhZ05hbWUiLCJvblJFIiwiZGlyUkUiLCJmb3JBbGlhc1JFIiwiZm9ySXRlcmF0b3JSRSIsInN0cmlwUGFyZW5zUkUiLCJkeW5hbWljQXJnUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJzbG90UkUiLCJsaW5lQnJlYWtSRSIsIndoaXRlc3BhY2VSRSQxIiwiaW52YWxpZEF0dHJpYnV0ZVJFIiwiZGVjb2RlSFRNTENhY2hlZCIsImVtcHR5U2xvdFNjb3BlVG9rZW4iLCJ3YXJuJDIiLCJ0cmFuc2Zvcm1zIiwicHJlVHJhbnNmb3JtcyIsInBvc3RUcmFuc2Zvcm1zIiwicGxhdGZvcm1Jc1ByZVRhZyIsInBsYXRmb3JtTXVzdFVzZVByb3AiLCJwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSIsIm1heWJlQ29tcG9uZW50IiwiY3JlYXRlQVNURWxlbWVudCIsIm1ha2VBdHRyc01hcCIsInByZXNlcnZlV2hpdGVzcGFjZSIsIndoaXRlc3BhY2VPcHRpb24iLCJjdXJyZW50UGFyZW50IiwiaW5QcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImNsb3NlRWxlbWVudCIsInRyaW1FbmRpbmdXaGl0ZXNwYWNlIiwicHJvY2Vzc2VkIiwicHJvY2Vzc0VsZW1lbnQiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJjaGVja1Jvb3RDb25zdHJhaW50cyIsImFkZElmQ29uZGl0aW9uIiwiYmxvY2siLCJmb3JiaWRkZW4iLCJwcm9jZXNzSWZDb25kaXRpb25zIiwic2xvdFNjb3BlIiwic2xvdFRhcmdldCIsImxhc3ROb2RlIiwiY29tbWVudHMiLCJzdGFydCQxIiwiZ3VhcmRJRVNWR0J1ZyIsImN1bXVsYXRlZCIsImlzRm9yYmlkZGVuVGFnIiwicHJvY2Vzc1ByZSIsInByb2Nlc3NSYXdBdHRycyIsInByb2Nlc3NGb3IiLCJwcm9jZXNzSWYiLCJwcm9jZXNzT25jZSIsImVuZCQxIiwiaXNUZXh0VGFnIiwicHJvY2Vzc0tleSIsInByb2Nlc3NSZWYiLCJwcm9jZXNzU2xvdENvbnRlbnQiLCJwcm9jZXNzU2xvdE91dGxldCIsInByb2Nlc3NDb21wb25lbnQiLCJwcm9jZXNzQXR0cnMiLCJmb3IiLCJpdGVyYXRvcjIiLCJpdGVyYXRvcjEiLCJjaGVja0luRm9yIiwicGFyc2VGb3IiLCJpbk1hdGNoIiwiaXRlcmF0b3JNYXRjaCIsImZpbmRQcmV2RWxlbWVudCIsImlmQ29uZGl0aW9ucyIsInNsb3RUYXJnZXREeW5hbWljIiwic2xvdEJpbmRpbmciLCJnZXRTbG90TmFtZSIsInNsb3RCaW5kaW5nJDEiLCJkeW5hbWljJDEiLCJzbG90Q29udGFpbmVyIiwic2xvdE5hbWUiLCJzeW5jR2VuIiwiaXNEeW5hbWljIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsImNhbWVsIiwiYXJnTWF0Y2giLCJjaGVja0ZvckFsaWFzTW9kZWwiLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsIl9lbCIsInByZVRyYW5zZm9ybU5vZGUiLCJpZkNvbmRpdGlvbiIsImlmQ29uZGl0aW9uRXh0cmEiLCJoYXNFbHNlIiwiZWxzZUlmQ29uZGl0aW9uIiwiYnJhbmNoMCIsImNsb25lQVNURWxlbWVudCIsImJyYW5jaDEiLCJicmFuY2gyIiwibW9kZWwkMSIsIm1vZHVsZXMkMSIsImRpcmVjdGl2ZXMkMSIsImJhc2VPcHRpb25zIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJsJDEiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJmbkludm9rZVJFIiwic2ltcGxlUGF0aFJFIiwiZXNjIiwidGFiIiwic3BhY2UiLCJ1cCIsImRvd24iLCJrZXlOYW1lcyIsImdlbkd1YXJkIiwibW9kaWZpZXJDb2RlIiwiY3RybCIsImFsdCIsImdlbkhhbmRsZXJzIiwic3RhdGljSGFuZGxlcnMiLCJkeW5hbWljSGFuZGxlcnMiLCJoYW5kbGVyQ29kZSIsImdlbkhhbmRsZXIiLCJpc01ldGhvZFBhdGgiLCJpc0Z1bmN0aW9uRXhwcmVzc2lvbiIsImlzRnVuY3Rpb25JbnZvY2F0aW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwia2V5TW9kaWZpZXIiLCJnZW5LZXlGaWx0ZXIiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwia2V5TmFtZSIsIndyYXBMaXN0ZW5lcnMiLCJiaW5kJDEiLCJ3cmFwRGF0YSIsImJhc2VEaXJlY3RpdmVzIiwiY2xvYWsiLCJDb2RlZ2VuU3RhdGUiLCJkYXRhR2VuRm5zIiwib25jZUlkIiwiZ2VuZXJhdGUiLCJhc3QiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSQyIiwib3JpZ2luYWxQcmVTdGF0ZSIsImFsdEdlbiIsImFsdEVtcHR5IiwiZ2VuSWZDb25kaXRpb25zIiwiY29uZGl0aW9ucyIsImdlblRlcm5hcnlFeHAiLCJhbHRIZWxwZXIiLCJnZW5EaXJlY3RpdmVzIiwiZ2VuUHJvcHMiLCJnZW5TY29wZWRTbG90cyIsImdlbklubGluZVRlbXBsYXRlIiwiaGFzUnVudGltZSIsIm5lZWRSdW50aW1lIiwiZ2VuIiwiaW5saW5lUmVuZGVyRm5zIiwiY29udGFpbnNTbG90Q2hpbGQiLCJuZWVkc0tleSIsImdlbmVyYXRlZFNsb3RzIiwiZ2VuU2NvcGVkU2xvdCIsImlzTGVnYWN5U3ludGF4IiwicmV2ZXJzZVByb3h5IiwiY2hlY2tTa2lwIiwiYWx0R2VuRWxlbWVudCIsImFsdEdlbk5vZGUiLCJlbCQxIiwibm9ybWFsaXphdGlvblR5cGUkMSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlbkNvbW1lbnQiLCJnZW5UZXh0IiwidHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzIiwiYmluZCQkMSIsImNvbXBvbmVudE5hbWUiLCJzdGF0aWNQcm9wcyIsImR5bmFtaWNQcm9wcyIsInByb2hpYml0ZWRLZXl3b3JkUkUiLCJ1bmFyeU9wZXJhdG9yc1JFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0aXBwZWQiLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsImdlbmVyYXRlQ29kZUZyYW1lIiwibGluZXMiLCJyZXBlYXQkMSIsImxpbmVMZW5ndGgiLCJwYWQiLCJsZW5ndGgkMSIsImNyZWF0ZUZ1bmN0aW9uIiwiZXJyb3JzIiwiY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiIsImNvbXBpbGVUb0Z1bmN0aW9ucyIsIndhcm4kJDEiLCJ0aXBzIiwiZm5HZW5FcnJvcnMiLCJjcmVhdGVDb21waWxlckNyZWF0b3IiLCJiYXNlQ29tcGlsZSIsImNyZWF0ZUNvbXBpbGVyIiwiZmluYWxPcHRpb25zIiwibGVhZGluZ1NwYWNlTGVuZ3RoIiwiZ2V0U2hvdWxkRGVjb2RlIiwiaWRUb1RlbXBsYXRlIiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwicmJyYWNlIiwicm11bHRpRGFzaCIsImRhdGFBdHRyIiwicmVtb3ZlRGF0YSIsIl9yZW1vdmVEYXRhIiwiYm9vbEhvb2siLCJyZW1vdmVBdHRyIiwiYXR0ckhvb2tzIiwiYm9vbCIsImF0dHJOYW1lcyIsImxvd2VyY2FzZU5hbWUiLCJ2YWx1ZVBhcnRzIiwidHdlZW4iLCJhZGp1c3RlZCIsIm1heEl0ZXJhdGlvbnMiLCJjdXJyZW50VmFsdWUiLCJpbml0aWFsSW5Vbml0IiwiVHdlZW4iLCJwZXJjZW50IiwiZWFzZWQiLCJsaW5lYXIiLCJzd2luZyIsInJlYWR5RXhjZXB0aW9uIiwibmVlZFF1b3RlcyIsImVzY2FwZVNlbGVjdG9yIiwiaXNIaWRkZW5XaXRoaW5UcmVlIiwic2hvd0hpZGUiLCJmeE5vdyIsImluUHJvZ3Jlc3MiLCJyZnh0eXBlcyIsInJydW4iLCJzY2hlZHVsZSIsInRpY2siLCJjcmVhdGVGeE5vdyIsImdlbkZ4IiwiaW5jbHVkZVdpZHRoIiwiY3JlYXRlVHdlZW4iLCJhbmltYXRpb24iLCJBbmltYXRpb24iLCJ0d2VlbmVycyIsImRlZmF1bHRQcmVmaWx0ZXIiLCJ0b2dnbGUiLCJvbGRmaXJlIiwicHJvcFR3ZWVuIiwicmVzdG9yZURpc3BsYXkiLCJpc0JveCIsImFuaW0iLCJkYXRhU2hvdyIsInVucXVldWVkIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJwcm9wRmlsdGVyIiwic3BlY2lhbEVhc2luZyIsInN0b3BwZWQiLCJzdGFydFRpbWUiLCJ0d2VlbnMiLCJvcmlnaW5hbFByb3BlcnRpZXMiLCJnb3RvRW5kIiwidGltZXIiLCJ0d2VlbmVyIiwicHJlZmlsdGVyIiwic3BlZWQiLCJmYWRlVG8iLCJvcHRhbGwiLCJkb0FuaW1hdGlvbiIsImZpbmlzaCIsInN0b3BRdWV1ZSIsInRpbWVycyIsImNzc0ZuIiwic2xpZGVEb3duIiwic2xpZGVVcCIsInNsaWRlVG9nZ2xlIiwiZmFkZUluIiwiZmFkZU91dCIsImZhZGVUb2dnbGUiLCJzbG93IiwiZmFzdCIsInJlYWR5TGlzdCIsIndhaXQiLCJkb1Njcm9sbCIsImFuaW1hdGVkIiwicnJldHVybiIsInZhbEhvb2tzIiwib3B0aW9uU2V0Iiwic2libGluZ3MiLCJycGFyZW50c3ByZXYiLCJndWFyYW50ZWVkVW5pcXVlIiwidGFyZ2V0cyIsImNsb3Nlc3QiLCJwcmV2QWxsIiwiYWRkQmFjayIsInNpYmxpbmciLCJwYXJlbnRzIiwicGFyZW50c1VudGlsIiwibmV4dEFsbCIsIm5leHRVbnRpbCIsInByZXZVbnRpbCIsImNvbnRlbnREb2N1bWVudCIsInRoZWFkIiwidHIiLCJ0ZCIsIm9wdGdyb3VwIiwidGJvZHkiLCJ0Zm9vdCIsImNvbGdyb3VwIiwiY2FwdGlvbiIsInRoIiwicmJyYWNrZXQiLCJyQ1JMRiIsInJzdWJtaXR0ZXJUeXBlcyIsInJzdWJtaXR0YWJsZSIsImJ1aWxkUGFyYW1zIiwidmFsdWVPckZ1bmN0aW9uIiwic2VyaWFsaXplIiwic2VyaWFsaXplQXJyYXkiLCJkZWZhdWx0RGlzcGxheU1hcCIsImdldERlZmF1bHREaXNwbGF5IiwiaGlkZSIsImciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQUEscUVBQVEsWUFBVztBQUNsQjs7QUFFQSxTQUFTLHVCQUFUO0FBQ0EsQ0FKSztBQUFBLG9HQUFOLEM7Ozs7Ozs7Ozs7OztBQ0FBQSxpR0FBUSxDQUNQLCtDQURPLENBQUYsbUNBRUgsVUFBVUMsVUFBVixFQUF1QjtBQUN6Qjs7QUFFQSxTQUFPQSxVQUFVLENBQUNDLElBQVgsQ0FBaUJDLE1BQWpCLENBQVA7QUFDQSxDQU5LO0FBQUEsb0dBQU4sQzs7Ozs7Ozs7Ozs7O0FDQUFILGlHQUFRLENBQ1Asa0RBRE8sQ0FBRixtQ0FFSCxVQUFVSSxRQUFWLEVBQXFCO0FBQ3ZCOztBQUVBLE1BQUlDLHlCQUF5QixHQUFHO0FBQy9CQyxRQUFJLEVBQUUsSUFEeUI7QUFFL0JDLE9BQUcsRUFBRSxJQUYwQjtBQUcvQkMsWUFBUSxFQUFFO0FBSHFCLEdBQWhDOztBQU1BLFdBQVNDLE9BQVQsQ0FBa0JDLElBQWxCLEVBQXdCQyxHQUF4QixFQUE2QkMsSUFBN0IsRUFBb0M7QUFDbkNELE9BQUcsR0FBR0EsR0FBRyxJQUFJUCxRQUFiO0FBRUEsUUFBSVMsQ0FBSjtBQUFBLFFBQ0NDLE1BQU0sR0FBR0gsR0FBRyxDQUFDSSxhQUFKLENBQW1CLFFBQW5CLENBRFY7QUFHQUQsVUFBTSxDQUFDRSxJQUFQLEdBQWNOLElBQWQ7O0FBQ0EsUUFBS0UsSUFBTCxFQUFZO0FBQ1gsV0FBTUMsQ0FBTixJQUFXUix5QkFBWCxFQUF1QztBQUN0QyxZQUFLTyxJQUFJLENBQUVDLENBQUYsQ0FBVCxFQUFpQjtBQUNoQkMsZ0JBQU0sQ0FBRUQsQ0FBRixDQUFO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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQSxLQUFLLEtBQXdDLEVBQUUsRUFFN0M7O0FBRUYsUUFBUSxzQkFBaUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFB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R0FBaUIsNEJBQWpCO0FBQ0EsV0FBT2pJLElBQUksQ0FBQ3ZGLFVBQUwsQ0FBZ0I3TSxNQUFoQixLQUEyQixDQUFsQztBQUNBLEdBSjRCLEVBQTdCOztBQU1BLFNBQU95QixPQUFQO0FBQ0MsQ0FuQks7QUFBQSxvR0FBTixDOzs7Ozs7Ozs7Ozs7QUNBQXBNLHFFQUFRLFlBQVc7QUFDbEI7O0FBRUEsU0FBT0csTUFBTSxDQUFDMmlDLGNBQWQ7QUFDQSxDQUpLO0FBQUEsb0dBQU4sQyIsImZpbGUiOiJ2ZW5kb3JzLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZSggZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHJldHVybiAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuL2ZuVG9TdHJpbmdcIlxuXSwgZnVuY3Rpb24oIGZuVG9TdHJpbmcgKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHJldHVybiBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vdmFyL2RvY3VtZW50XCJcbl0sIGZ1bmN0aW9uKCBkb2N1bWVudCApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBkb2MsIG5vZGUgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblx0XHRcdFx0aWYgKCBub2RlWyBpIF0gKSB7XG5cdFx0XHRcdFx0c2NyaXB0WyBpIF0gPSBub2RlWyBpIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblx0cmV0dXJuIERPTUV2YWw7XG59ICk7XG4iLCJkZWZpbmUoIGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRyZXR1cm4gRGF0ZS5ub3coKTtcbn0gKTtcbiIsImRlZmluZSggW1xuXHRcIi4vY29yZVwiLFxuXHRcIi4vdmFyL2RvY3VtZW50XCIsXG5cdFwiLi92YXIvaXNGdW5jdGlvblwiLFxuXHRcIi4vdmFyL3Jub3RodG1sd2hpdGVcIixcblx0XCIuL2FqYXgvdmFyL2xvY2F0aW9uXCIsXG5cdFwiLi9hamF4L3Zhci9ub25jZVwiLFxuXHRcIi4vYWpheC92YXIvcnF1ZXJ5XCIsXG5cblx0XCIuL2NvcmUvaW5pdFwiLFxuXHRcIi4vYWpheC9wYXJzZVhNTFwiLFxuXHRcIi4vZXZlbnQvdHJpZ2dlclwiLFxuXHRcIi4vZGVmZXJyZWRcIixcblx0XCIuL3NlcmlhbGl6ZVwiIC8vIGpRdWVyeS5wYXJhbVxuXSwgZnVuY3Rpb24oIGpRdWVyeSwgZG9jdW1lbnQsIGlzRnVuY3Rpb24sIHJub3RodG1sd2hpdGUsIGxvY2F0aW9uLCBub25jZSwgcnF1ZXJ5ICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vY29yZVwiLFxuXHRcIi4uL3Zhci9zdXBwb3J0XCIsXG5cdFwiLi4vYWpheFwiXG5dLCBmdW5jdGlvbiggalF1ZXJ5LCBzdXBwb3J0ICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vRGF0YVwiXG5dLCBmdW5jdGlvbiggRGF0YSApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0cmV0dXJuIG5ldyBEYXRhKCk7XG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuL2NvcmVcIixcblx0XCIuL2RhdGEvdmFyL2RhdGFQcml2XCIsXG5cdFwiLi9kZWZlcnJlZFwiLFxuXHRcIi4vY2FsbGJhY2tzXCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnksIGRhdGFQcml2ICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vY29yZVwiLFxuXHRcIi4uL2NvcmUvc3RyaXBBbmRDb2xsYXBzZVwiLFxuXHRcIi4uL3Zhci9pc0Z1bmN0aW9uXCIsXG5cdFwiLi4vdmFyL3Jub3RodG1sd2hpdGVcIixcblx0XCIuLi9kYXRhL3Zhci9kYXRhUHJpdlwiLFxuXHRcIi4uL2NvcmUvaW5pdFwiXG5dLCBmdW5jdGlvbiggalF1ZXJ5LCBzdHJpcEFuZENvbGxhcHNlLCBpc0Z1bmN0aW9uLCBybm90aHRtbHdoaXRlLCBkYXRhUHJpdiApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0fVxuXHRyZXR1cm4gW107XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIGlzVmFsaWRWYWx1ZSApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cbn0gKTtcbiIsImRlZmluZSggZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHJldHVybiBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH07XG5cbn0gKTtcbiIsImRlZmluZSggW1xuXHRcIi4vY29yZVwiLFxuXHRcIi4vdmFyL3BudW1cIixcblx0XCIuL2NvcmUvYWNjZXNzXCIsXG5cdFwiLi9jb3JlL2NhbWVsQ2FzZVwiLFxuXHRcIi4vdmFyL2RvY3VtZW50XCIsXG5cdFwiLi92YXIvcmNzc051bVwiLFxuXHRcIi4vY3NzL3Zhci9ybnVtbm9ucHhcIixcblx0XCIuL2Nzcy92YXIvY3NzRXhwYW5kXCIsXG5cdFwiLi9jc3MvdmFyL2dldFN0eWxlc1wiLFxuXHRcIi4vY3NzL3Zhci9zd2FwXCIsXG5cdFwiLi9jc3MvY3VyQ1NTXCIsXG5cdFwiLi9jc3MvYWRqdXN0Q1NTXCIsXG5cdFwiLi9jc3MvYWRkR2V0SG9va0lmXCIsXG5cdFwiLi9jc3Mvc3VwcG9ydFwiLFxuXG5cdFwiLi9jb3JlL2luaXRcIixcblx0XCIuL2NvcmUvcmVhZHlcIixcblx0XCIuL3NlbGVjdG9yXCIgLy8gY29udGFpbnNcbl0sIGZ1bmN0aW9uKCBqUXVlcnksIHBudW0sIGFjY2VzcywgY2FtZWxDYXNlLCBkb2N1bWVudCwgcmNzc051bSwgcm51bW5vbnB4LCBjc3NFeHBhbmQsXG5cdGdldFN0eWxlcywgc3dhcCwgY3VyQ1NTLCBhZGp1c3RDU1MsIGFkZEdldEhvb2tJZiwgc3VwcG9ydCApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcHJvcGVydHkgbWFwcGVkIGFsb25nIHdoYXQgalF1ZXJ5LmNzc1Byb3BzIHN1Z2dlc3RzIG9yIHRvXG4vLyBhIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eS5cbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciByZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXTtcblx0aWYgKCAhcmV0ICkge1xuXHRcdHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xuXHR9XG5cdHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cdFx0KSApO1xuXHR9XG5cblx0cmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94O1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcblx0dmFsdWVJc0JvcmRlckJveCA9IHZhbHVlSXNCb3JkZXJCb3ggJiZcblx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdICk7XG5cblx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdGlmICggdmFsID09PSBcImF1dG9cIiB8fFxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkge1xuXG5cdFx0dmFsID0gZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdO1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHByb3ZpZGUgYm9yZGVyLWJveCB2YWx1ZXNcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZTtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIGRpbWVuc2lvbiApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgJiYgYm94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGlzQm9yZGVyQm94LFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpID09PSBzdHlsZXMucG9zaXRpb24gKSB7XG5cdFx0XHRcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcblx0XHRcdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHN0eWxlc1sgZGltZW5zaW9uIF0gKSAtXG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMgKSAtXG5cdFx0XHRcdFx0MC41XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBkaW1lbnNpb24gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoIHByZWZpeCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiIsImRlZmluZSggW1xuXHRcIi4uL2NvcmVcIlxuXSwgZnVuY3Rpb24oIGpRdWVyeSApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi92YXIvcm5vdGh0bWx3aGl0ZVwiXG5dLCBmdW5jdGlvbiggcm5vdGh0bWx3aGl0ZSApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblx0cmV0dXJuIHN0cmlwQW5kQ29sbGFwc2U7XG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuL2FyclwiXG5dLCBmdW5jdGlvbiggYXJyICkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRyZXR1cm4gYXJyLmNvbmNhdDtcbn0gKTtcbiIsImRlZmluZSggW1xuXHRcIi4uL2NvcmVcIixcblx0XCIuLi9xdWV1ZVwiLFxuXHRcIi4uL2VmZmVjdHNcIiAvLyBEZWxheSBpcyBvcHRpb25hbCBiZWNhdXNlIG9mIHRoaXMgZGVwZW5kZW5jeVxuXSwgZnVuY3Rpb24oIGpRdWVyeSApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5yZXR1cm4galF1ZXJ5LmZuLmRlbGF5O1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vZGF0YS92YXIvZGF0YVByaXZcIlxuXSwgZnVuY3Rpb24oIGRhdGFQcml2ICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5yZXR1cm4gc2V0R2xvYmFsRXZhbDtcbn0gKTtcbiIsImRlZmluZSggW1xuXHRcIi4uLy4uL2NvcmVcIixcblx0XCIuLi8uLi9zZWxlY3RvclwiXG5dLCBmdW5jdGlvbiggalF1ZXJ5ICkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRyZXR1cm4galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xufSApO1xuIiwiZGVmaW5lKCBmdW5jdGlvbigpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnJldHVybiBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG59ICk7XG4iLCIvKiEgQGxpY2Vuc2UgaXMtZG9tLW5vZGUtbGlzdCB2MS4yLjFcblxuXHRDb3B5cmlnaHQgMjAxOCBGaXNzc2lvbiBMTEMuXG5cblx0UGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuXHRvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5cdGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcblx0dG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuXHRjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcblx0ZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuXHRUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcblx0Y29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5cdElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuXHRGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcblx0QVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuXHRMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuXHRPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuXHRTT0ZUV0FSRS5cblxuKi9cbmltcG9ydCBpc0RvbU5vZGUgZnJvbSAnaXMtZG9tLW5vZGUnO1xuXG5mdW5jdGlvbiBpc0RvbU5vZGVMaXN0KHgpIHtcblx0dmFyIHByb3RvdHlwZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpO1xuXHR2YXIgcmVnZXggPSAvXlxcW29iamVjdCAoSFRNTENvbGxlY3Rpb258Tm9kZUxpc3R8T2JqZWN0KVxcXSQvO1xuXG5cdHJldHVybiB0eXBlb2Ygd2luZG93Lk5vZGVMaXN0ID09PSAnb2JqZWN0J1xuXHRcdD8geCBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlTGlzdFxuXHRcdDogeCAhPT0gbnVsbCAmJlxuXHRcdFx0XHR0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiZcblx0XHRcdFx0dHlwZW9mIHgubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdFx0XHRyZWdleC50ZXN0KHByb3RvdHlwZVRvU3RyaW5nKSAmJlxuXHRcdFx0XHQoeC5sZW5ndGggPT09IDAgfHwgaXNEb21Ob2RlKHhbMF0pKVxufVxuXG5leHBvcnQgZGVmYXVsdCBpc0RvbU5vZGVMaXN0O1xuIiwiZGVmaW5lKCBbXG5cdFwiLi9jb3JlXCIsXG5cdFwiLi92YXIvaXNGdW5jdGlvblwiLFxuXHRcIi4vY29yZS9pbml0XCIsXG5cdFwiLi9tYW5pcHVsYXRpb25cIiwgLy8gY2xvbmVcblx0XCIuL3RyYXZlcnNpbmdcIiAvLyBwYXJlbnQsIGNvbnRlbnRzXG5dLCBmdW5jdGlvbiggalF1ZXJ5LCBpc0Z1bmN0aW9uICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi9jb3JlXCIsXG5cdFwiLi4vY29yZS9hY2Nlc3NcIixcblx0XCIuL3N1cHBvcnRcIixcblx0XCIuLi9zZWxlY3RvclwiXG5dLCBmdW5jdGlvbiggalF1ZXJ5LCBhY2Nlc3MsIHN1cHBvcnQgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cbn0gKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiEgQGxpY2Vuc2UgVGVhbGlnaHQgdjAuMy42XG5cblx0Q29weXJpZ2h0IDIwMTggRmlzc3Npb24gTExDLlxuXG5cdFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcblx0b2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuXHRpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG5cdHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcblx0Y29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5cdGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblx0VGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5cdGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuXHRJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcblx0RklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5cdEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcblx0TElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcblx0T1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblx0U09GVFdBUkUuXG5cbiovXG5pbXBvcnQgaXNEb21Ob2RlIGZyb20gJ2lzLWRvbS1ub2RlJztcbmltcG9ydCBpc0RvbU5vZGVMaXN0IGZyb20gJ2lzLWRvbS1ub2RlLWxpc3QnO1xuXG5mdW5jdGlvbiB0ZWFsaWdodCh0YXJnZXQsIGNvbnRleHQpIHtcbiAgaWYgKCBjb250ZXh0ID09PSB2b2lkIDAgKSBjb250ZXh0ID0gZG9jdW1lbnQ7XG5cbiAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEFycmF5KSB7IHJldHVybiB0YXJnZXQuZmlsdGVyKGlzRG9tTm9kZSk7IH1cbiAgaWYgKGlzRG9tTm9kZSh0YXJnZXQpKSB7IHJldHVybiBbdGFyZ2V0XTsgfVxuICBpZiAoaXNEb21Ob2RlTGlzdCh0YXJnZXQpKSB7IHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0YXJnZXQpOyB9XG4gIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBxdWVyeSA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCh0YXJnZXQpO1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHF1ZXJ5KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0ZWFsaWdodDtcbiIsImRlZmluZSggW1xuXHRcIi4vY29yZVwiLFxuXHRcIi4vY29yZS9hY2Nlc3NcIixcblx0XCIuL3Zhci9kb2N1bWVudFwiLFxuXHRcIi4vdmFyL2RvY3VtZW50RWxlbWVudFwiLFxuXHRcIi4vdmFyL2lzRnVuY3Rpb25cIixcblx0XCIuL2Nzcy92YXIvcm51bW5vbnB4XCIsXG5cdFwiLi9jc3MvY3VyQ1NTXCIsXG5cdFwiLi9jc3MvYWRkR2V0SG9va0lmXCIsXG5cdFwiLi9jc3Mvc3VwcG9ydFwiLFxuXHRcIi4vdmFyL2lzV2luZG93XCIsXG5cdFwiLi9jb3JlL2luaXRcIixcblx0XCIuL2Nzc1wiLFxuXHRcIi4vc2VsZWN0b3JcIiAvLyBjb250YWluc1xuXSwgZnVuY3Rpb24oIGpRdWVyeSwgYWNjZXNzLCBkb2N1bWVudCwgZG9jdW1lbnRFbGVtZW50LCBpc0Z1bmN0aW9uLCBybnVtbm9ucHgsXG4gICAgICAgICAgICAgY3VyQ1NTLCBhZGRHZXRIb29rSWYsIHN1cHBvcnQsIGlzV2luZG93ICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgcmVjdCwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHQvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0d2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuXHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG5cdFx0fTtcblx0fSxcblxuXHQvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuXHQvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcblx0XHRcdC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiZcblx0XHRcdFx0KCBvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCApICYmXG5cdFx0XHRcdGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsZW0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBqUXVlcnkoIG9mZnNldFBhcmVudCApLm9mZnNldCgpO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3Ncblx0XHRcdHZhciB3aW47XG5cdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iLCIvKiEgQGxpY2Vuc2UgaXMtZG9tLW5vZGUgdjEuMC40XG5cblx0Q29weXJpZ2h0IDIwMTggRmlzc3Npb24gTExDLlxuXG5cdFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcblx0b2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuXHRpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG5cdHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcblx0Y29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5cdGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblx0VGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5cdGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuXHRJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcblx0RklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5cdEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcblx0TElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcblx0T1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblx0U09GVFdBUkUuXG5cbiovXG5mdW5jdGlvbiBpc0RvbU5vZGUoeCkge1xuXHRyZXR1cm4gdHlwZW9mIHdpbmRvdy5Ob2RlID09PSAnb2JqZWN0J1xuXHRcdD8geCBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlXG5cdFx0OiB4ICE9PSBudWxsICYmXG5cdFx0XHRcdHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0XHR0eXBlb2YgeC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiZcblx0XHRcdFx0dHlwZW9mIHgubm9kZU5hbWUgPT09ICdzdHJpbmcnXG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRG9tTm9kZTtcbiIsIi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy4zXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wOC0wOFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIChcImZvcm1cIiBpbiBlbGVtIHx8IFwibGFiZWxcIiBpbiBlbGVtKTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdGRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG5cdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtc1tpKytdKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIEVYUE9TRVxudmFyIF9zaXp6bGUgPSB3aW5kb3cuU2l6emxlO1xuXG5TaXp6bGUubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIHdpbmRvdy5TaXp6bGUgPT09IFNpenpsZSApIHtcblx0XHR3aW5kb3cuU2l6emxlID0gX3NpenpsZTtcblx0fVxuXG5cdHJldHVybiBTaXp6bGU7XG59O1xuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBTaXp6bGU7IH0pO1xuLy8gU2l6emxlIHJlcXVpcmVzIHRoYXQgdGhlcmUgYmUgYSBnbG9iYWwgd2luZG93IGluIENvbW1vbi1KUyBsaWtlIGVudmlyb25tZW50c1xufSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyApIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBTaXp6bGU7XG59IGVsc2Uge1xuXHR3aW5kb3cuU2l6emxlID0gU2l6emxlO1xufVxuLy8gRVhQT1NFXG5cbn0pKCB3aW5kb3cgKTtcbiIsImRlZmluZSggW1xuXHRcIi4vY2xhc3MydHlwZVwiXG5dLCBmdW5jdGlvbiggY2xhc3MydHlwZSApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0cmV0dXJuIGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG59ICk7XG4iLCJkZWZpbmUoIGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRyZXR1cm4gKCAvXFw/LyApO1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vY29yZVwiLFxuXHRcIi4uL2V2ZW50XCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnkgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi9jb3JlXCIsXG5cdFwiLi4vZGF0YS92YXIvZGF0YVByaXZcIixcblx0XCIuL3N1cHBvcnRcIixcblxuXHRcIi4uL2V2ZW50XCIsXG5cdFwiLi90cmlnZ2VyXCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnksIGRhdGFQcml2LCBzdXBwb3J0ICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi92YXIvZG9jdW1lbnRcIixcblx0XCIuLi92YXIvc3VwcG9ydFwiXG5dLCBmdW5jdGlvbiggZG9jdW1lbnQsIHN1cHBvcnQgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5yZXR1cm4gc3VwcG9ydDtcblxufSApO1xuIiwiZGVmaW5lKCBmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gW1tDbGFzc11dIC0+IHR5cGUgcGFpcnNcblx0cmV0dXJuIHt9O1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vdmFyL3BudW1cIlxuXSwgZnVuY3Rpb24oIHBudW0gKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5yZXR1cm4gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi9jb3JlXCIsXG5cdFwiLi92YXIvaXNGdW5jdGlvblwiLFxuXHRcIi4vdmFyL3NsaWNlXCIsXG5cdFwiLi9jYWxsYmFja3NcIlxuXSwgZnVuY3Rpb24oIGpRdWVyeSwgaXNGdW5jdGlvbiwgc2xpY2UgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi92YXIvZG9jdW1lbnRcIixcblx0XCIuLi92YXIvc3VwcG9ydFwiXG5dLCBmdW5jdGlvbiggZG9jdW1lbnQsIHN1cHBvcnQgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcblxucmV0dXJuIHN1cHBvcnQ7XG5cbn0gKTtcbiIsImRlZmluZSggW1xuXHRcIi4vaGFzT3duXCJcbl0sIGZ1bmN0aW9uKCBoYXNPd24gKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHJldHVybiBoYXNPd24udG9TdHJpbmc7XG59ICk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gJ0BtZWRpYSAnICsgaXRlbVsyXSArICd7JyArIGNvbnRlbnQgKyAnfSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gbW9kdWxlc1tpXTsgLy8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuICAgICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcbiAgICAgIC8vIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cbiAgICAgIC8vIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblxuICAgICAgaWYgKGl0ZW1bMF0gPT0gbnVsbCB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBpZiAobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2UgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICBpdGVtWzJdID0gJygnICsgaXRlbVsyXSArICcpIGFuZCAoJyArIG1lZGlhUXVlcnkgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLyc7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG4gIHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59IiwiZGVmaW5lKCBmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0cmV0dXJuICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0rKS9pICk7XG59ICk7XG4iLCIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHNjcmlwdEV4cG9ydHMsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciwgLyogc2VydmVyIG9ubHkgKi9cbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cbikge1xuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gc2hhZG93TW9kZVxuICAgICAgPyBmdW5jdGlvbiAoKSB7IGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIHRoaXMuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdCkgfVxuICAgICAgOiBpbmplY3RTdHlsZXNcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG5vcm1hbGl6ZXJcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuIiwiZGVmaW5lKCBbXG5cdFwiLi4vY29yZVwiLFxuXHRcIi4uL3Zhci9pc0Z1bmN0aW9uXCIsXG5cdFwiLi92YXIvbm9uY2VcIixcblx0XCIuL3Zhci9ycXVlcnlcIixcblx0XCIuLi9hamF4XCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnksIGlzRnVuY3Rpb24sIG5vbmNlLCBycXVlcnkgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBpc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cbn0gKTtcbiIsImRlZmluZSggW1xuXHRcIi4uLy4uL2NvcmVcIlxuXSwgZnVuY3Rpb24oIGpRdWVyeSApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnJldHVybiBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi8uLi9jb3JlXCIsXG5cdFwiLi4vLi4vc2VsZWN0b3JcIlxuXG5cdC8vIGNzcyBpcyBhc3N1bWVkXG5dLCBmdW5jdGlvbiggalF1ZXJ5ICkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBpc0hpZGRlbldpdGhpblRyZWUgcmVwb3J0cyBpZiBhbiBlbGVtZW50IGhhcyBhIG5vbi1cIm5vbmVcIiBkaXNwbGF5IHN0eWxlIChpbmxpbmUgYW5kL29yXG5cdC8vIHRocm91Z2ggdGhlIENTUyBjYXNjYWRlKSwgd2hpY2ggaXMgdXNlZnVsIGluIGRlY2lkaW5nIHdoZXRoZXIgb3Igbm90IHRvIG1ha2UgaXQgdmlzaWJsZS5cblx0Ly8gSXQgZGlmZmVycyBmcm9tIHRoZSA6aGlkZGVuIHNlbGVjdG9yIChqUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbikgaW4gdHdvIGltcG9ydGFudCB3YXlzOlxuXHQvLyAqIEEgaGlkZGVuIGFuY2VzdG9yIGRvZXMgbm90IGZvcmNlIGFuIGVsZW1lbnQgdG8gYmUgY2xhc3NpZmllZCBhcyBoaWRkZW4uXG5cdC8vICogQmVpbmcgZGlzY29ubmVjdGVkIGZyb20gdGhlIGRvY3VtZW50IGRvZXMgbm90IGZvcmNlIGFuIGVsZW1lbnQgdG8gYmUgY2xhc3NpZmllZCBhcyBoaWRkZW4uXG5cdC8vIFRoZXNlIGRpZmZlcmVuY2VzIGltcHJvdmUgdGhlIGJlaGF2aW9yIG9mIC50b2dnbGUoKSBldCBhbC4gd2hlbiBhcHBsaWVkIHRvIGVsZW1lbnRzIHRoYXQgYXJlXG5cdC8vIGRldGFjaGVkIG9yIGNvbnRhaW5lZCB3aXRoaW4gaGlkZGVuIGFuY2VzdG9ycyAoZ2gtMjQwNCwgZ2gtMjg2MykuXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vY29yZVwiLFxuXHRcIi4uL2NvcmUvdG9UeXBlXCIsXG5cdFwiLi4vdmFyL2lzRnVuY3Rpb25cIlxuXSwgZnVuY3Rpb24oIGpRdWVyeSwgdG9UeXBlLCBpc0Z1bmN0aW9uICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5yZXR1cm4gYWNjZXNzO1xuXG59ICk7XG4iLCIvLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuZGVmaW5lKCBbXG5cdFwiLi4vY29yZVwiLFxuXHRcIi4uL3Zhci9kb2N1bWVudFwiLFxuXHRcIi4uL3Zhci9pc0Z1bmN0aW9uXCIsXG5cdFwiLi92YXIvcnNpbmdsZVRhZ1wiLFxuXG5cdFwiLi4vdHJhdmVyc2luZy9maW5kRmlsdGVyXCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnksIGRvY3VtZW50LCBpc0Z1bmN0aW9uLCByc2luZ2xlVGFnICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxucmV0dXJuIGluaXQ7XG5cbn0gKTtcbiIsImRlZmluZSggZnVuY3Rpb24oKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblxufTtcblxucmV0dXJuIG5vZGVOYW1lO1xuXG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuL2NvcmVcIixcblx0XCIuL2NvcmUvbm9kZU5hbWVcIixcblx0XCIuL2NvcmUvY2FtZWxDYXNlXCIsXG5cdFwiLi9jb3JlL3RvVHlwZVwiLFxuXHRcIi4vdmFyL2lzRnVuY3Rpb25cIixcblx0XCIuL3Zhci9pc1dpbmRvd1wiLFxuXHRcIi4vdmFyL3NsaWNlXCIsXG5cblx0XCIuL2V2ZW50L2FsaWFzXCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnksIG5vZGVOYW1lLCBjYW1lbENhc2UsIHRvVHlwZSwgaXNGdW5jdGlvbiwgaXNXaW5kb3csIHNsaWNlICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSApO1xuXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbi8vIGFyZ3VtZW50cy5cbi8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxualF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0Y29udGV4dCA9IGZuO1xuXHRcdGZuID0gdG1wO1xuXHR9XG5cblx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0aWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRyZXR1cm4gcHJveHk7XG59O1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xualF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xualF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xualF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxualF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG59O1xuXG59ICk7XG4iLCJkZWZpbmUoIGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRyZXR1cm4gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuL2NvcmVcIixcblx0XCIuL3Zhci9jb25jYXRcIixcblx0XCIuL3Zhci9pc0Z1bmN0aW9uXCIsXG5cdFwiLi92YXIvcHVzaFwiLFxuXHRcIi4vY29yZS9hY2Nlc3NcIixcblx0XCIuL21hbmlwdWxhdGlvbi92YXIvcmNoZWNrYWJsZVR5cGVcIixcblx0XCIuL21hbmlwdWxhdGlvbi92YXIvcnRhZ05hbWVcIixcblx0XCIuL21hbmlwdWxhdGlvbi92YXIvcnNjcmlwdFR5cGVcIixcblx0XCIuL21hbmlwdWxhdGlvbi93cmFwTWFwXCIsXG5cdFwiLi9tYW5pcHVsYXRpb24vZ2V0QWxsXCIsXG5cdFwiLi9tYW5pcHVsYXRpb24vc2V0R2xvYmFsRXZhbFwiLFxuXHRcIi4vbWFuaXB1bGF0aW9uL2J1aWxkRnJhZ21lbnRcIixcblx0XCIuL21hbmlwdWxhdGlvbi9zdXBwb3J0XCIsXG5cblx0XCIuL2RhdGEvdmFyL2RhdGFQcml2XCIsXG5cdFwiLi9kYXRhL3Zhci9kYXRhVXNlclwiLFxuXHRcIi4vZGF0YS92YXIvYWNjZXB0RGF0YVwiLFxuXHRcIi4vY29yZS9ET01FdmFsXCIsXG5cdFwiLi9jb3JlL25vZGVOYW1lXCIsXG5cblx0XCIuL2NvcmUvaW5pdFwiLFxuXHRcIi4vdHJhdmVyc2luZ1wiLFxuXHRcIi4vc2VsZWN0b3JcIixcblx0XCIuL2V2ZW50XCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnksIGNvbmNhdCwgaXNGdW5jdGlvbiwgcHVzaCwgYWNjZXNzLFxuXHRyY2hlY2thYmxlVHlwZSwgcnRhZ05hbWUsIHJzY3JpcHRUeXBlLFxuXHR3cmFwTWFwLCBnZXRBbGwsIHNldEdsb2JhbEV2YWwsIGJ1aWxkRnJhZ21lbnQsIHN1cHBvcnQsXG5cdGRhdGFQcml2LCBkYXRhVXNlciwgYWNjZXB0RGF0YSwgRE9NRXZhbCwgbm9kZU5hbWUgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBkb2MsIG5vZGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiIsImRlZmluZSggW1xuXHRcIi4vYXJyXCJcbl0sIGZ1bmN0aW9uKCBhcnIgKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHJldHVybiBhcnIuc2xpY2U7XG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi9jb3JlXCIsXG5cdFwiLi4vdmFyL2RvY3VtZW50XCIsXG5cdFwiLi4vYWpheFwiXG5dLCBmdW5jdGlvbiggalF1ZXJ5LCBkb2N1bWVudCApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi9jb3JlXCIsXG5cdFwiLi92YXIvcmJveFN0eWxlXCIsXG5cdFwiLi92YXIvcm51bW5vbnB4XCIsXG5cdFwiLi92YXIvZ2V0U3R5bGVzXCIsXG5cdFwiLi9zdXBwb3J0XCIsXG5cdFwiLi4vc2VsZWN0b3JcIiAvLyBHZXQgalF1ZXJ5LmNvbnRhaW5zXG5dLCBmdW5jdGlvbiggalF1ZXJ5LCByYm94U3R5bGUsIHJudW1ub25weCwgZ2V0U3R5bGVzLCBzdXBwb3J0ICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5yZXR1cm4gY3VyQ1NTO1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vY29yZVwiLFxuXHRcIi4uL3Zhci9pbmRleE9mXCIsXG5cdFwiLi4vdmFyL2lzRnVuY3Rpb25cIixcblx0XCIuL3Zhci9ybmVlZHNDb250ZXh0XCIsXG5cdFwiLi4vc2VsZWN0b3JcIlxuXSwgZnVuY3Rpb24oIGpRdWVyeSwgaW5kZXhPZiwgaXNGdW5jdGlvbiwgcm5lZWRzQ29udGV4dCApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi92YXIvc3VwcG9ydFwiXG5dLCBmdW5jdGlvbiggc3VwcG9ydCApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5yZXR1cm4gc3VwcG9ydDtcblxufSApO1xuIiwiZGVmaW5lKCBmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0cmV0dXJuICggL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xufSApO1xuIiwiLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG5pbXBvcnQgbGlzdFRvU3R5bGVzIGZyb20gJy4vbGlzdFRvU3R5bGVzJ1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cbnZhciBvcHRpb25zID0gbnVsbFxudmFyIHNzcklkS2V5ID0gJ2RhdGEtdnVlLXNzci1pZCdcblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkU3R5bGVzQ2xpZW50IChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbiwgX29wdGlvbnMpIHtcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxuXG4gIG9wdGlvbnMgPSBfb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG4gICAgdmFyIG1heVJlbW92ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgICAgZG9tU3R5bGUucmVmcy0tXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcbiAgICB9XG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcbiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW11cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxuICAgICAgaWYgKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUucmVmcysrXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXG4gICAgICB9XG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsgaWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0cyB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcbiAgcmV0dXJuIHN0eWxlRWxlbWVudFxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICB2YXIgdXBkYXRlLCByZW1vdmVcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlWycgKyBzc3JJZEtleSArICd+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuICBpZiAob3B0aW9ucy5zc3JJZCkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoc3NySWRLZXksIG9iai5pZClcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuIiwiZGVmaW5lKCBbXG5cdFwiLi4vY29yZVwiLFxuXHRcIi4uL3NlbGVjdG9yXCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnkgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vY29yZVwiXG5dLCBmdW5jdGlvbiggalF1ZXJ5LCBub0dsb2JhbCApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cbn0gKTtcbiIsImRlZmluZSggZnVuY3Rpb24oKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhbiBvYmplY3QgY2FuIGhhdmUgZGF0YVxuICovXG5yZXR1cm4gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi9jb3JlXCIsXG5cdFwiLi4vdmFyL2RvY3VtZW50XCIsXG5cdFwiLi4vdmFyL2RvY3VtZW50RWxlbWVudFwiLFxuXHRcIi4uL3Zhci9zdXBwb3J0XCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnksIGRvY3VtZW50LCBkb2N1bWVudEVsZW1lbnQsIHN1cHBvcnQgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXG5cdFx0XHRcIm1hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFwiO1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcIndpZHRoOjYwJTt0b3A6MSVcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5tYXJnaW5MZWZ0ICkgPT09IDEyO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLnJpZ2h0ID0gXCI2MCVcIjtcblx0XHRwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHRcdC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUud2lkdGggKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHQvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSBkaXYub2Zmc2V0V2lkdGggPT09IDM2IHx8IFwiYWJzb2x1dGVcIjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiByb3VuZFBpeGVsTWVhc3VyZXMoIG1lYXN1cmUgKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIHBhcnNlRmxvYXQoIG1lYXN1cmUgKSApO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cbnJldHVybiBzdXBwb3J0O1xuXG59ICk7XG4iLCJkZWZpbmUoIGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRyZXR1cm4gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcbn0gKTtcbiIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vdmFyL2NsYXNzMnR5cGVcIixcblx0XCIuLi92YXIvdG9TdHJpbmdcIlxuXSwgZnVuY3Rpb24oIGNsYXNzMnR5cGUsIHRvU3RyaW5nICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG5cbnJldHVybiB0b1R5cGU7XG59ICk7XG4iLCJkZWZpbmUoIGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBPbmx5IGNvdW50IEhUTUwgd2hpdGVzcGFjZVxuXHQvLyBPdGhlciB3aGl0ZXNwYWNlIHNob3VsZCBjb3VudCBpbiB2YWx1ZXNcblx0Ly8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXdoaXRlc3BhY2Vcblx0cmV0dXJuICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi9jb3JlXCIsXG5cdFwiLi4vY29yZS9jYW1lbENhc2VcIixcblx0XCIuLi92YXIvcm5vdGh0bWx3aGl0ZVwiLFxuXHRcIi4vdmFyL2FjY2VwdERhdGFcIlxuXSwgZnVuY3Rpb24oIGpRdWVyeSwgY2FtZWxDYXNlLCBybm90aHRtbHdoaXRlLCBhY2NlcHREYXRhICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcblxucmV0dXJuIERhdGE7XG59ICk7XG4iLCIvKiEgQGxpY2Vuc2UgbWluaXJhZiB2MS4wLjBcblxuXHRDb3B5cmlnaHQgMjAxOCBGaXNzc2lvbiBMTEMuXG5cblx0UGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuXHRvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5cdGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcblx0dG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuXHRjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcblx0ZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuXHRUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcblx0Y29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5cdElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuXHRGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcblx0QVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuXHRMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuXHRPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuXHRTT0ZUV0FSRS5cblxuKi9cbnZhciBwb2x5ZmlsbCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciBjbG9jayA9IERhdGUubm93KCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdHZhciBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG5cdFx0aWYgKGN1cnJlbnRUaW1lIC0gY2xvY2sgPiAxNikge1xuXHRcdFx0Y2xvY2sgPSBjdXJyZW50VGltZTtcblx0XHRcdGNhbGxiYWNrKGN1cnJlbnRUaW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBwb2x5ZmlsbChjYWxsYmFjayk7IH0sIDApO1xuXHRcdH1cblx0fVxufSkoKTtcblxudmFyIGluZGV4ID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHR3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0cG9seWZpbGw7XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuIiwiZGVmaW5lKCBbXG5cdFwiLi9jb3JlXCIsXG5cdFwiLi92YXIvZG9jdW1lbnRcIixcblx0XCIuL3Zhci9kb2N1bWVudEVsZW1lbnRcIixcblx0XCIuL3Zhci9pc0Z1bmN0aW9uXCIsXG5cdFwiLi92YXIvcm5vdGh0bWx3aGl0ZVwiLFxuXHRcIi4vdmFyL3NsaWNlXCIsXG5cdFwiLi9kYXRhL3Zhci9kYXRhUHJpdlwiLFxuXHRcIi4vY29yZS9ub2RlTmFtZVwiLFxuXG5cdFwiLi9jb3JlL2luaXRcIixcblx0XCIuL3NlbGVjdG9yXCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnksIGRvY3VtZW50LCBkb2N1bWVudEVsZW1lbnQsIGlzRnVuY3Rpb24sIHJub3RodG1sd2hpdGUsXG5cdHNsaWNlLCBkYXRhUHJpdiwgbm9kZU5hbWUgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIG5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vY29yZVwiLFxuXG5cdFwiLi4vZXZlbnRcIixcblx0XCIuL3RyaWdnZXJcIlxuXSwgZnVuY3Rpb24oIGpRdWVyeSApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cbn0gKTtcbiIsInZhciBWdWUgLy8gbGF0ZSBiaW5kXG52YXIgdmVyc2lvblxudmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbClcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3aW5kb3cuX19WVUVfSE9UX01BUF9fID0gbWFwXG59XG52YXIgaW5zdGFsbGVkID0gZmFsc2VcbnZhciBpc0Jyb3dzZXJpZnkgPSBmYWxzZVxudmFyIGluaXRIb29rTmFtZSA9ICdiZWZvcmVDcmVhdGUnXG5cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uICh2dWUsIGJyb3dzZXJpZnkpIHtcbiAgaWYgKGluc3RhbGxlZCkgeyByZXR1cm4gfVxuICBpbnN0YWxsZWQgPSB0cnVlXG5cbiAgVnVlID0gdnVlLl9fZXNNb2R1bGUgPyB2dWUuZGVmYXVsdCA6IHZ1ZVxuICB2ZXJzaW9uID0gVnVlLnZlcnNpb24uc3BsaXQoJy4nKS5tYXAoTnVtYmVyKVxuICBpc0Jyb3dzZXJpZnkgPSBicm93c2VyaWZ5XG5cbiAgLy8gY29tcGF0IHdpdGggPCAyLjAuMC1hbHBoYS43XG4gIGlmIChWdWUuY29uZmlnLl9saWZlY3ljbGVIb29rcy5pbmRleE9mKCdpbml0JykgPiAtMSkge1xuICAgIGluaXRIb29rTmFtZSA9ICdpbml0J1xuICB9XG5cbiAgZXhwb3J0cy5jb21wYXRpYmxlID0gdmVyc2lvblswXSA+PSAyXG4gIGlmICghZXhwb3J0cy5jb21wYXRpYmxlKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1tITVJdIFlvdSBhcmUgdXNpbmcgYSB2ZXJzaW9uIG9mIHZ1ZS1ob3QtcmVsb2FkLWFwaSB0aGF0IGlzICcgK1xuICAgICAgICAnb25seSBjb21wYXRpYmxlIHdpdGggVnVlLmpzIGNvcmUgXjIuMC4wLidcbiAgICApXG4gICAgcmV0dXJuXG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByZWNvcmQgZm9yIGEgaG90IG1vZHVsZSwgd2hpY2gga2VlcHMgdHJhY2sgb2YgaXRzIGNvbnN0cnVjdG9yXG4gKiBhbmQgaW5zdGFuY2VzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmV4cG9ydHMuY3JlYXRlUmVjb3JkID0gZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG4gIGlmKG1hcFtpZF0pIHsgcmV0dXJuIH1cblxuICB2YXIgQ3RvciA9IG51bGxcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgQ3RvciA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zXG4gIH1cbiAgbWFrZU9wdGlvbnNIb3QoaWQsIG9wdGlvbnMpXG4gIG1hcFtpZF0gPSB7XG4gICAgQ3RvcjogQ3RvcixcbiAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgIGluc3RhbmNlczogW11cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIG1vZHVsZSBpcyByZWNvcmRlZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICovXG5cbmV4cG9ydHMuaXNSZWNvcmRlZCA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gdHlwZW9mIG1hcFtpZF0gIT09ICd1bmRlZmluZWQnXG59XG5cbi8qKlxuICogTWFrZSBhIENvbXBvbmVudCBvcHRpb25zIG9iamVjdCBob3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIG1ha2VPcHRpb25zSG90KGlkLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICB2YXIgcmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIChoLCBjdHgpIHtcbiAgICAgIHZhciBpbnN0YW5jZXMgPSBtYXBbaWRdLmluc3RhbmNlc1xuICAgICAgaWYgKGN0eCAmJiBpbnN0YW5jZXMuaW5kZXhPZihjdHgucGFyZW50KSA8IDApIHtcbiAgICAgICAgaW5zdGFuY2VzLnB1c2goY3R4LnBhcmVudClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW5kZXIoaCwgY3R4KVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbmplY3RIb29rKG9wdGlvbnMsIGluaXRIb29rTmFtZSwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVjb3JkID0gbWFwW2lkXVxuICAgICAgaWYgKCFyZWNvcmQuQ3Rvcikge1xuICAgICAgICByZWNvcmQuQ3RvciA9IHRoaXMuY29uc3RydWN0b3JcbiAgICAgIH1cbiAgICAgIHJlY29yZC5pbnN0YW5jZXMucHVzaCh0aGlzKVxuICAgIH0pXG4gICAgaW5qZWN0SG9vayhvcHRpb25zLCAnYmVmb3JlRGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGluc3RhbmNlcyA9IG1hcFtpZF0uaW5zdGFuY2VzXG4gICAgICBpbnN0YW5jZXMuc3BsaWNlKGluc3RhbmNlcy5pbmRleE9mKHRoaXMpLCAxKVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBJbmplY3QgYSBob29rIHRvIGEgaG90IHJlbG9hZGFibGUgY29tcG9uZW50IHNvIHRoYXRcbiAqIHdlIGNhbiBrZWVwIHRyYWNrIG9mIGl0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va1xuICovXG5cbmZ1bmN0aW9uIGluamVjdEhvb2sob3B0aW9ucywgbmFtZSwgaG9vaykge1xuICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zW25hbWVdXG4gIG9wdGlvbnNbbmFtZV0gPSBleGlzdGluZ1xuICAgID8gQXJyYXkuaXNBcnJheShleGlzdGluZykgPyBleGlzdGluZy5jb25jYXQoaG9vaykgOiBbZXhpc3RpbmcsIGhvb2tdXG4gICAgOiBbaG9va11cbn1cblxuZnVuY3Rpb24gdHJ5V3JhcChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGlkLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgZm4oaWQsIGFyZylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC4nXG4gICAgICApXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMgKG9sZE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9sZE9wdGlvbnMpIHtcbiAgICBpZiAoIShrZXkgaW4gbmV3T3B0aW9ucykpIHtcbiAgICAgIGRlbGV0ZSBvbGRPcHRpb25zW2tleV1cbiAgICB9XG4gIH1cbiAgZm9yICh2YXIga2V5JDEgaW4gbmV3T3B0aW9ucykge1xuICAgIG9sZE9wdGlvbnNba2V5JDFdID0gbmV3T3B0aW9uc1trZXkkMV1cbiAgfVxufVxuXG5leHBvcnRzLnJlcmVuZGVyID0gdHJ5V3JhcChmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlY29yZCA9IG1hcFtpZF1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgcmVjb3JkLmluc3RhbmNlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZS4kZm9yY2VVcGRhdGUoKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMub3B0aW9uc1xuICB9XG4gIGlmIChyZWNvcmQuQ3Rvcikge1xuICAgIHJlY29yZC5DdG9yLm9wdGlvbnMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICByZWNvcmQuQ3Rvci5vcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zXG4gICAgcmVjb3JkLmluc3RhbmNlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZS4kb3B0aW9ucy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgaW5zdGFuY2UuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNcbiAgICAgIC8vIHJlc2V0IHN0YXRpYyB0cmVlc1xuICAgICAgLy8gcHJlIDIuNSwgYWxsIHN0YXRpYyB0cmVlcyBhcmUgY2FjaGVkIHRvZ2V0aGVyIG9uIHRoZSBpbnN0YW5jZVxuICAgICAgaWYgKGluc3RhbmNlLl9zdGF0aWNUcmVlcykge1xuICAgICAgICBpbnN0YW5jZS5fc3RhdGljVHJlZXMgPSBbXVxuICAgICAgfVxuICAgICAgLy8gMi41LjBcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlY29yZC5DdG9yLm9wdGlvbnMuY2FjaGVkKSkge1xuICAgICAgICByZWNvcmQuQ3Rvci5vcHRpb25zLmNhY2hlZCA9IFtdXG4gICAgICB9XG4gICAgICAvLyAyLjUuM1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5zdGFuY2UuJG9wdGlvbnMuY2FjaGVkKSkge1xuICAgICAgICBpbnN0YW5jZS4kb3B0aW9ucy5jYWNoZWQgPSBbXVxuICAgICAgfVxuXG4gICAgICAvLyBwb3N0IDIuNS40OiB2LW9uY2UgdHJlZXMgYXJlIGNhY2hlZCBvbiBpbnN0YW5jZS5fc3RhdGljVHJlZXMuXG4gICAgICAvLyBQdXJlIHN0YXRpYyB0cmVlcyBhcmUgY2FjaGVkIG9uIHRoZSBzdGF0aWNSZW5kZXJGbnMgYXJyYXlcbiAgICAgIC8vIChib3RoIGFscmVhZHkgcmVzZXQgYWJvdmUpXG5cbiAgICAgIC8vIDIuNjogdGVtcG9yYXJpbHkgbWFyayByZW5kZXJlZCBzY29wZWQgc2xvdHMgYXMgdW5zdGFibGUgc28gdGhhdFxuICAgICAgLy8gY2hpbGQgY29tcG9uZW50cyBjYW4gYmUgZm9yY2VkIHRvIHVwZGF0ZVxuICAgICAgdmFyIHJlc3RvcmUgPSBwYXRjaFNjb3BlZFNsb3RzKGluc3RhbmNlKVxuICAgICAgaW5zdGFuY2UuJGZvcmNlVXBkYXRlKClcbiAgICAgIGluc3RhbmNlLiRuZXh0VGljayhyZXN0b3JlKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gZnVuY3Rpb25hbCBvciBubyBpbnN0YW5jZSBjcmVhdGVkIHlldFxuICAgIHJlY29yZC5vcHRpb25zLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgcmVjb3JkLm9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNcblxuICAgIC8vIGhhbmRsZSBmdW5jdGlvbmFsIGNvbXBvbmVudCByZS1yZW5kZXJcbiAgICBpZiAocmVjb3JkLm9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gcmVyZW5kZXIgd2l0aCBmdWxsIG9wdGlvbnNcbiAgICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPiAyKSB7XG4gICAgICAgIHVwZGF0ZU9wdGlvbnMocmVjb3JkLm9wdGlvbnMsIG9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0ZW1wbGF0ZS1vbmx5IHJlcmVuZGVyLlxuICAgICAgICAvLyBuZWVkIHRvIGluamVjdCB0aGUgc3R5bGUgaW5qZWN0aW9uIGNvZGUgZm9yIENTUyBtb2R1bGVzXG4gICAgICAgIC8vIHRvIHdvcmsgcHJvcGVybHkuXG4gICAgICAgIHZhciBpbmplY3RTdHlsZXMgPSByZWNvcmQub3B0aW9ucy5faW5qZWN0U3R5bGVzXG4gICAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgICB2YXIgcmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICAgICAgICByZWNvcmQub3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiAoaCwgY3R4KSB7XG4gICAgICAgICAgICBpbmplY3RTdHlsZXMuY2FsbChjdHgpXG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyKGgsIGN0eClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY29yZC5vcHRpb25zLl9DdG9yID0gbnVsbFxuICAgICAgLy8gMi41LjNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlY29yZC5vcHRpb25zLmNhY2hlZCkpIHtcbiAgICAgICAgcmVjb3JkLm9wdGlvbnMuY2FjaGVkID0gW11cbiAgICAgIH1cbiAgICAgIHJlY29yZC5pbnN0YW5jZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICBpbnN0YW5jZS4kZm9yY2VVcGRhdGUoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pXG5cbmV4cG9ydHMucmVsb2FkID0gdHJ5V3JhcChmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlY29yZCA9IG1hcFtpZF1cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zLm9wdGlvbnNcbiAgICB9XG4gICAgbWFrZU9wdGlvbnNIb3QoaWQsIG9wdGlvbnMpXG4gICAgaWYgKHJlY29yZC5DdG9yKSB7XG4gICAgICBpZiAodmVyc2lvblsxXSA8IDIpIHtcbiAgICAgICAgLy8gcHJlc2VydmUgcHJlIDIuMiBiZWhhdmlvciBmb3IgZ2xvYmFsIG1peGluIGhhbmRsaW5nXG4gICAgICAgIHJlY29yZC5DdG9yLmV4dGVuZE9wdGlvbnMgPSBvcHRpb25zXG4gICAgICB9XG4gICAgICB2YXIgbmV3Q3RvciA9IHJlY29yZC5DdG9yLnN1cGVyLmV4dGVuZChvcHRpb25zKVxuICAgICAgcmVjb3JkLkN0b3Iub3B0aW9ucyA9IG5ld0N0b3Iub3B0aW9uc1xuICAgICAgcmVjb3JkLkN0b3IuY2lkID0gbmV3Q3Rvci5jaWRcbiAgICAgIHJlY29yZC5DdG9yLnByb3RvdHlwZSA9IG5ld0N0b3IucHJvdG90eXBlXG4gICAgICBpZiAobmV3Q3Rvci5yZWxlYXNlKSB7XG4gICAgICAgIC8vIHRlbXBvcmFyeSBnbG9iYWwgbWl4aW4gc3RyYXRlZ3kgdXNlZCBpbiA8IDIuMC4wLWFscGhhLjZcbiAgICAgICAgbmV3Q3Rvci5yZWxlYXNlKClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlT3B0aW9ucyhyZWNvcmQub3B0aW9ucywgb3B0aW9ucylcbiAgICB9XG4gIH1cbiAgcmVjb3JkLmluc3RhbmNlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgaWYgKGluc3RhbmNlLiR2bm9kZSAmJiBpbnN0YW5jZS4kdm5vZGUuY29udGV4dCkge1xuICAgICAgaW5zdGFuY2UuJHZub2RlLmNvbnRleHQuJGZvcmNlVXBkYXRlKClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnUm9vdCBvciBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlIG1vZGlmaWVkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC4nXG4gICAgICApXG4gICAgfVxuICB9KVxufSlcblxuLy8gMi42IG9wdGltaXplcyB0ZW1wbGF0ZS1jb21waWxlZCBzY29wZWQgc2xvdHMgYW5kIHNraXBzIHVwZGF0ZXMgaWYgY2hpbGRcbi8vIG9ubHkgdXNlcyBzY29wZWQgc2xvdHMuIFdlIG5lZWQgdG8gcGF0Y2ggdGhlIHNjb3BlZCBzbG90cyByZXNvbHZpbmcgaGVscGVyXG4vLyB0byB0ZW1wb3JhcmlseSBtYXJrIGFsbCBzY29wZWQgc2xvdHMgYXMgdW5zdGFibGUgaW4gb3JkZXIgdG8gZm9yY2UgY2hpbGRcbi8vIHVwZGF0ZXMuXG5mdW5jdGlvbiBwYXRjaFNjb3BlZFNsb3RzIChpbnN0YW5jZSkge1xuICBpZiAoIWluc3RhbmNlLl91KSB7IHJldHVybiB9XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvYmxvYi9kZXYvc3JjL2NvcmUvaW5zdGFuY2UvcmVuZGVyLWhlbHBlcnMvcmVzb2x2ZS1zY29wZWQtc2xvdHMuanNcbiAgdmFyIG9yaWdpbmFsID0gaW5zdGFuY2UuX3VcbiAgaW5zdGFuY2UuX3UgPSBmdW5jdGlvbiAoc2xvdHMpIHtcbiAgICB0cnkge1xuICAgICAgLy8gMi42LjQgfiAyLjYuNlxuICAgICAgcmV0dXJuIG9yaWdpbmFsKHNsb3RzLCB0cnVlKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIDIuNSAvID49IDIuNi43XG4gICAgICByZXR1cm4gb3JpZ2luYWwoc2xvdHMsIG51bGwsIHRydWUpXG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaW5zdGFuY2UuX3UgPSBvcmlnaW5hbFxuICB9XG59XG4iLCJkZWZpbmUoIGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRyZXR1cm4gd2luZG93LmxvY2F0aW9uO1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vY29yZVwiLFxuXHRcIi4uL2NvcmUvc3RyaXBBbmRDb2xsYXBzZVwiLFxuXHRcIi4uL3Zhci9pc0Z1bmN0aW9uXCIsXG5cdFwiLi4vY29yZS9wYXJzZUhUTUxcIixcblx0XCIuLi9hamF4XCIsXG5cdFwiLi4vdHJhdmVyc2luZ1wiLFxuXHRcIi4uL21hbmlwdWxhdGlvblwiLFxuXHRcIi4uL3NlbGVjdG9yXCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnksIHN0cmlwQW5kQ29sbGFwc2UsIGlzRnVuY3Rpb24gKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbn0gKTtcbiIsImRlZmluZSggW1xuXHRcIi4uL0RhdGFcIlxuXSwgZnVuY3Rpb24oIERhdGEgKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHJldHVybiBuZXcgRGF0YSgpO1xufSApO1xuIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhcmVudCkge1xuICBpZiAocGFyZW50KXtcbiAgICByZXR1cm4gcGFyZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQsIHBhcmVudCk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1t0YXJnZXRdXG5cdH07XG59KSgpO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuICAgICAgICBpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlLCB0YXJnZXQpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXG5cdGlmKG9wdGlvbnMuYXR0cnMubm9uY2UgPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBub25jZSA9IGdldE5vbmNlKCk7XG5cdFx0aWYgKG5vbmNlKSB7XG5cdFx0XHRvcHRpb25zLmF0dHJzLm5vbmNlID0gbm9uY2U7XG5cdFx0fVxuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9uY2UoKSB7XG5cdGlmICh0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4gX193ZWJwYWNrX25vbmNlX187XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gdHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nXG5cdFx0ID8gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcykgXG5cdFx0IDogb3B0aW9ucy50cmFuc2Zvcm0uZGVmYXVsdChvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiIsImRlZmluZSggW1xuXHRcIi4uL2NvcmVcIixcblx0XCIuLi92YXIvZG9jdW1lbnRcIixcblx0XCIuL3Zhci9yc2luZ2xlVGFnXCIsXG5cdFwiLi4vbWFuaXB1bGF0aW9uL2J1aWxkRnJhZ21lbnRcIixcblxuXHQvLyBUaGlzIGlzIHRoZSBvbmx5IG1vZHVsZSB0aGF0IG5lZWRzIGNvcmUvc3VwcG9ydFxuXHRcIi4vc3VwcG9ydFwiXG5dLCBmdW5jdGlvbiggalF1ZXJ5LCBkb2N1bWVudCwgcnNpbmdsZVRhZywgYnVpbGRGcmFnbWVudCwgc3VwcG9ydCApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5yZXR1cm4galF1ZXJ5LnBhcnNlSFRNTDtcblxufSApO1xuIiwiLyohIEBsaWNlbnNlIFJlbWF0cml4IHYwLjMuMFxuXG5cdENvcHlyaWdodCAyMDE4IEp1bGlhbiBMbG95ZC5cblxuXHRQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5cdG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcblx0aW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuXHR0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5cdGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuXHRmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5cdFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5cdGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5cdFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcblx0SU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5cdEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuXHRBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5cdExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5cdE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblx0VEhFIFNPRlRXQVJFLlxuKi9cbi8qKlxuICogQG1vZHVsZSBSZW1hdHJpeFxuICovXG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gbWF0cmljZXMgaW4gdGhlIGJyb3dzZXIgY29tZSBpbiB0d28gZmxhdm9yczpcbiAqXG4gKiAgLSBgbWF0cml4YCB1c2luZyA2IHZhbHVlcyAoc2hvcnQpXG4gKiAgLSBgbWF0cml4M2RgIHVzaW5nIDE2IHZhbHVlcyAobG9uZylcbiAqXG4gKiBUaGlzIHV0aWxpdHkgZm9sbG93cyB0aGlzIFtjb252ZXJzaW9uIGd1aWRlXShodHRwczovL2dvby5nbC9FSmxVUTEpXG4gKiB0byBleHBhbmQgc2hvcnQgZm9ybSBtYXRyaWNlcyB0byB0aGVpciBlcXVpdmFsZW50IGxvbmcgZm9ybS5cbiAqXG4gKiBAcGFyYW0gIHthcnJheX0gc291cmNlIC0gQWNjZXB0cyBib3RoIHNob3J0IGFuZCBsb25nIGZvcm0gbWF0cmljZXMuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0KHNvdXJjZSkge1xuXHRpZiAoc291cmNlLmNvbnN0cnVjdG9yICE9PSBBcnJheSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFycmF5LicpXG5cdH1cblx0aWYgKHNvdXJjZS5sZW5ndGggPT09IDE2KSB7XG5cdFx0cmV0dXJuIHNvdXJjZVxuXHR9XG5cdGlmIChzb3VyY2UubGVuZ3RoID09PSA2KSB7XG5cdFx0dmFyIG1hdHJpeCA9IGlkZW50aXR5KCk7XG5cdFx0bWF0cml4WzBdID0gc291cmNlWzBdO1xuXHRcdG1hdHJpeFsxXSA9IHNvdXJjZVsxXTtcblx0XHRtYXRyaXhbNF0gPSBzb3VyY2VbMl07XG5cdFx0bWF0cml4WzVdID0gc291cmNlWzNdO1xuXHRcdG1hdHJpeFsxMl0gPSBzb3VyY2VbNF07XG5cdFx0bWF0cml4WzEzXSA9IHNvdXJjZVs1XTtcblx0XHRyZXR1cm4gbWF0cml4XG5cdH1cblx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0V4cGVjdGVkIGFycmF5IHdpdGggZWl0aGVyIDYgb3IgMTYgdmFsdWVzLicpXG59XG5cbi8qKlxuICogUmV0dXJucyBhIG1hdHJpeCByZXByZXNlbnRpbmcgbm8gdHJhbnNmb3JtYXRpb24uIFRoZSBwcm9kdWN0IG9mIGFueSBtYXRyaXhcbiAqIG11bHRpcGxpZWQgYnkgdGhlIGlkZW50aXR5IG1hdHJpeCB3aWxsIGJlIHRoZSBvcmlnaW5hbCBtYXRyaXguXG4gKlxuICogPiAqKlRpcDoqKiBTaW1pbGFyIHRvIGhvdyBgNSAqIDEgPT09IDVgLCB3aGVyZSBgMWAgaXMgdGhlIGlkZW50aXR5LlxuICpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSgpIHtcblx0dmFyIG1hdHJpeCA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0XHRpICUgNSA9PSAwID8gbWF0cml4LnB1c2goMSkgOiBtYXRyaXgucHVzaCgwKTtcblx0fVxuXHRyZXR1cm4gbWF0cml4XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG1hdHJpeCBkZXNjcmliaW5nIHRoZSBpbnZlcnNlIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBzb3VyY2VcbiAqIG1hdHJpeC4gVGhlIHByb2R1Y3Qgb2YgYW55IG1hdHJpeCBtdWx0aXBsaWVkIGJ5IGl0cyBpbnZlcnNlIHdpbGwgYmUgdGhlXG4gKiBpZGVudGl0eSBtYXRyaXguXG4gKlxuICogPiAqKlRpcDoqKiBTaW1pbGFyIHRvIGhvdyBgNSAqICgxLzUpID09PSAxYCwgd2hlcmUgYDEvNWAgaXMgdGhlIGludmVyc2UuXG4gKlxuICogQHBhcmFtICB7YXJyYXl9IHNvdXJjZSAtIEFjY2VwdHMgYm90aCBzaG9ydCBhbmQgbG9uZyBmb3JtIG1hdHJpY2VzLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGludmVyc2Uoc291cmNlKSB7XG5cdHZhciBtID0gZm9ybWF0KHNvdXJjZSk7XG5cblx0dmFyIHMwID0gbVswXSAqIG1bNV0gLSBtWzRdICogbVsxXTtcblx0dmFyIHMxID0gbVswXSAqIG1bNl0gLSBtWzRdICogbVsyXTtcblx0dmFyIHMyID0gbVswXSAqIG1bN10gLSBtWzRdICogbVszXTtcblx0dmFyIHMzID0gbVsxXSAqIG1bNl0gLSBtWzVdICogbVsyXTtcblx0dmFyIHM0ID0gbVsxXSAqIG1bN10gLSBtWzVdICogbVszXTtcblx0dmFyIHM1ID0gbVsyXSAqIG1bN10gLSBtWzZdICogbVszXTtcblxuXHR2YXIgYzUgPSBtWzEwXSAqIG1bMTVdIC0gbVsxNF0gKiBtWzExXTtcblx0dmFyIGM0ID0gbVs5XSAqIG1bMTVdIC0gbVsxM10gKiBtWzExXTtcblx0dmFyIGMzID0gbVs5XSAqIG1bMTRdIC0gbVsxM10gKiBtWzEwXTtcblx0dmFyIGMyID0gbVs4XSAqIG1bMTVdIC0gbVsxMl0gKiBtWzExXTtcblx0dmFyIGMxID0gbVs4XSAqIG1bMTRdIC0gbVsxMl0gKiBtWzEwXTtcblx0dmFyIGMwID0gbVs4XSAqIG1bMTNdIC0gbVsxMl0gKiBtWzldO1xuXG5cdHZhciBkZXRlcm1pbmFudCA9IDEgLyAoczAgKiBjNSAtIHMxICogYzQgKyBzMiAqIGMzICsgczMgKiBjMiAtIHM0ICogYzEgKyBzNSAqIGMwKTtcblxuXHRpZiAoaXNOYU4oZGV0ZXJtaW5hbnQpIHx8IGRldGVybWluYW50ID09PSBJbmZpbml0eSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignSW52ZXJzZSBkZXRlcm1pbmFudCBhdHRlbXB0ZWQgdG8gZGl2aWRlIGJ5IHplcm8uJylcblx0fVxuXG5cdHJldHVybiBbXG5cdFx0KG1bNV0gKiBjNSAtIG1bNl0gKiBjNCArIG1bN10gKiBjMykgKiBkZXRlcm1pbmFudCxcblx0XHQoLW1bMV0gKiBjNSArIG1bMl0gKiBjNCAtIG1bM10gKiBjMykgKiBkZXRlcm1pbmFudCxcblx0XHQobVsxM10gKiBzNSAtIG1bMTRdICogczQgKyBtWzE1XSAqIHMzKSAqIGRldGVybWluYW50LFxuXHRcdCgtbVs5XSAqIHM1ICsgbVsxMF0gKiBzNCAtIG1bMTFdICogczMpICogZGV0ZXJtaW5hbnQsXG5cblx0XHQoLW1bNF0gKiBjNSArIG1bNl0gKiBjMiAtIG1bN10gKiBjMSkgKiBkZXRlcm1pbmFudCxcblx0XHQobVswXSAqIGM1IC0gbVsyXSAqIGMyICsgbVszXSAqIGMxKSAqIGRldGVybWluYW50LFxuXHRcdCgtbVsxMl0gKiBzNSArIG1bMTRdICogczIgLSBtWzE1XSAqIHMxKSAqIGRldGVybWluYW50LFxuXHRcdChtWzhdICogczUgLSBtWzEwXSAqIHMyICsgbVsxMV0gKiBzMSkgKiBkZXRlcm1pbmFudCxcblxuXHRcdChtWzRdICogYzQgLSBtWzVdICogYzIgKyBtWzddICogYzApICogZGV0ZXJtaW5hbnQsXG5cdFx0KC1tWzBdICogYzQgKyBtWzFdICogYzIgLSBtWzNdICogYzApICogZGV0ZXJtaW5hbnQsXG5cdFx0KG1bMTJdICogczQgLSBtWzEzXSAqIHMyICsgbVsxNV0gKiBzMCkgKiBkZXRlcm1pbmFudCxcblx0XHQoLW1bOF0gKiBzNCArIG1bOV0gKiBzMiAtIG1bMTFdICogczApICogZGV0ZXJtaW5hbnQsXG5cblx0XHQoLW1bNF0gKiBjMyArIG1bNV0gKiBjMSAtIG1bNl0gKiBjMCkgKiBkZXRlcm1pbmFudCxcblx0XHQobVswXSAqIGMzIC0gbVsxXSAqIGMxICsgbVsyXSAqIGMwKSAqIGRldGVybWluYW50LFxuXHRcdCgtbVsxMl0gKiBzMyArIG1bMTNdICogczEgLSBtWzE0XSAqIHMwKSAqIGRldGVybWluYW50LFxuXHRcdChtWzhdICogczMgLSBtWzldICogczEgKyBtWzEwXSAqIHMwKSAqIGRldGVybWluYW50XG5cdF1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIHRoZSBjb21iaW5lZCB0cmFuc2Zvcm1hdGlvbnNcbiAqIG9mIGJvdGggYXJndW1lbnRzLlxuICpcbiAqID4gKipOb3RlOioqIE9yZGVyIGlzIHZlcnkgaW1wb3J0YW50LiBGb3IgZXhhbXBsZSwgcm90YXRpbmcgNDXCsFxuICogYWxvbmcgdGhlIFotYXhpcywgZm9sbG93ZWQgYnkgdHJhbnNsYXRpbmcgNTAwIHBpeGVscyBhbG9uZyB0aGVcbiAqIFktYXhpcy4uLiBpcyBub3QgdGhlIHNhbWUgYXMgdHJhbnNsYXRpbmcgNTAwIHBpeGVscyBhbG9uZyB0aGVcbiAqIFktYXhpcywgZm9sbG93ZWQgYnkgcm90YXRpbmcgNDXCsCBhbG9uZyBvbiB0aGUgWi1heGlzLlxuICpcbiAqIEBwYXJhbSAge2FycmF5fSBtIC0gQWNjZXB0cyBib3RoIHNob3J0IGFuZCBsb25nIGZvcm0gbWF0cmljZXMuXG4gKiBAcGFyYW0gIHthcnJheX0geCAtIEFjY2VwdHMgYm90aCBzaG9ydCBhbmQgbG9uZyBmb3JtIG1hdHJpY2VzLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG0sIHgpIHtcblx0dmFyIGZtID0gZm9ybWF0KG0pO1xuXHR2YXIgZnggPSBmb3JtYXQoeCk7XG5cdHZhciBwcm9kdWN0ID0gW107XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHR2YXIgcm93ID0gW2ZtW2ldLCBmbVtpICsgNF0sIGZtW2kgKyA4XSwgZm1baSArIDEyXV07XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspIHtcblx0XHRcdHZhciBrID0gaiAqIDQ7XG5cdFx0XHR2YXIgY29sID0gW2Z4W2tdLCBmeFtrICsgMV0sIGZ4W2sgKyAyXSwgZnhbayArIDNdXTtcblx0XHRcdHZhciByZXN1bHQgPVxuXHRcdFx0XHRyb3dbMF0gKiBjb2xbMF0gKyByb3dbMV0gKiBjb2xbMV0gKyByb3dbMl0gKiBjb2xbMl0gKyByb3dbM10gKiBjb2xbM107XG5cblx0XHRcdHByb2R1Y3RbaSArIGtdID0gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBwcm9kdWN0XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcmV0dXJuIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIHRoZSBDU1MgdHJhbnNmb3JtXG4gKiBtYXRyaXggcGFzc2VkIGluLCBidXQgd2lsbCByZXR1cm4gdGhlIGlkZW50aXR5IG1hdHJpeCBhcyBhXG4gKiBmYWxsYmFjay5cbiAqXG4gKiA+ICoqVGlwOioqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gY29udmVydCBhIENTUyBtYXRyaXggKHJldHJpZXZlZCBhcyBhXG4gKiBgc3RyaW5nYCBmcm9tIGNvbXB1dGVkIHN0eWxlcykgdG8gaXRzIGVxdWl2YWxlbnQgYXJyYXkgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc291cmNlIC0gYG1hdHJpeGAgb3IgYG1hdHJpeDNkYCBDU1MgVHJhbnNmb3JtIHZhbHVlLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHNvdXJjZSkge1xuXHRpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcblx0XHR2YXIgbWF0Y2ggPSBzb3VyY2UubWF0Y2goL21hdHJpeCgzZCk/XFwoKFteKV0rKVxcKS8pO1xuXHRcdGlmIChtYXRjaCkge1xuXHRcdFx0dmFyIHJhdyA9IG1hdGNoWzJdLnNwbGl0KCcsICcpLm1hcChwYXJzZUZsb2F0KTtcblx0XHRcdHJldHVybiBmb3JtYXQocmF3KVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gaWRlbnRpdHkoKVxufVxuXG4vKipcbiAqIFJldHVybnMgYSA0eDQgbWF0cml4IGRlc2NyaWJpbmcgWi1heGlzIHJvdGF0aW9uLlxuICpcbiAqID4gKipUaXA6KiogVGhpcyBpcyBqdXN0IGFuIGFsaWFzIGZvciBgUmVtYXRyaXgucm90YXRlWmAgZm9yIHBhcml0eSB3aXRoIENTU1xuICpcbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGUgLSBNZWFzdXJlZCBpbiBkZWdyZWVzLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZShhbmdsZSkge1xuXHRyZXR1cm4gcm90YXRlWihhbmdsZSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIFgtYXhpcyByb3RhdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlIC0gTWVhc3VyZWQgaW4gZGVncmVlcy5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiByb3RhdGVYKGFuZ2xlKSB7XG5cdHZhciB0aGV0YSA9IE1hdGguUEkgLyAxODAgKiBhbmdsZTtcblx0dmFyIG1hdHJpeCA9IGlkZW50aXR5KCk7XG5cblx0bWF0cml4WzVdID0gbWF0cml4WzEwXSA9IE1hdGguY29zKHRoZXRhKTtcblx0bWF0cml4WzZdID0gbWF0cml4WzldID0gTWF0aC5zaW4odGhldGEpO1xuXHRtYXRyaXhbOV0gKj0gLTE7XG5cblx0cmV0dXJuIG1hdHJpeFxufVxuXG4vKipcbiAqIFJldHVybnMgYSA0eDQgbWF0cml4IGRlc2NyaWJpbmcgWS1heGlzIHJvdGF0aW9uLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGUgLSBNZWFzdXJlZCBpbiBkZWdyZWVzLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVkoYW5nbGUpIHtcblx0dmFyIHRoZXRhID0gTWF0aC5QSSAvIDE4MCAqIGFuZ2xlO1xuXHR2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcblxuXHRtYXRyaXhbMF0gPSBtYXRyaXhbMTBdID0gTWF0aC5jb3ModGhldGEpO1xuXHRtYXRyaXhbMl0gPSBtYXRyaXhbOF0gPSBNYXRoLnNpbih0aGV0YSk7XG5cdG1hdHJpeFsyXSAqPSAtMTtcblxuXHRyZXR1cm4gbWF0cml4XG59XG5cbi8qKlxuICogUmV0dXJucyBhIDR4NCBtYXRyaXggZGVzY3JpYmluZyBaLWF4aXMgcm90YXRpb24uXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZSAtIE1lYXN1cmVkIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gcm90YXRlWihhbmdsZSkge1xuXHR2YXIgdGhldGEgPSBNYXRoLlBJIC8gMTgwICogYW5nbGU7XG5cdHZhciBtYXRyaXggPSBpZGVudGl0eSgpO1xuXG5cdG1hdHJpeFswXSA9IG1hdHJpeFs1XSA9IE1hdGguY29zKHRoZXRhKTtcblx0bWF0cml4WzFdID0gbWF0cml4WzRdID0gTWF0aC5zaW4odGhldGEpO1xuXHRtYXRyaXhbNF0gKj0gLTE7XG5cblx0cmV0dXJuIG1hdHJpeFxufVxuXG4vKipcbiAqIFJldHVybnMgYSA0eDQgbWF0cml4IGRlc2NyaWJpbmcgMkQgc2NhbGluZy4gVGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBpcyB1c2VkIGZvciBib3RoIFggYW5kIFktYXhpcyBzY2FsaW5nLCB1bmxlc3MgYW4gb3B0aW9uYWxcbiAqIHNlY29uZCBhcmd1bWVudCBpcyBwcm92aWRlZCB0byBleHBsaWNpdGx5IGRlZmluZSBZLWF4aXMgc2NhbGluZy5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHNjYWxhciAgICAtIERlY2ltYWwgbXVsdGlwbGllci5cbiAqIEBwYXJhbSAge251bWJlcn0gW3NjYWxhclldIC0gRGVjaW1hbCBtdWx0aXBsaWVyLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHNjYWxlKHNjYWxhciwgc2NhbGFyWSkge1xuXHR2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcblxuXHRtYXRyaXhbMF0gPSBzY2FsYXI7XG5cdG1hdHJpeFs1XSA9IHR5cGVvZiBzY2FsYXJZID09PSAnbnVtYmVyJyA/IHNjYWxhclkgOiBzY2FsYXI7XG5cblx0cmV0dXJuIG1hdHJpeFxufVxuXG4vKipcbiAqIFJldHVybnMgYSA0eDQgbWF0cml4IGRlc2NyaWJpbmcgWC1heGlzIHNjYWxpbmcuXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBzY2FsYXIgLSBEZWNpbWFsIG11bHRpcGxpZXIuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gc2NhbGVYKHNjYWxhcikge1xuXHR2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcblx0bWF0cml4WzBdID0gc2NhbGFyO1xuXHRyZXR1cm4gbWF0cml4XG59XG5cbi8qKlxuICogUmV0dXJucyBhIDR4NCBtYXRyaXggZGVzY3JpYmluZyBZLWF4aXMgc2NhbGluZy5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHNjYWxhciAtIERlY2ltYWwgbXVsdGlwbGllci5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiBzY2FsZVkoc2NhbGFyKSB7XG5cdHZhciBtYXRyaXggPSBpZGVudGl0eSgpO1xuXHRtYXRyaXhbNV0gPSBzY2FsYXI7XG5cdHJldHVybiBtYXRyaXhcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIFotYXhpcyBzY2FsaW5nLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gc2NhbGFyIC0gRGVjaW1hbCBtdWx0aXBsaWVyLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHNjYWxlWihzY2FsYXIpIHtcblx0dmFyIG1hdHJpeCA9IGlkZW50aXR5KCk7XG5cdG1hdHJpeFsxMF0gPSBzY2FsYXI7XG5cdHJldHVybiBtYXRyaXhcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIHNoZWFyLiBUaGUgZmlyc3QgYXJndW1lbnRcbiAqIGRlZmluZXMgWC1heGlzIHNoZWFyaW5nLCBhbmQgYW4gb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50XG4gKiBkZWZpbmVzIFktYXhpcyBzaGVhcmluZy5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlWCAgIC0gTWVhc3VyZWQgaW4gZGVncmVlcy5cbiAqIEBwYXJhbSAge251bWJlcn0gW2FuZ2xlWV0gLSBNZWFzdXJlZCBpbiBkZWdyZWVzLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHNrZXcoYW5nbGVYLCBhbmdsZVkpIHtcblx0dmFyIHRoZXRhWCA9IE1hdGguUEkgLyAxODAgKiBhbmdsZVg7XG5cdHZhciBtYXRyaXggPSBpZGVudGl0eSgpO1xuXG5cdG1hdHJpeFs0XSA9IE1hdGgudGFuKHRoZXRhWCk7XG5cblx0aWYgKGFuZ2xlWSkge1xuXHRcdHZhciB0aGV0YVkgPSBNYXRoLlBJIC8gMTgwICogYW5nbGVZO1xuXHRcdG1hdHJpeFsxXSA9IE1hdGgudGFuKHRoZXRhWSk7XG5cdH1cblxuXHRyZXR1cm4gbWF0cml4XG59XG5cbi8qKlxuICogUmV0dXJucyBhIDR4NCBtYXRyaXggZGVzY3JpYmluZyBYLWF4aXMgc2hlYXIuXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZSAtIE1lYXN1cmVkIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gc2tld1goYW5nbGUpIHtcblx0dmFyIHRoZXRhID0gTWF0aC5QSSAvIDE4MCAqIGFuZ2xlO1xuXHR2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcblxuXHRtYXRyaXhbNF0gPSBNYXRoLnRhbih0aGV0YSk7XG5cblx0cmV0dXJuIG1hdHJpeFxufVxuXG4vKipcbiAqIFJldHVybnMgYSA0eDQgbWF0cml4IGRlc2NyaWJpbmcgWS1heGlzIHNoZWFyLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGUgLSBNZWFzdXJlZCBpbiBkZWdyZWVzXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gc2tld1koYW5nbGUpIHtcblx0dmFyIHRoZXRhID0gTWF0aC5QSSAvIDE4MCAqIGFuZ2xlO1xuXHR2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcblxuXHRtYXRyaXhbMV0gPSBNYXRoLnRhbih0aGV0YSk7XG5cblx0cmV0dXJuIG1hdHJpeFxufVxuXG4vKipcbiAqIFJldHVybnMgYSBDU1MgVHJhbnNmb3JtIHByb3BlcnR5IHZhbHVlIGVxdWl2YWxlbnQgdG8gdGhlIHNvdXJjZSBtYXRyaXguXG4gKlxuICogQHBhcmFtICB7YXJyYXl9IHNvdXJjZSAtIEFjY2VwdHMgYm90aCBzaG9ydCBhbmQgbG9uZyBmb3JtIG1hdHJpY2VzLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b1N0cmluZyhzb3VyY2UpIHtcblx0cmV0dXJuIChcIm1hdHJpeDNkKFwiICsgKGZvcm1hdChzb3VyY2UpLmpvaW4oJywgJykpICsgXCIpXCIpXG59XG5cbi8qKlxuICogUmV0dXJucyBhIDR4NCBtYXRyaXggZGVzY3JpYmluZyAyRCB0cmFuc2xhdGlvbi4gVGhlIGZpcnN0XG4gKiBhcmd1bWVudCBkZWZpbmVzIFgtYXhpcyB0cmFuc2xhdGlvbiwgYW5kIGFuIG9wdGlvbmFsIHNlY29uZFxuICogYXJndW1lbnQgZGVmaW5lcyBZLWF4aXMgdHJhbnNsYXRpb24uXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBkaXN0YW5jZVggICAtIE1lYXN1cmVkIGluIHBpeGVscy5cbiAqIEBwYXJhbSAge251bWJlcn0gW2Rpc3RhbmNlWV0gLSBNZWFzdXJlZCBpbiBwaXhlbHMuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlKGRpc3RhbmNlWCwgZGlzdGFuY2VZKSB7XG5cdHZhciBtYXRyaXggPSBpZGVudGl0eSgpO1xuXHRtYXRyaXhbMTJdID0gZGlzdGFuY2VYO1xuXG5cdGlmIChkaXN0YW5jZVkpIHtcblx0XHRtYXRyaXhbMTNdID0gZGlzdGFuY2VZO1xuXHR9XG5cblx0cmV0dXJuIG1hdHJpeFxufVxuXG4vKipcbiAqIFJldHVybnMgYSA0eDQgbWF0cml4IGRlc2NyaWJpbmcgWC1heGlzIHRyYW5zbGF0aW9uLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gZGlzdGFuY2UgLSBNZWFzdXJlZCBpbiBwaXhlbHMuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlWChkaXN0YW5jZSkge1xuXHR2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcblx0bWF0cml4WzEyXSA9IGRpc3RhbmNlO1xuXHRyZXR1cm4gbWF0cml4XG59XG5cbi8qKlxuICogUmV0dXJucyBhIDR4NCBtYXRyaXggZGVzY3JpYmluZyBZLWF4aXMgdHJhbnNsYXRpb24uXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBkaXN0YW5jZSAtIE1lYXN1cmVkIGluIHBpeGVscy5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiB0cmFuc2xhdGVZKGRpc3RhbmNlKSB7XG5cdHZhciBtYXRyaXggPSBpZGVudGl0eSgpO1xuXHRtYXRyaXhbMTNdID0gZGlzdGFuY2U7XG5cdHJldHVybiBtYXRyaXhcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIFotYXhpcyB0cmFuc2xhdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGRpc3RhbmNlIC0gTWVhc3VyZWQgaW4gcGl4ZWxzLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zbGF0ZVooZGlzdGFuY2UpIHtcblx0dmFyIG1hdHJpeCA9IGlkZW50aXR5KCk7XG5cdG1hdHJpeFsxNF0gPSBkaXN0YW5jZTtcblx0cmV0dXJuIG1hdHJpeFxufVxuXG5leHBvcnQgeyBmb3JtYXQsIGlkZW50aXR5LCBpbnZlcnNlLCBtdWx0aXBseSwgcGFyc2UsIHJvdGF0ZSwgcm90YXRlWCwgcm90YXRlWSwgcm90YXRlWiwgc2NhbGUsIHNjYWxlWCwgc2NhbGVZLCBzY2FsZVosIHNrZXcsIHNrZXdYLCBza2V3WSwgdG9TdHJpbmcsIHRyYW5zbGF0ZSwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgdHJhbnNsYXRlWiB9O1xuIiwiLyohIEBsaWNlbnNlIFNjcm9sbFJldmVhbCB2NC4wLjVcblxuXHRDb3B5cmlnaHQgMjAxOCBGaXNzc2lvbiBMTEMuXG5cblx0TGljZW5zZWQgdW5kZXIgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIDMuMCBmb3Jcblx0Y29tcGF0aWJsZSBvcGVuIHNvdXJjZSBwcm9qZWN0cyBhbmQgbm9uLWNvbW1lcmNpYWwgdXNlLlxuXG5cdEZvciBjb21tZXJjaWFsIHNpdGVzLCB0aGVtZXMsIHByb2plY3RzLCBhbmQgYXBwbGljYXRpb25zLFxuXHRrZWVwIHlvdXIgc291cmNlIGNvZGUgcHJpdmF0ZS9wcm9wcmlldGFyeSBieSBwdXJjaGFzaW5nXG5cdGEgY29tbWVyY2lhbCBsaWNlbnNlIGZyb20gaHR0cHM6Ly9zY3JvbGxyZXZlYWxqcy5vcmcvXG4qL1xuaW1wb3J0ICQgZnJvbSAndGVhbGlnaHQnO1xuaW1wb3J0IHsgcGFyc2UsIG11bHRpcGx5LCByb3RhdGVYLCByb3RhdGVZLCByb3RhdGVaLCBzY2FsZSwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSB9IGZyb20gJ3JlbWF0cml4JztcbmltcG9ydCByYWYgZnJvbSAnbWluaXJhZic7XG5cbnZhciBkZWZhdWx0cyA9IHtcblx0ZGVsYXk6IDAsXG5cdGRpc3RhbmNlOiAnMCcsXG5cdGR1cmF0aW9uOiA2MDAsXG5cdGVhc2luZzogJ2N1YmljLWJlemllcigwLjUsIDAsIDAsIDEpJyxcblx0aW50ZXJ2YWw6IDAsXG5cdG9wYWNpdHk6IDAsXG5cdG9yaWdpbjogJ2JvdHRvbScsXG5cdHJvdGF0ZToge1xuXHRcdHg6IDAsXG5cdFx0eTogMCxcblx0XHR6OiAwXG5cdH0sXG5cdHNjYWxlOiAxLFxuXHRjbGVhbnVwOiBmYWxzZSxcblx0Y29udGFpbmVyOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdGRlc2t0b3A6IHRydWUsXG5cdG1vYmlsZTogdHJ1ZSxcblx0cmVzZXQ6IGZhbHNlLFxuXHR1c2VEZWxheTogJ2Fsd2F5cycsXG5cdHZpZXdGYWN0b3I6IDAuMCxcblx0dmlld09mZnNldDoge1xuXHRcdHRvcDogMCxcblx0XHRyaWdodDogMCxcblx0XHRib3R0b206IDAsXG5cdFx0bGVmdDogMFxuXHR9LFxuXHRhZnRlclJlc2V0OiBmdW5jdGlvbiBhZnRlclJlc2V0KCkge30sXG5cdGFmdGVyUmV2ZWFsOiBmdW5jdGlvbiBhZnRlclJldmVhbCgpIHt9LFxuXHRiZWZvcmVSZXNldDogZnVuY3Rpb24gYmVmb3JlUmVzZXQoKSB7fSxcblx0YmVmb3JlUmV2ZWFsOiBmdW5jdGlvbiBiZWZvcmVSZXZlYWwoKSB7fVxufVxuXG5mdW5jdGlvbiBmYWlsdXJlKCkge1xuXHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnc3InKTtcblxuXHRyZXR1cm4ge1xuXHRcdGNsZWFuOiBmdW5jdGlvbiBjbGVhbigpIHt9LFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fSxcblx0XHRyZXZlYWw6IGZ1bmN0aW9uIHJldmVhbCgpIHt9LFxuXHRcdHN5bmM6IGZ1bmN0aW9uIHN5bmMoKSB7fSxcblx0XHRnZXQgbm9vcCgpIHtcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHN1Y2Nlc3MoKSB7XG5cdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzcicpO1xuXG5cdGlmIChkb2N1bWVudC5ib2R5KSB7XG5cdFx0ZG9jdW1lbnQuYm9keS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cdH0gZWxzZSB7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdGRvY3VtZW50LmJvZHkuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXHRcdH0pO1xuXHR9XG59XG5cbnZhciBtb3VudCA9IHsgc3VjY2Vzczogc3VjY2VzcywgZmFpbHVyZTogZmFpbHVyZSB9XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcblx0cmV0dXJuIChcblx0XHR4ICE9PSBudWxsICYmXG5cdFx0eCBpbnN0YW5jZW9mIE9iamVjdCAmJlxuXHRcdCh4LmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHxcblx0XHRcdE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpXG5cdClcbn1cblxuZnVuY3Rpb24gZWFjaChjb2xsZWN0aW9uLCBjYWxsYmFjaykge1xuXHRpZiAoaXNPYmplY3QoY29sbGVjdGlvbikpIHtcblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pO1xuXHRcdHJldHVybiBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY2FsbGJhY2soY29sbGVjdGlvbltrZXldLCBrZXksIGNvbGxlY3Rpb24pOyB9KVxuXHR9XG5cdGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7IHJldHVybiBjYWxsYmFjayhpdGVtLCBpLCBjb2xsZWN0aW9uKTsgfSlcblx0fVxuXHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBlaXRoZXIgYW4gYXJyYXkgb3Igb2JqZWN0IGxpdGVyYWwuJylcbn1cblxuZnVuY3Rpb24gbG9nZ2VyKG1lc3NhZ2UpIHtcblx0dmFyIGRldGFpbHMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cdHdoaWxlICggbGVuLS0gPiAwICkgZGV0YWlsc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuXHRpZiAodGhpcy5jb25zdHJ1Y3Rvci5kZWJ1ZyAmJiBjb25zb2xlKSB7XG5cdFx0dmFyIHJlcG9ydCA9IFwiJWNTY3JvbGxSZXZlYWw6IFwiICsgbWVzc2FnZTtcblx0XHRkZXRhaWxzLmZvckVhY2goZnVuY3Rpb24gKGRldGFpbCkgeyByZXR1cm4gKHJlcG9ydCArPSBcIlxcbiDigJQgXCIgKyBkZXRhaWwpOyB9KTtcblx0XHRjb25zb2xlLmxvZyhyZXBvcnQsICdjb2xvcjogI2VhNjU0YjsnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdH1cbn1cblxuZnVuY3Rpb24gcmluc2UoKSB7XG5cdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdHZhciBzdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuXHRcdGFjdGl2ZTogW10sXG5cdFx0c3RhbGU6IFtdXG5cdH0pOyB9O1xuXG5cdHZhciBlbGVtZW50SWRzID0gc3RydWN0KCk7XG5cdHZhciBzZXF1ZW5jZUlkcyA9IHN0cnVjdCgpO1xuXHR2YXIgY29udGFpbmVySWRzID0gc3RydWN0KCk7XG5cblx0LyoqXG5cdCAqIFRha2Ugc3RvY2sgb2YgYWN0aXZlIGVsZW1lbnQgSURzLlxuXHQgKi9cblx0dHJ5IHtcblx0XHRlYWNoKCQoJ1tkYXRhLXNyLWlkXScpLCBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0dmFyIGlkID0gcGFyc2VJbnQobm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3ItaWQnKSk7XG5cdFx0XHRlbGVtZW50SWRzLmFjdGl2ZS5wdXNoKGlkKTtcblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHRocm93IGVcblx0fVxuXHQvKipcblx0ICogRGVzdHJveSBzdGFsZSBlbGVtZW50cy5cblx0ICovXG5cdGVhY2godGhpcy5zdG9yZS5lbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRpZiAoZWxlbWVudElkcy5hY3RpdmUuaW5kZXhPZihlbGVtZW50LmlkKSA9PT0gLTEpIHtcblx0XHRcdGVsZW1lbnRJZHMuc3RhbGUucHVzaChlbGVtZW50LmlkKTtcblx0XHR9XG5cdH0pO1xuXG5cdGVhY2goZWxlbWVudElkcy5zdGFsZSwgZnVuY3Rpb24gKHN0YWxlSWQpIHsgcmV0dXJuIGRlbGV0ZSB0aGlzJDEuc3RvcmUuZWxlbWVudHNbc3RhbGVJZF07IH0pO1xuXG5cdC8qKlxuXHQgKiBUYWtlIHN0b2NrIG9mIGFjdGl2ZSBjb250YWluZXIgYW5kIHNlcXVlbmNlIElEcy5cblx0ICovXG5cdGVhY2godGhpcy5zdG9yZS5lbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRpZiAoY29udGFpbmVySWRzLmFjdGl2ZS5pbmRleE9mKGVsZW1lbnQuY29udGFpbmVySWQpID09PSAtMSkge1xuXHRcdFx0Y29udGFpbmVySWRzLmFjdGl2ZS5wdXNoKGVsZW1lbnQuY29udGFpbmVySWQpO1xuXHRcdH1cblx0XHRpZiAoZWxlbWVudC5oYXNPd25Qcm9wZXJ0eSgnc2VxdWVuY2UnKSkge1xuXHRcdFx0aWYgKHNlcXVlbmNlSWRzLmFjdGl2ZS5pbmRleE9mKGVsZW1lbnQuc2VxdWVuY2UuaWQpID09PSAtMSkge1xuXHRcdFx0XHRzZXF1ZW5jZUlkcy5hY3RpdmUucHVzaChlbGVtZW50LnNlcXVlbmNlLmlkKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95IHN0YWxlIGNvbnRhaW5lcnMuXG5cdCAqL1xuXHRlYWNoKHRoaXMuc3RvcmUuY29udGFpbmVycywgZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdGlmIChjb250YWluZXJJZHMuYWN0aXZlLmluZGV4T2YoY29udGFpbmVyLmlkKSA9PT0gLTEpIHtcblx0XHRcdGNvbnRhaW5lcklkcy5zdGFsZS5wdXNoKGNvbnRhaW5lci5pZCk7XG5cdFx0fVxuXHR9KTtcblxuXHRlYWNoKGNvbnRhaW5lcklkcy5zdGFsZSwgZnVuY3Rpb24gKHN0YWxlSWQpIHtcblx0XHR2YXIgc3RhbGUgPSB0aGlzJDEuc3RvcmUuY29udGFpbmVyc1tzdGFsZUlkXS5ub2RlO1xuXHRcdHN0YWxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMkMS5kZWxlZ2F0ZSk7XG5cdFx0c3RhbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcyQxLmRlbGVnYXRlKTtcblx0XHRkZWxldGUgdGhpcyQxLnN0b3JlLmNvbnRhaW5lcnNbc3RhbGVJZF07XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95IHN0YWxlIHNlcXVlbmNlcy5cblx0ICovXG5cdGVhY2godGhpcy5zdG9yZS5zZXF1ZW5jZXMsIGZ1bmN0aW9uIChzZXF1ZW5jZSkge1xuXHRcdGlmIChzZXF1ZW5jZUlkcy5hY3RpdmUuaW5kZXhPZihzZXF1ZW5jZS5pZCkgPT09IC0xKSB7XG5cdFx0XHRzZXF1ZW5jZUlkcy5zdGFsZS5wdXNoKHNlcXVlbmNlLmlkKTtcblx0XHR9XG5cdH0pO1xuXG5cdGVhY2goc2VxdWVuY2VJZHMuc3RhbGUsIGZ1bmN0aW9uIChzdGFsZUlkKSB7IHJldHVybiBkZWxldGUgdGhpcyQxLnN0b3JlLnNlcXVlbmNlc1tzdGFsZUlkXTsgfSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFuKHRhcmdldCkge1xuXHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHR2YXIgZGlydHk7XG5cdHRyeSB7XG5cdFx0ZWFjaCgkKHRhcmdldCksIGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHR2YXIgaWQgPSBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1zci1pZCcpO1xuXHRcdFx0aWYgKGlkICE9PSBudWxsKSB7XG5cdFx0XHRcdGRpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzJDEuc3RvcmUuZWxlbWVudHNbaWRdO1xuXHRcdFx0XHRpZiAoZWxlbWVudC5jYWxsYmFja1RpbWVyKSB7XG5cdFx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dChlbGVtZW50LmNhbGxiYWNrVGltZXIuY2xvY2spO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdzdHlsZScsIGVsZW1lbnQuc3R5bGVzLmlubGluZS5nZW5lcmF0ZWQpO1xuXHRcdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1zci1pZCcpO1xuXHRcdFx0XHRkZWxldGUgdGhpcyQxLnN0b3JlLmVsZW1lbnRzW2lkXTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBsb2dnZXIuY2FsbCh0aGlzLCAnQ2xlYW4gZmFpbGVkLicsIGUubWVzc2FnZSlcblx0fVxuXG5cdGlmIChkaXJ0eSkge1xuXHRcdHRyeSB7XG5cdFx0XHRyaW5zZS5jYWxsKHRoaXMpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBsb2dnZXIuY2FsbCh0aGlzLCAnQ2xlYW4gZmFpbGVkLicsIGUubWVzc2FnZSlcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgZ2VuZXJhdGVkIHN0eWxlcyBhbmQgZWxlbWVudCBpZHNcblx0ICovXG5cdGVhY2godGhpcy5zdG9yZS5lbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRlbGVtZW50Lm5vZGUuc2V0QXR0cmlidXRlKCdzdHlsZScsIGVsZW1lbnQuc3R5bGVzLmlubGluZS5nZW5lcmF0ZWQpO1xuXHRcdGVsZW1lbnQubm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtc3ItaWQnKTtcblx0fSk7XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgZXZlbnQgbGlzdGVuZXJzLlxuXHQgKi9cblx0ZWFjaCh0aGlzLnN0b3JlLmNvbnRhaW5lcnMsIGZ1bmN0aW9uIChjb250YWluZXIpIHtcblx0XHR2YXIgdGFyZ2V0ID1cblx0XHRcdGNvbnRhaW5lci5ub2RlID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyB3aW5kb3cgOiBjb250YWluZXIubm9kZTtcblx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcyQxLmRlbGVnYXRlKTtcblx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcyQxLmRlbGVnYXRlKTtcblx0fSk7XG5cblx0LyoqXG5cdCAqIENsZWFyIGFsbCBkYXRhIGZyb20gdGhlIHN0b3JlXG5cdCAqL1xuXHR0aGlzLnN0b3JlID0ge1xuXHRcdGNvbnRhaW5lcnM6IHt9LFxuXHRcdGVsZW1lbnRzOiB7fSxcblx0XHRoaXN0b3J5OiBbXSxcblx0XHRzZXF1ZW5jZXM6IHt9XG5cdH07XG59XG5cbnZhciBnZXRQcmVmaXhlZENzc1Byb3AgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgcHJvcGVydGllcyA9IHt9O1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5cblx0ZnVuY3Rpb24gZ2V0UHJlZml4ZWRDc3NQcm9wZXJ0eShuYW1lLCBzb3VyY2UpIHtcblx0XHRpZiAoIHNvdXJjZSA9PT0gdm9pZCAwICkgc291cmNlID0gc3R5bGU7XG5cblx0XHRpZiAobmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGlmIChwcm9wZXJ0aWVzW25hbWVdKSB7XG5cdFx0XHRcdHJldHVybiBwcm9wZXJ0aWVzW25hbWVdXG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIHNvdXJjZVtuYW1lXSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cmV0dXJuIChwcm9wZXJ0aWVzW25hbWVdID0gbmFtZSlcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2Ygc291cmNlWyhcIi13ZWJraXQtXCIgKyBuYW1lKV0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHJldHVybiAocHJvcGVydGllc1tuYW1lXSA9IFwiLXdlYmtpdC1cIiArIG5hbWUpXG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcigoXCJVbmFibGUgdG8gZmluZCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIHN0eWxlIHByb3BlcnR5LlwiKSlcblx0XHR9XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcuJylcblx0fVxuXG5cdGdldFByZWZpeGVkQ3NzUHJvcGVydHkuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChwcm9wZXJ0aWVzID0ge30pOyB9O1xuXG5cdHJldHVybiBnZXRQcmVmaXhlZENzc1Byb3BlcnR5XG59KSgpO1xuXG5mdW5jdGlvbiBzdHlsZShlbGVtZW50KSB7XG5cdHZhciBjb21wdXRlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQubm9kZSk7XG5cdHZhciBwb3NpdGlvbiA9IGNvbXB1dGVkLnBvc2l0aW9uO1xuXHR2YXIgY29uZmlnID0gZWxlbWVudC5jb25maWc7XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGlubGluZSBzdHlsZXNcblx0ICovXG5cdHZhciBpbmxpbmUgPSB7fTtcblx0dmFyIGlubGluZVN0eWxlID0gZWxlbWVudC5ub2RlLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJztcblx0dmFyIGlubGluZU1hdGNoID0gaW5saW5lU3R5bGUubWF0Y2goL1tcXHctXStcXHMqOlxccypbXjtdK1xccyovZ2kpIHx8IFtdO1xuXG5cdGlubGluZS5jb21wdXRlZCA9IGlubGluZU1hdGNoID8gaW5saW5lTWF0Y2gubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnRyaW0oKTsgfSkuam9pbignOyAnKSArICc7JyA6ICcnO1xuXG5cdGlubGluZS5nZW5lcmF0ZWQgPSBpbmxpbmVNYXRjaC5zb21lKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLm1hdGNoKC92aXNpYmlsaXR5XFxzPzpcXHM/dmlzaWJsZS9pKTsgfSlcblx0XHQ/IGlubGluZS5jb21wdXRlZFxuXHRcdDogaW5saW5lTWF0Y2guY29uY2F0KCBbJ3Zpc2liaWxpdHk6IHZpc2libGUnXSkubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnRyaW0oKTsgfSkuam9pbignOyAnKSArICc7JztcblxuXHQvKipcblx0ICogR2VuZXJhdGUgb3BhY2l0eSBzdHlsZXNcblx0ICovXG5cdHZhciBjb21wdXRlZE9wYWNpdHkgPSBwYXJzZUZsb2F0KGNvbXB1dGVkLm9wYWNpdHkpO1xuXHR2YXIgY29uZmlnT3BhY2l0eSA9ICFpc05hTihwYXJzZUZsb2F0KGNvbmZpZy5vcGFjaXR5KSlcblx0XHQ/IHBhcnNlRmxvYXQoY29uZmlnLm9wYWNpdHkpXG5cdFx0OiBwYXJzZUZsb2F0KGNvbXB1dGVkLm9wYWNpdHkpO1xuXG5cdHZhciBvcGFjaXR5ID0ge1xuXHRcdGNvbXB1dGVkOiBjb21wdXRlZE9wYWNpdHkgIT09IGNvbmZpZ09wYWNpdHkgPyAoXCJvcGFjaXR5OiBcIiArIGNvbXB1dGVkT3BhY2l0eSArIFwiO1wiKSA6ICcnLFxuXHRcdGdlbmVyYXRlZDogY29tcHV0ZWRPcGFjaXR5ICE9PSBjb25maWdPcGFjaXR5ID8gKFwib3BhY2l0eTogXCIgKyBjb25maWdPcGFjaXR5ICsgXCI7XCIpIDogJydcblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGUgdHJhbnNmb3JtYXRpb24gc3R5bGVzXG5cdCAqL1xuXHR2YXIgdHJhbnNmb3JtYXRpb25zID0gW107XG5cblx0aWYgKHBhcnNlRmxvYXQoY29uZmlnLmRpc3RhbmNlKSkge1xuXHRcdHZhciBheGlzID0gY29uZmlnLm9yaWdpbiA9PT0gJ3RvcCcgfHwgY29uZmlnLm9yaWdpbiA9PT0gJ2JvdHRvbScgPyAnWScgOiAnWCc7XG5cblx0XHQvKipcblx0XHQgKiBMZXTigJlzIG1ha2Ugc3VyZSBvdXIgb3VyIHBpeGVsIGRpc3RhbmNlcyBhcmUgbmVnYXRpdmUgZm9yIHRvcCBhbmQgbGVmdC5cblx0XHQgKiBlLmcuIHsgb3JpZ2luOiAndG9wJywgZGlzdGFuY2U6ICcyNXB4JyB9IHN0YXJ0cyBhdCBgdG9wOiAtMjVweGAgaW4gQ1NTLlxuXHRcdCAqL1xuXHRcdHZhciBkaXN0YW5jZSA9IGNvbmZpZy5kaXN0YW5jZTtcblx0XHRpZiAoY29uZmlnLm9yaWdpbiA9PT0gJ3RvcCcgfHwgY29uZmlnLm9yaWdpbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRkaXN0YW5jZSA9IC9eLS8udGVzdChkaXN0YW5jZSkgPyBkaXN0YW5jZS5zdWJzdHIoMSkgOiAoXCItXCIgKyBkaXN0YW5jZSk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlZiA9IGRpc3RhbmNlLm1hdGNoKC8oXi0/XFxkK1xcLj9cXGQ/KXwoZW0kfHB4JHwlJCkvZyk7XG5cdFx0dmFyIHZhbHVlID0gcmVmWzBdO1xuXHRcdHZhciB1bml0ID0gcmVmWzFdO1xuXG5cdFx0c3dpdGNoICh1bml0KSB7XG5cdFx0XHRjYXNlICdlbSc6XG5cdFx0XHRcdGRpc3RhbmNlID0gcGFyc2VJbnQoY29tcHV0ZWQuZm9udFNpemUpICogdmFsdWU7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdweCc6XG5cdFx0XHRcdGRpc3RhbmNlID0gdmFsdWU7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICclJzpcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEhlcmUgd2UgdXNlIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIGluc3RlYWQgb2Zcblx0XHRcdFx0ICogdGhlIGV4aXN0aW5nIGRhdGEgYXR0YWNoZWQgdG8gYGVsZW1lbnQuZ2VvbWV0cnlgXG5cdFx0XHRcdCAqIGJlY2F1c2Ugb25seSB0aGUgZm9ybWVyIGluY2x1ZGVzIGFueSB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdFx0ICogY3VycmVudCBhcHBsaWVkIHRvIHRoZSBlbGVtZW50LlxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiBJZiB0aGF0IGJlaGF2aW9yIGVuZHMgdXAgYmVpbmcgdW5pbnR1aXRpdmUsIHRoaXNcblx0XHRcdFx0ICogbG9naWMgY291bGQgaW5zdGVhZCB1dGlsaXplIGBlbGVtZW50Lmdlb21ldHJ5LmhlaWdodGBcblx0XHRcdFx0ICogYW5kIGBlbGVtZW50Lmdlb2VtZXRyeS53aWR0aGAgZm9yIHRoZSBkaXN0YWluY2UgY2FsY3VsYXRpb25cblx0XHRcdFx0ICovXG5cdFx0XHRcdGRpc3RhbmNlID1cblx0XHRcdFx0XHRheGlzID09PSAnWSdcblx0XHRcdFx0XHRcdD8gZWxlbWVudC5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCAqIHZhbHVlIC8gMTAwXG5cdFx0XHRcdFx0XHQ6IGVsZW1lbnQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAqIHZhbHVlIC8gMTAwO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1VucmVjb2duaXplZCBvciBtaXNzaW5nIGRpc3RhbmNlIHVuaXQuJylcblx0XHR9XG5cblx0XHRpZiAoYXhpcyA9PT0gJ1knKSB7XG5cdFx0XHR0cmFuc2Zvcm1hdGlvbnMucHVzaCh0cmFuc2xhdGVZKGRpc3RhbmNlKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRyYW5zZm9ybWF0aW9ucy5wdXNoKHRyYW5zbGF0ZVgoZGlzdGFuY2UpKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoY29uZmlnLnJvdGF0ZS54KSB7IHRyYW5zZm9ybWF0aW9ucy5wdXNoKHJvdGF0ZVgoY29uZmlnLnJvdGF0ZS54KSk7IH1cblx0aWYgKGNvbmZpZy5yb3RhdGUueSkgeyB0cmFuc2Zvcm1hdGlvbnMucHVzaChyb3RhdGVZKGNvbmZpZy5yb3RhdGUueSkpOyB9XG5cdGlmIChjb25maWcucm90YXRlLnopIHsgdHJhbnNmb3JtYXRpb25zLnB1c2gocm90YXRlWihjb25maWcucm90YXRlLnopKTsgfVxuXHRpZiAoY29uZmlnLnNjYWxlICE9PSAxKSB7XG5cdFx0aWYgKGNvbmZpZy5zY2FsZSA9PT0gMCkge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgQ1NTIFRyYW5zZm9ybXMgbWF0cml4IGludGVycG9sYXRpb24gc3BlY2lmaWNhdGlvblxuXHRcdFx0ICogYmFzaWNhbGx5IGRpc2FsbG93cyB0cmFuc2l0aW9ucyBvZiBub24taW52ZXJ0aWJsZVxuXHRcdFx0ICogbWF0cml4ZXMsIHdoaWNoIG1lYW5zIGJyb3dzZXJzIHdvbid0IHRyYW5zaXRpb25cblx0XHRcdCAqIGVsZW1lbnRzIHdpdGggemVybyBzY2FsZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGF04oCZcyBpbmNvbnZlbmllbnQgZm9yIHRoZSBBUEkgYW5kIGRldmVsb3BlclxuXHRcdFx0ICogZXhwZXJpZW5jZSwgc28gd2Ugc2ltcGx5IG51ZGdlIHRoZWlyIHZhbHVlXG5cdFx0XHQgKiBzbGlnaHRseSBhYm92ZSB6ZXJvOyB0aGlzIGFsbG93cyBicm93c2Vyc1xuXHRcdFx0ICogdG8gdHJhbnNpdGlvbiBvdXIgZWxlbWVudCBhcyBleHBlY3RlZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBgMC4wMDAyYCB3YXMgdGhlIHNtYWxsZXN0IG51bWJlclxuXHRcdFx0ICogdGhhdCBwZXJmb3JtZWQgYWNyb3NzIGJyb3dzZXJzLlxuXHRcdFx0ICovXG5cdFx0XHR0cmFuc2Zvcm1hdGlvbnMucHVzaChzY2FsZSgwLjAwMDIpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dHJhbnNmb3JtYXRpb25zLnB1c2goc2NhbGUoY29uZmlnLnNjYWxlKSk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIHRyYW5zZm9ybSA9IHt9O1xuXHRpZiAodHJhbnNmb3JtYXRpb25zLmxlbmd0aCkge1xuXHRcdHRyYW5zZm9ybS5wcm9wZXJ0eSA9IGdldFByZWZpeGVkQ3NzUHJvcCgndHJhbnNmb3JtJyk7XG5cdFx0LyoqXG5cdFx0ICogVGhlIGRlZmF1bHQgY29tcHV0ZWQgdHJhbnNmb3JtIHZhbHVlIHNob3VsZCBiZSBvbmUgb2Y6XG5cdFx0ICogdW5kZWZpbmVkIHx8ICdub25lJyB8fCAnbWF0cml4KCknIHx8ICdtYXRyaXgzZCgpJ1xuXHRcdCAqL1xuXHRcdHRyYW5zZm9ybS5jb21wdXRlZCA9IHtcblx0XHRcdHJhdzogY29tcHV0ZWRbdHJhbnNmb3JtLnByb3BlcnR5XSxcblx0XHRcdG1hdHJpeDogcGFyc2UoY29tcHV0ZWRbdHJhbnNmb3JtLnByb3BlcnR5XSlcblx0XHR9O1xuXG5cdFx0dHJhbnNmb3JtYXRpb25zLnVuc2hpZnQodHJhbnNmb3JtLmNvbXB1dGVkLm1hdHJpeCk7XG5cdFx0dmFyIHByb2R1Y3QgPSB0cmFuc2Zvcm1hdGlvbnMucmVkdWNlKG11bHRpcGx5KTtcblxuXHRcdHRyYW5zZm9ybS5nZW5lcmF0ZWQgPSB7XG5cdFx0XHRpbml0aWFsOiAoKHRyYW5zZm9ybS5wcm9wZXJ0eSkgKyBcIjogbWF0cml4M2QoXCIgKyAocHJvZHVjdC5qb2luKCcsICcpKSArIFwiKTtcIiksXG5cdFx0XHRmaW5hbDogKCh0cmFuc2Zvcm0ucHJvcGVydHkpICsgXCI6IG1hdHJpeDNkKFwiICsgKHRyYW5zZm9ybS5jb21wdXRlZC5tYXRyaXguam9pbihcblx0XHRcdFx0JywgJ1xuXHRcdFx0KSkgKyBcIik7XCIpXG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHR0cmFuc2Zvcm0uZ2VuZXJhdGVkID0ge1xuXHRcdFx0aW5pdGlhbDogJycsXG5cdFx0XHRmaW5hbDogJydcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIHRyYW5zaXRpb24gc3R5bGVzXG5cdCAqL1xuXHR2YXIgdHJhbnNpdGlvbiA9IHt9O1xuXHRpZiAob3BhY2l0eS5nZW5lcmF0ZWQgfHwgdHJhbnNmb3JtLmdlbmVyYXRlZC5pbml0aWFsKSB7XG5cdFx0dHJhbnNpdGlvbi5wcm9wZXJ0eSA9IGdldFByZWZpeGVkQ3NzUHJvcCgndHJhbnNpdGlvbicpO1xuXHRcdHRyYW5zaXRpb24uY29tcHV0ZWQgPSBjb21wdXRlZFt0cmFuc2l0aW9uLnByb3BlcnR5XTtcblx0XHR0cmFuc2l0aW9uLmZyYWdtZW50cyA9IFtdO1xuXG5cdFx0dmFyIGRlbGF5ID0gY29uZmlnLmRlbGF5O1xuXHRcdHZhciBkdXJhdGlvbiA9IGNvbmZpZy5kdXJhdGlvbjtcblx0XHR2YXIgZWFzaW5nID0gY29uZmlnLmVhc2luZztcblxuXHRcdGlmIChvcGFjaXR5LmdlbmVyYXRlZCkge1xuXHRcdFx0dHJhbnNpdGlvbi5mcmFnbWVudHMucHVzaCh7XG5cdFx0XHRcdGRlbGF5ZWQ6IChcIm9wYWNpdHkgXCIgKyAoZHVyYXRpb24gLyAxMDAwKSArIFwicyBcIiArIGVhc2luZyArIFwiIFwiICsgKGRlbGF5IC8gMTAwMCkgKyBcInNcIiksXG5cdFx0XHRcdGluc3RhbnQ6IChcIm9wYWNpdHkgXCIgKyAoZHVyYXRpb24gLyAxMDAwKSArIFwicyBcIiArIGVhc2luZyArIFwiIDBzXCIpXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAodHJhbnNmb3JtLmdlbmVyYXRlZC5pbml0aWFsKSB7XG5cdFx0XHR0cmFuc2l0aW9uLmZyYWdtZW50cy5wdXNoKHtcblx0XHRcdFx0ZGVsYXllZDogKCh0cmFuc2Zvcm0ucHJvcGVydHkpICsgXCIgXCIgKyAoZHVyYXRpb24gLyAxMDAwKSArIFwicyBcIiArIGVhc2luZyArIFwiIFwiICsgKGRlbGF5IC9cblx0XHRcdFx0XHQxMDAwKSArIFwic1wiKSxcblx0XHRcdFx0aW5zdGFudDogKCh0cmFuc2Zvcm0ucHJvcGVydHkpICsgXCIgXCIgKyAoZHVyYXRpb24gLyAxMDAwKSArIFwicyBcIiArIGVhc2luZyArIFwiIDBzXCIpXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZGVmYXVsdCBjb21wdXRlZCB0cmFuc2l0aW9uIHByb3BlcnR5IHNob3VsZCBiZSBvbmUgb2Y6XG5cdFx0ICogdW5kZWZpbmVkIHx8ICcnIHx8ICdhbGwgMHMgZWFzZSAwcycgfHwgJ2FsbCAwcyAwcyBjdWJpYy1iZXppZXIoKSdcblx0XHQgKi9cblx0XHRpZiAodHJhbnNpdGlvbi5jb21wdXRlZCAmJiAhdHJhbnNpdGlvbi5jb21wdXRlZC5tYXRjaCgvYWxsIDBzLykpIHtcblx0XHRcdHRyYW5zaXRpb24uZnJhZ21lbnRzLnVuc2hpZnQoe1xuXHRcdFx0XHRkZWxheWVkOiB0cmFuc2l0aW9uLmNvbXB1dGVkLFxuXHRcdFx0XHRpbnN0YW50OiB0cmFuc2l0aW9uLmNvbXB1dGVkXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgY29tcG9zZWQgPSB0cmFuc2l0aW9uLmZyYWdtZW50cy5yZWR1Y2UoXG5cdFx0XHRmdW5jdGlvbiAoY29tcG9zaXRpb24sIGZyYWdtZW50LCBpKSB7XG5cdFx0XHRcdGNvbXBvc2l0aW9uLmRlbGF5ZWQgKz1cblx0XHRcdFx0XHRpID09PSAwID8gZnJhZ21lbnQuZGVsYXllZCA6IChcIiwgXCIgKyAoZnJhZ21lbnQuZGVsYXllZCkpO1xuXHRcdFx0XHRjb21wb3NpdGlvbi5pbnN0YW50ICs9XG5cdFx0XHRcdFx0aSA9PT0gMCA/IGZyYWdtZW50Lmluc3RhbnQgOiAoXCIsIFwiICsgKGZyYWdtZW50Lmluc3RhbnQpKTtcblx0XHRcdFx0cmV0dXJuIGNvbXBvc2l0aW9uXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRkZWxheWVkOiAnJyxcblx0XHRcdFx0aW5zdGFudDogJydcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0dHJhbnNpdGlvbi5nZW5lcmF0ZWQgPSB7XG5cdFx0XHRkZWxheWVkOiAoKHRyYW5zaXRpb24ucHJvcGVydHkpICsgXCI6IFwiICsgKGNvbXBvc2VkLmRlbGF5ZWQpICsgXCI7XCIpLFxuXHRcdFx0aW5zdGFudDogKCh0cmFuc2l0aW9uLnByb3BlcnR5KSArIFwiOiBcIiArIChjb21wb3NlZC5pbnN0YW50KSArIFwiO1wiKVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0dHJhbnNpdGlvbi5nZW5lcmF0ZWQgPSB7XG5cdFx0XHRkZWxheWVkOiAnJyxcblx0XHRcdGluc3RhbnQ6ICcnXG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0aW5saW5lOiBpbmxpbmUsXG5cdFx0b3BhY2l0eTogb3BhY2l0eSxcblx0XHRwb3NpdGlvbjogcG9zaXRpb24sXG5cdFx0dHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG5cdFx0dHJhbnNpdGlvbjogdHJhbnNpdGlvblxuXHR9XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGUoZWxlbWVudCwgZm9yY2UpIHtcblx0aWYgKCBmb3JjZSA9PT0gdm9pZCAwICkgZm9yY2UgPSB7fTtcblxuXHR2YXIgcHJpc3RpbmUgPSBmb3JjZS5wcmlzdGluZSB8fCB0aGlzLnByaXN0aW5lO1xuXHR2YXIgZGVsYXllZCA9XG5cdFx0ZWxlbWVudC5jb25maWcudXNlRGVsYXkgPT09ICdhbHdheXMnIHx8XG5cdFx0KGVsZW1lbnQuY29uZmlnLnVzZURlbGF5ID09PSAnb25sb2FkJyAmJiBwcmlzdGluZSkgfHxcblx0XHQoZWxlbWVudC5jb25maWcudXNlRGVsYXkgPT09ICdvbmNlJyAmJiAhZWxlbWVudC5zZWVuKTtcblxuXHR2YXIgc2hvdWxkUmV2ZWFsID0gZWxlbWVudC52aXNpYmxlICYmICFlbGVtZW50LnJldmVhbGVkO1xuXHR2YXIgc2hvdWxkUmVzZXQgPSAhZWxlbWVudC52aXNpYmxlICYmIGVsZW1lbnQucmV2ZWFsZWQgJiYgZWxlbWVudC5jb25maWcucmVzZXQ7XG5cblx0aWYgKGZvcmNlLnJldmVhbCB8fCBzaG91bGRSZXZlYWwpIHtcblx0XHRyZXR1cm4gdHJpZ2dlclJldmVhbC5jYWxsKHRoaXMsIGVsZW1lbnQsIGRlbGF5ZWQpXG5cdH1cblxuXHRpZiAoZm9yY2UucmVzZXQgfHwgc2hvdWxkUmVzZXQpIHtcblx0XHRyZXR1cm4gdHJpZ2dlclJlc2V0LmNhbGwodGhpcywgZWxlbWVudClcblx0fVxufVxuXG5mdW5jdGlvbiB0cmlnZ2VyUmV2ZWFsKGVsZW1lbnQsIGRlbGF5ZWQpIHtcblx0dmFyIHN0eWxlcyA9IFtcblx0XHRlbGVtZW50LnN0eWxlcy5pbmxpbmUuZ2VuZXJhdGVkLFxuXHRcdGVsZW1lbnQuc3R5bGVzLm9wYWNpdHkuY29tcHV0ZWQsXG5cdFx0ZWxlbWVudC5zdHlsZXMudHJhbnNmb3JtLmdlbmVyYXRlZC5maW5hbFxuXHRdO1xuXHRpZiAoZGVsYXllZCkge1xuXHRcdHN0eWxlcy5wdXNoKGVsZW1lbnQuc3R5bGVzLnRyYW5zaXRpb24uZ2VuZXJhdGVkLmRlbGF5ZWQpO1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlcy5wdXNoKGVsZW1lbnQuc3R5bGVzLnRyYW5zaXRpb24uZ2VuZXJhdGVkLmluc3RhbnQpO1xuXHR9XG5cdGVsZW1lbnQucmV2ZWFsZWQgPSBlbGVtZW50LnNlZW4gPSB0cnVlO1xuXHRlbGVtZW50Lm5vZGUuc2V0QXR0cmlidXRlKCdzdHlsZScsIHN0eWxlcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMgIT09ICcnOyB9KS5qb2luKCcgJykpO1xuXHRyZWdpc3RlckNhbGxiYWNrcy5jYWxsKHRoaXMsIGVsZW1lbnQsIGRlbGF5ZWQpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyUmVzZXQoZWxlbWVudCkge1xuXHR2YXIgc3R5bGVzID0gW1xuXHRcdGVsZW1lbnQuc3R5bGVzLmlubGluZS5nZW5lcmF0ZWQsXG5cdFx0ZWxlbWVudC5zdHlsZXMub3BhY2l0eS5nZW5lcmF0ZWQsXG5cdFx0ZWxlbWVudC5zdHlsZXMudHJhbnNmb3JtLmdlbmVyYXRlZC5pbml0aWFsLFxuXHRcdGVsZW1lbnQuc3R5bGVzLnRyYW5zaXRpb24uZ2VuZXJhdGVkLmluc3RhbnRcblx0XTtcblx0ZWxlbWVudC5yZXZlYWxlZCA9IGZhbHNlO1xuXHRlbGVtZW50Lm5vZGUuc2V0QXR0cmlidXRlKCdzdHlsZScsIHN0eWxlcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMgIT09ICcnOyB9KS5qb2luKCcgJykpO1xuXHRyZWdpc3RlckNhbGxiYWNrcy5jYWxsKHRoaXMsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckNhbGxiYWNrcyhlbGVtZW50LCBpc0RlbGF5ZWQpIHtcblx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0dmFyIGR1cmF0aW9uID0gaXNEZWxheWVkXG5cdFx0PyBlbGVtZW50LmNvbmZpZy5kdXJhdGlvbiArIGVsZW1lbnQuY29uZmlnLmRlbGF5XG5cdFx0OiBlbGVtZW50LmNvbmZpZy5kdXJhdGlvbjtcblxuXHR2YXIgYmVmb3JlQ2FsbGJhY2sgPSBlbGVtZW50LnJldmVhbGVkXG5cdFx0PyBlbGVtZW50LmNvbmZpZy5iZWZvcmVSZXZlYWxcblx0XHQ6IGVsZW1lbnQuY29uZmlnLmJlZm9yZVJlc2V0O1xuXG5cdHZhciBhZnRlckNhbGxiYWNrID0gZWxlbWVudC5yZXZlYWxlZFxuXHRcdD8gZWxlbWVudC5jb25maWcuYWZ0ZXJSZXZlYWxcblx0XHQ6IGVsZW1lbnQuY29uZmlnLmFmdGVyUmVzZXQ7XG5cblx0dmFyIGVsYXBzZWQgPSAwO1xuXHRpZiAoZWxlbWVudC5jYWxsYmFja1RpbWVyKSB7XG5cdFx0ZWxhcHNlZCA9IERhdGUubm93KCkgLSBlbGVtZW50LmNhbGxiYWNrVGltZXIuc3RhcnQ7XG5cdFx0d2luZG93LmNsZWFyVGltZW91dChlbGVtZW50LmNhbGxiYWNrVGltZXIuY2xvY2spO1xuXHR9XG5cblx0YmVmb3JlQ2FsbGJhY2soZWxlbWVudC5ub2RlKTtcblxuXHRlbGVtZW50LmNhbGxiYWNrVGltZXIgPSB7XG5cdFx0c3RhcnQ6IERhdGUubm93KCksXG5cdFx0Y2xvY2s6IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdGFmdGVyQ2FsbGJhY2soZWxlbWVudC5ub2RlKTtcblx0XHRcdGVsZW1lbnQuY2FsbGJhY2tUaW1lciA9IG51bGw7XG5cdFx0XHRpZiAoZWxlbWVudC5yZXZlYWxlZCAmJiAhZWxlbWVudC5jb25maWcucmVzZXQgJiYgZWxlbWVudC5jb25maWcuY2xlYW51cCkge1xuXHRcdFx0XHRjbGVhbi5jYWxsKHRoaXMkMSwgZWxlbWVudC5ub2RlKTtcblx0XHRcdH1cblx0XHR9LCBkdXJhdGlvbiAtIGVsYXBzZWQpXG5cdH07XG59XG5cbnZhciBuZXh0VW5pcXVlSWQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdWlkID0gMDtcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVpZCsrOyB9XG59KSgpO1xuXG5mdW5jdGlvbiBzZXF1ZW5jZShlbGVtZW50LCBwcmlzdGluZSkge1xuXHRpZiAoIHByaXN0aW5lID09PSB2b2lkIDAgKSBwcmlzdGluZSA9IHRoaXMucHJpc3RpbmU7XG5cblx0LyoqXG5cdCAqIFdlIGZpcnN0IGNoZWNrIGlmIHRoZSBlbGVtZW50IHNob3VsZCByZXNldC5cblx0ICovXG5cdGlmICghZWxlbWVudC52aXNpYmxlICYmIGVsZW1lbnQucmV2ZWFsZWQgJiYgZWxlbWVudC5jb25maWcucmVzZXQpIHtcblx0XHRyZXR1cm4gYW5pbWF0ZS5jYWxsKHRoaXMsIGVsZW1lbnQsIHsgcmVzZXQ6IHRydWUgfSlcblx0fVxuXG5cdHZhciBzZXEgPSB0aGlzLnN0b3JlLnNlcXVlbmNlc1tlbGVtZW50LnNlcXVlbmNlLmlkXTtcblx0dmFyIGkgPSBlbGVtZW50LnNlcXVlbmNlLmluZGV4O1xuXG5cdGlmIChzZXEpIHtcblx0XHR2YXIgdmlzaWJsZSA9IG5ldyBTZXF1ZW5jZU1vZGVsKHNlcSwgJ3Zpc2libGUnLCB0aGlzLnN0b3JlKTtcblx0XHR2YXIgcmV2ZWFsZWQgPSBuZXcgU2VxdWVuY2VNb2RlbChzZXEsICdyZXZlYWxlZCcsIHRoaXMuc3RvcmUpO1xuXG5cdFx0c2VxLm1vZGVscyA9IHsgdmlzaWJsZTogdmlzaWJsZSwgcmV2ZWFsZWQ6IHJldmVhbGVkIH07XG5cblx0XHQvKipcblx0XHQgKiBJZiB0aGUgc2VxdWVuY2UgaGFzIG5vIHJldmVhbGVkIG1lbWJlcnMsXG5cdFx0ICogdGhlbiB3ZSByZXZlYWwgdGhlIGZpcnN0IHZpc2libGUgZWxlbWVudFxuXHRcdCAqIHdpdGhpbiB0aGF0IHNlcXVlbmNlLlxuXHRcdCAqXG5cdFx0ICogVGhlIHNlcXVlbmNlIHRoZW4gY3VlcyBhIHJlY3Vyc2l2ZSBjYWxsXG5cdFx0ICogaW4gYm90aCBkaXJlY3Rpb25zLlxuXHRcdCAqL1xuXHRcdGlmICghcmV2ZWFsZWQuYm9keS5sZW5ndGgpIHtcblx0XHRcdHZhciBuZXh0SWQgPSBzZXEubWVtYmVyc1t2aXNpYmxlLmJvZHlbMF1dO1xuXHRcdFx0dmFyIG5leHRFbGVtZW50ID0gdGhpcy5zdG9yZS5lbGVtZW50c1tuZXh0SWRdO1xuXG5cdFx0XHRpZiAobmV4dEVsZW1lbnQpIHtcblx0XHRcdFx0Y3VlLmNhbGwodGhpcywgc2VxLCB2aXNpYmxlLmJvZHlbMF0sIC0xLCBwcmlzdGluZSk7XG5cdFx0XHRcdGN1ZS5jYWxsKHRoaXMsIHNlcSwgdmlzaWJsZS5ib2R5WzBdLCArMSwgcHJpc3RpbmUpO1xuXHRcdFx0XHRyZXR1cm4gYW5pbWF0ZS5jYWxsKHRoaXMsIG5leHRFbGVtZW50LCB7IHJldmVhbDogdHJ1ZSwgcHJpc3RpbmU6IHByaXN0aW5lIH0pXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogSWYgb3VyIGVsZW1lbnQgaXNu4oCZdCByZXNldHRpbmcsIHdlIGNoZWNrIHRoZVxuXHRcdCAqIGVsZW1lbnQgc2VxdWVuY2UgaW5kZXggYWdhaW5zdCB0aGUgaGVhZCwgYW5kXG5cdFx0ICogdGhlbiB0aGUgZm9vdCBvZiB0aGUgc2VxdWVuY2UuXG5cdFx0ICovXG5cdFx0aWYgKFxuXHRcdFx0IXNlcS5ibG9ja2VkLmhlYWQgJiZcblx0XHRcdGkgPT09IFtdLmNvbmNhdCggcmV2ZWFsZWQuaGVhZCApLnBvcCgpICYmXG5cdFx0XHRpID49IFtdLmNvbmNhdCggdmlzaWJsZS5ib2R5ICkuc2hpZnQoKVxuXHRcdCkge1xuXHRcdFx0Y3VlLmNhbGwodGhpcywgc2VxLCBpLCAtMSwgcHJpc3RpbmUpO1xuXHRcdFx0cmV0dXJuIGFuaW1hdGUuY2FsbCh0aGlzLCBlbGVtZW50LCB7IHJldmVhbDogdHJ1ZSwgcHJpc3RpbmU6IHByaXN0aW5lIH0pXG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0IXNlcS5ibG9ja2VkLmZvb3QgJiZcblx0XHRcdGkgPT09IFtdLmNvbmNhdCggcmV2ZWFsZWQuZm9vdCApLnNoaWZ0KCkgJiZcblx0XHRcdGkgPD0gW10uY29uY2F0KCB2aXNpYmxlLmJvZHkgKS5wb3AoKVxuXHRcdCkge1xuXHRcdFx0Y3VlLmNhbGwodGhpcywgc2VxLCBpLCArMSwgcHJpc3RpbmUpO1xuXHRcdFx0cmV0dXJuIGFuaW1hdGUuY2FsbCh0aGlzLCBlbGVtZW50LCB7IHJldmVhbDogdHJ1ZSwgcHJpc3RpbmU6IHByaXN0aW5lIH0pXG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIFNlcXVlbmNlKGludGVydmFsKSB7XG5cdHZhciBpID0gTWF0aC5hYnMoaW50ZXJ2YWwpO1xuXHRpZiAoIWlzTmFOKGkpKSB7XG5cdFx0dGhpcy5pZCA9IG5leHRVbmlxdWVJZCgpO1xuXHRcdHRoaXMuaW50ZXJ2YWwgPSBNYXRoLm1heChpLCAxNik7XG5cdFx0dGhpcy5tZW1iZXJzID0gW107XG5cdFx0dGhpcy5tb2RlbHMgPSB7fTtcblx0XHR0aGlzLmJsb2NrZWQgPSB7XG5cdFx0XHRoZWFkOiBmYWxzZSxcblx0XHRcdGZvb3Q6IGZhbHNlXG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzZXF1ZW5jZSBpbnRlcnZhbC4nKVxuXHR9XG59XG5cbmZ1bmN0aW9uIFNlcXVlbmNlTW9kZWwoc2VxLCBwcm9wLCBzdG9yZSkge1xuXHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHR0aGlzLmhlYWQgPSBbXTtcblx0dGhpcy5ib2R5ID0gW107XG5cdHRoaXMuZm9vdCA9IFtdO1xuXG5cdGVhY2goc2VxLm1lbWJlcnMsIGZ1bmN0aW9uIChpZCwgaW5kZXgpIHtcblx0XHR2YXIgZWxlbWVudCA9IHN0b3JlLmVsZW1lbnRzW2lkXTtcblx0XHRpZiAoZWxlbWVudCAmJiBlbGVtZW50W3Byb3BdKSB7XG5cdFx0XHR0aGlzJDEuYm9keS5wdXNoKGluZGV4KTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmICh0aGlzLmJvZHkubGVuZ3RoKSB7XG5cdFx0ZWFjaChzZXEubWVtYmVycywgZnVuY3Rpb24gKGlkLCBpbmRleCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBzdG9yZS5lbGVtZW50c1tpZF07XG5cdFx0XHRpZiAoZWxlbWVudCAmJiAhZWxlbWVudFtwcm9wXSkge1xuXHRcdFx0XHRpZiAoaW5kZXggPCB0aGlzJDEuYm9keVswXSkge1xuXHRcdFx0XHRcdHRoaXMkMS5oZWFkLnB1c2goaW5kZXgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMkMS5mb290LnB1c2goaW5kZXgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3VlKHNlcSwgaSwgZGlyZWN0aW9uLCBwcmlzdGluZSkge1xuXHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHR2YXIgYmxvY2tlZCA9IFsnaGVhZCcsIG51bGwsICdmb290J11bMSArIGRpcmVjdGlvbl07XG5cdHZhciBuZXh0SWQgPSBzZXEubWVtYmVyc1tpICsgZGlyZWN0aW9uXTtcblx0dmFyIG5leHRFbGVtZW50ID0gdGhpcy5zdG9yZS5lbGVtZW50c1tuZXh0SWRdO1xuXG5cdHNlcS5ibG9ja2VkW2Jsb2NrZWRdID0gdHJ1ZTtcblxuXHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRzZXEuYmxvY2tlZFtibG9ja2VkXSA9IGZhbHNlO1xuXHRcdGlmIChuZXh0RWxlbWVudCkge1xuXHRcdFx0c2VxdWVuY2UuY2FsbCh0aGlzJDEsIG5leHRFbGVtZW50LCBwcmlzdGluZSk7XG5cdFx0fVxuXHR9LCBzZXEuaW50ZXJ2YWwpO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplKCkge1xuXHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHRyaW5zZS5jYWxsKHRoaXMpO1xuXG5cdGVhY2godGhpcy5zdG9yZS5lbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHR2YXIgc3R5bGVzID0gW2VsZW1lbnQuc3R5bGVzLmlubGluZS5nZW5lcmF0ZWRdO1xuXG5cdFx0aWYgKGVsZW1lbnQudmlzaWJsZSkge1xuXHRcdFx0c3R5bGVzLnB1c2goZWxlbWVudC5zdHlsZXMub3BhY2l0eS5jb21wdXRlZCk7XG5cdFx0XHRzdHlsZXMucHVzaChlbGVtZW50LnN0eWxlcy50cmFuc2Zvcm0uZ2VuZXJhdGVkLmZpbmFsKTtcblx0XHRcdGVsZW1lbnQucmV2ZWFsZWQgPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZXMucHVzaChlbGVtZW50LnN0eWxlcy5vcGFjaXR5LmdlbmVyYXRlZCk7XG5cdFx0XHRzdHlsZXMucHVzaChlbGVtZW50LnN0eWxlcy50cmFuc2Zvcm0uZ2VuZXJhdGVkLmluaXRpYWwpO1xuXHRcdFx0ZWxlbWVudC5yZXZlYWxlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGVsZW1lbnQubm9kZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgc3R5bGVzLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gcyAhPT0gJyc7IH0pLmpvaW4oJyAnKSk7XG5cdH0pO1xuXG5cdGVhY2godGhpcy5zdG9yZS5jb250YWluZXJzLCBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG5cdFx0dmFyIHRhcmdldCA9XG5cdFx0XHRjb250YWluZXIubm9kZSA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gd2luZG93IDogY29udGFpbmVyLm5vZGU7XG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMkMS5kZWxlZ2F0ZSk7XG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMkMS5kZWxlZ2F0ZSk7XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBNYW51YWxseSBpbnZva2UgZGVsZWdhdGUgb25jZSB0byBjYXB0dXJlXG5cdCAqIGVsZW1lbnQgYW5kIGNvbnRhaW5lciBkaW1lbnNpb25zLCBjb250YWluZXJcblx0ICogc2Nyb2xsIHBvc2l0aW9uLCBhbmQgdHJpZ2dlciBhbnkgdmFsaWQgcmV2ZWFsc1xuXHQgKi9cblx0dGhpcy5kZWxlZ2F0ZSgpO1xuXG5cdC8qKlxuXHQgKiBXaXBlIGFueSBleGlzdGluZyBgc2V0VGltZW91dGAgbm93XG5cdCAqIHRoYXQgaW5pdGlhbGl6YXRpb24gaGFzIGNvbXBsZXRlZC5cblx0ICovXG5cdHRoaXMuaW5pdFRpbWVvdXQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc01vYmlsZShhZ2VudCkge1xuXHRpZiAoIGFnZW50ID09PSB2b2lkIDAgKSBhZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG5cblx0cmV0dXJuIC9BbmRyb2lkfGlQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KGFnZW50KVxufVxuXG5mdW5jdGlvbiBkZWVwQXNzaWduKHRhcmdldCkge1xuXHR2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblx0d2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG5cdGlmIChpc09iamVjdCh0YXJnZXQpKSB7XG5cdFx0ZWFjaChzb3VyY2VzLCBmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRlYWNoKHNvdXJjZSwgZnVuY3Rpb24gKGRhdGEsIGtleSkge1xuXHRcdFx0XHRpZiAoaXNPYmplY3QoZGF0YSkpIHtcblx0XHRcdFx0XHRpZiAoIXRhcmdldFtrZXldIHx8ICFpc09iamVjdCh0YXJnZXRba2V5XSkpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtrZXldID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRlZXBBc3NpZ24odGFyZ2V0W2tleV0sIGRhdGEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gZGF0YTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRhcmdldFxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCBsaXRlcmFsLicpXG5cdH1cbn1cblxuZnVuY3Rpb24gcmV2ZWFsKHRhcmdldCwgb3B0aW9ucywgc3luY2luZykge1xuXHR2YXIgdGhpcyQxID0gdGhpcztcblx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cdGlmICggc3luY2luZyA9PT0gdm9pZCAwICkgc3luY2luZyA9IGZhbHNlO1xuXG5cdHZhciBjb250YWluZXJCdWZmZXIgPSBbXTtcblx0dmFyIHNlcXVlbmNlJCQxO1xuXHR2YXIgaW50ZXJ2YWwgPSBvcHRpb25zLmludGVydmFsIHx8IGRlZmF1bHRzLmludGVydmFsO1xuXG5cdHRyeSB7XG5cdFx0aWYgKGludGVydmFsKSB7XG5cdFx0XHRzZXF1ZW5jZSQkMSA9IG5ldyBTZXF1ZW5jZShpbnRlcnZhbCk7XG5cdFx0fVxuXG5cdFx0dmFyIG5vZGVzID0gJCh0YXJnZXQpO1xuXHRcdGlmICghbm9kZXMubGVuZ3RoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmV2ZWFsIHRhcmdldC4nKVxuXHRcdH1cblxuXHRcdHZhciBlbGVtZW50cyA9IG5vZGVzLnJlZHVjZShmdW5jdGlvbiAoZWxlbWVudEJ1ZmZlciwgZWxlbWVudE5vZGUpIHtcblx0XHRcdHZhciBlbGVtZW50ID0ge307XG5cdFx0XHR2YXIgZXhpc3RpbmdJZCA9IGVsZW1lbnROb2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1zci1pZCcpO1xuXG5cdFx0XHRpZiAoZXhpc3RpbmdJZCkge1xuXHRcdFx0XHRkZWVwQXNzaWduKGVsZW1lbnQsIHRoaXMkMS5zdG9yZS5lbGVtZW50c1tleGlzdGluZ0lkXSk7XG5cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEluIG9yZGVyIHRvIHByZXZlbnQgcHJldmlvdXNseSBnZW5lcmF0ZWQgc3R5bGVzXG5cdFx0XHRcdCAqIGZyb20gdGhyb3dpbmcgb2ZmIHRoZSBuZXcgc3R5bGVzLCB0aGUgc3R5bGUgdGFnXG5cdFx0XHRcdCAqIGhhcyB0byBiZSByZXZlcnRlZCB0byBpdHMgcHJlLXJldmVhbCBzdGF0ZS5cblx0XHRcdFx0ICovXG5cdFx0XHRcdGVsZW1lbnQubm9kZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgZWxlbWVudC5zdHlsZXMuaW5saW5lLmNvbXB1dGVkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnQuaWQgPSBuZXh0VW5pcXVlSWQoKTtcblx0XHRcdFx0ZWxlbWVudC5ub2RlID0gZWxlbWVudE5vZGU7XG5cdFx0XHRcdGVsZW1lbnQuc2VlbiA9IGZhbHNlO1xuXHRcdFx0XHRlbGVtZW50LnJldmVhbGVkID0gZmFsc2U7XG5cdFx0XHRcdGVsZW1lbnQudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY29uZmlnID0gZGVlcEFzc2lnbih7fSwgZWxlbWVudC5jb25maWcgfHwgdGhpcyQxLmRlZmF1bHRzLCBvcHRpb25zKTtcblxuXHRcdFx0aWYgKCghY29uZmlnLm1vYmlsZSAmJiBpc01vYmlsZSgpKSB8fCAoIWNvbmZpZy5kZXNrdG9wICYmICFpc01vYmlsZSgpKSkge1xuXHRcdFx0XHRpZiAoZXhpc3RpbmdJZCkge1xuXHRcdFx0XHRcdGNsZWFuLmNhbGwodGhpcyQxLCBlbGVtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZWxlbWVudEJ1ZmZlciAvLyBza2lwIGVsZW1lbnRzIHRoYXQgYXJlIGRpc2FibGVkXG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb250YWluZXJOb2RlID0gJChjb25maWcuY29udGFpbmVyKVswXTtcblx0XHRcdGlmICghY29udGFpbmVyTm9kZSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29udGFpbmVyLicpXG5cdFx0XHR9XG5cdFx0XHRpZiAoIWNvbnRhaW5lck5vZGUuY29udGFpbnMoZWxlbWVudE5vZGUpKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtZW50QnVmZmVyIC8vIHNraXAgZWxlbWVudHMgZm91bmQgb3V0c2lkZSB0aGUgY29udGFpbmVyXG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb250YWluZXJJZDtcblx0XHRcdHtcblx0XHRcdFx0Y29udGFpbmVySWQgPSBnZXRDb250YWluZXJJZChcblx0XHRcdFx0XHRjb250YWluZXJOb2RlLFxuXHRcdFx0XHRcdGNvbnRhaW5lckJ1ZmZlcixcblx0XHRcdFx0XHR0aGlzJDEuc3RvcmUuY29udGFpbmVyc1xuXHRcdFx0XHQpO1xuXHRcdFx0XHRpZiAoY29udGFpbmVySWQgPT09IG51bGwpIHtcblx0XHRcdFx0XHRjb250YWluZXJJZCA9IG5leHRVbmlxdWVJZCgpO1xuXHRcdFx0XHRcdGNvbnRhaW5lckJ1ZmZlci5wdXNoKHsgaWQ6IGNvbnRhaW5lcklkLCBub2RlOiBjb250YWluZXJOb2RlIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGVsZW1lbnQuY29uZmlnID0gY29uZmlnO1xuXHRcdFx0ZWxlbWVudC5jb250YWluZXJJZCA9IGNvbnRhaW5lcklkO1xuXHRcdFx0ZWxlbWVudC5zdHlsZXMgPSBzdHlsZShlbGVtZW50KTtcblxuXHRcdFx0aWYgKHNlcXVlbmNlJCQxKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2VxdWVuY2UgPSB7XG5cdFx0XHRcdFx0aWQ6IHNlcXVlbmNlJCQxLmlkLFxuXHRcdFx0XHRcdGluZGV4OiBzZXF1ZW5jZSQkMS5tZW1iZXJzLmxlbmd0aFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRzZXF1ZW5jZSQkMS5tZW1iZXJzLnB1c2goZWxlbWVudC5pZCk7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW1lbnRCdWZmZXIucHVzaChlbGVtZW50KTtcblx0XHRcdHJldHVybiBlbGVtZW50QnVmZmVyXG5cdFx0fSwgW10pO1xuXG5cdFx0LyoqXG5cdFx0ICogTW9kaWZ5aW5nIHRoZSBET00gdmlhIHNldEF0dHJpYnV0ZSBuZWVkcyB0byBiZSBoYW5kbGVkXG5cdFx0ICogc2VwYXJhdGVseSBmcm9tIHJlYWRpbmcgY29tcHV0ZWQgc3R5bGVzIGluIHRoZSBtYXAgYWJvdmVcblx0XHQgKiBmb3IgdGhlIGJyb3dzZXIgdG8gYmF0Y2ggRE9NIGNoYW5nZXMgKGxpbWl0aW5nIHJlZmxvd3MpXG5cdFx0ICovXG5cdFx0ZWFjaChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdHRoaXMkMS5zdG9yZS5lbGVtZW50c1tlbGVtZW50LmlkXSA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50Lm5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXNyLWlkJywgZWxlbWVudC5pZCk7XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gbG9nZ2VyLmNhbGwodGhpcywgJ1JldmVhbCBmYWlsZWQuJywgZS5tZXNzYWdlKVxuXHR9XG5cblx0LyoqXG5cdCAqIE5vdyB0aGF0IGVsZW1lbnQgc2V0LXVwIGlzIGNvbXBsZXRlLi4uXG5cdCAqIExldOKAmXMgY29tbWl0IGFueSBjb250YWluZXIgYW5kIHNlcXVlbmNlIGRhdGEgd2UgaGF2ZSB0byB0aGUgc3RvcmUuXG5cdCAqL1xuXHRlYWNoKGNvbnRhaW5lckJ1ZmZlciwgZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdHRoaXMkMS5zdG9yZS5jb250YWluZXJzW2NvbnRhaW5lci5pZF0gPSB7XG5cdFx0XHRpZDogY29udGFpbmVyLmlkLFxuXHRcdFx0bm9kZTogY29udGFpbmVyLm5vZGVcblx0XHR9O1xuXHR9KTtcblx0aWYgKHNlcXVlbmNlJCQxKSB7XG5cdFx0dGhpcy5zdG9yZS5zZXF1ZW5jZXNbc2VxdWVuY2UkJDEuaWRdID0gc2VxdWVuY2UkJDE7XG5cdH1cblxuXHQvKipcblx0ICogSWYgcmV2ZWFsIHdhc24ndCBpbnZva2VkIGJ5IHN5bmMsIHdlIHdhbnQgdG9cblx0ICogbWFrZSBzdXJlIHRvIGFkZCB0aGlzIGNhbGwgdG8gdGhlIGhpc3RvcnkuXG5cdCAqL1xuXHRpZiAoc3luY2luZyAhPT0gdHJ1ZSkge1xuXHRcdHRoaXMuc3RvcmUuaGlzdG9yeS5wdXNoKHsgdGFyZ2V0OiB0YXJnZXQsIG9wdGlvbnM6IG9wdGlvbnMgfSk7XG5cblx0XHQvKipcblx0XHQgKiBQdXNoIGluaXRpYWxpemF0aW9uIHRvIHRoZSBldmVudCBxdWV1ZSwgZ2l2aW5nXG5cdFx0ICogbXVsdGlwbGUgcmV2ZWFsIGNhbGxzIHRpbWUgdG8gYmUgaW50ZXJwcmV0ZWQuXG5cdFx0ICovXG5cdFx0aWYgKHRoaXMuaW5pdFRpbWVvdXQpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5pbml0VGltZW91dCk7XG5cdFx0fVxuXHRcdHRoaXMuaW5pdFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChpbml0aWFsaXplLmJpbmQodGhpcyksIDApO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldENvbnRhaW5lcklkKG5vZGUpIHtcblx0dmFyIGNvbGxlY3Rpb25zID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuXHR3aGlsZSAoIGxlbi0tID4gMCApIGNvbGxlY3Rpb25zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG5cdHZhciBpZCA9IG51bGw7XG5cdGVhY2goY29sbGVjdGlvbnMsIGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG5cdFx0ZWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG5cdFx0XHRpZiAoaWQgPT09IG51bGwgJiYgY29udGFpbmVyLm5vZGUgPT09IG5vZGUpIHtcblx0XHRcdFx0aWQgPSBjb250YWluZXIuaWQ7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRyZXR1cm4gaWRcbn1cblxuLyoqXG4gKiBSZS1ydW5zIHRoZSByZXZlYWwgbWV0aG9kIGZvciBlYWNoIHJlY29yZCBzdG9yZWQgaW4gaGlzdG9yeSxcbiAqIGZvciBjYXB0dXJpbmcgbmV3IGNvbnRlbnQgYXN5bmNocm9ub3VzbHkgbG9hZGVkIGludG8gdGhlIERPTS5cbiAqL1xuZnVuY3Rpb24gc3luYygpIHtcblx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ZWFjaCh0aGlzLnN0b3JlLmhpc3RvcnksIGZ1bmN0aW9uIChyZWNvcmQpIHtcblx0XHRyZXZlYWwuY2FsbCh0aGlzJDEsIHJlY29yZC50YXJnZXQsIHJlY29yZC5vcHRpb25zLCB0cnVlKTtcblx0fSk7XG5cblx0aW5pdGlhbGl6ZS5jYWxsKHRoaXMpO1xufVxuXG52YXIgcG9seWZpbGwgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gKHggPiAwKSAtICh4IDwgMCkgfHwgK3g7IH07XG52YXIgbWF0aFNpZ24gPSBNYXRoLnNpZ24gfHwgcG9seWZpbGxcblxuZnVuY3Rpb24gZ2V0R2VvbWV0cnkodGFyZ2V0LCBpc0NvbnRhaW5lcikge1xuXHQvKipcblx0ICogV2Ugd2FudCB0byBpZ25vcmUgcGFkZGluZyBhbmQgc2Nyb2xsYmFycyBmb3IgY29udGFpbmVyIGVsZW1lbnRzLlxuXHQgKiBNb3JlIGluZm9ybWF0aW9uIGhlcmU6IGh0dHBzOi8vZ29vLmdsL3ZPWnBielxuXHQgKi9cblx0dmFyIGhlaWdodCA9IGlzQ29udGFpbmVyID8gdGFyZ2V0Lm5vZGUuY2xpZW50SGVpZ2h0IDogdGFyZ2V0Lm5vZGUub2Zmc2V0SGVpZ2h0O1xuXHR2YXIgd2lkdGggPSBpc0NvbnRhaW5lciA/IHRhcmdldC5ub2RlLmNsaWVudFdpZHRoIDogdGFyZ2V0Lm5vZGUub2Zmc2V0V2lkdGg7XG5cblx0dmFyIG9mZnNldFRvcCA9IDA7XG5cdHZhciBvZmZzZXRMZWZ0ID0gMDtcblx0dmFyIG5vZGUgPSB0YXJnZXQubm9kZTtcblxuXHRkbyB7XG5cdFx0aWYgKCFpc05hTihub2RlLm9mZnNldFRvcCkpIHtcblx0XHRcdG9mZnNldFRvcCArPSBub2RlLm9mZnNldFRvcDtcblx0XHR9XG5cdFx0aWYgKCFpc05hTihub2RlLm9mZnNldExlZnQpKSB7XG5cdFx0XHRvZmZzZXRMZWZ0ICs9IG5vZGUub2Zmc2V0TGVmdDtcblx0XHR9XG5cdFx0bm9kZSA9IG5vZGUub2Zmc2V0UGFyZW50O1xuXHR9IHdoaWxlIChub2RlKVxuXG5cdHJldHVybiB7XG5cdFx0Ym91bmRzOiB7XG5cdFx0XHR0b3A6IG9mZnNldFRvcCxcblx0XHRcdHJpZ2h0OiBvZmZzZXRMZWZ0ICsgd2lkdGgsXG5cdFx0XHRib3R0b206IG9mZnNldFRvcCArIGhlaWdodCxcblx0XHRcdGxlZnQ6IG9mZnNldExlZnRcblx0XHR9LFxuXHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdHdpZHRoOiB3aWR0aFxuXHR9XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbGVkKGNvbnRhaW5lcikge1xuXHR2YXIgdG9wLCBsZWZ0O1xuXHRpZiAoY29udGFpbmVyLm5vZGUgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuXHRcdHRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcblx0XHRsZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuXHR9IGVsc2Uge1xuXHRcdHRvcCA9IGNvbnRhaW5lci5ub2RlLnNjcm9sbFRvcDtcblx0XHRsZWZ0ID0gY29udGFpbmVyLm5vZGUuc2Nyb2xsTGVmdDtcblx0fVxuXHRyZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudFZpc2libGUoZWxlbWVudCkge1xuXHRpZiAoIGVsZW1lbnQgPT09IHZvaWQgMCApIGVsZW1lbnQgPSB7fTtcblxuXHR2YXIgY29udGFpbmVyID0gdGhpcy5zdG9yZS5jb250YWluZXJzW2VsZW1lbnQuY29udGFpbmVySWRdO1xuXHRpZiAoIWNvbnRhaW5lcikgeyByZXR1cm4gfVxuXG5cdHZhciB2aWV3RmFjdG9yID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgZWxlbWVudC5jb25maWcudmlld0ZhY3RvcikpO1xuXHR2YXIgdmlld09mZnNldCA9IGVsZW1lbnQuY29uZmlnLnZpZXdPZmZzZXQ7XG5cblx0dmFyIGVsZW1lbnRCb3VuZHMgPSB7XG5cdFx0dG9wOiBlbGVtZW50Lmdlb21ldHJ5LmJvdW5kcy50b3AgKyBlbGVtZW50Lmdlb21ldHJ5LmhlaWdodCAqIHZpZXdGYWN0b3IsXG5cdFx0cmlnaHQ6IGVsZW1lbnQuZ2VvbWV0cnkuYm91bmRzLnJpZ2h0IC0gZWxlbWVudC5nZW9tZXRyeS53aWR0aCAqIHZpZXdGYWN0b3IsXG5cdFx0Ym90dG9tOiBlbGVtZW50Lmdlb21ldHJ5LmJvdW5kcy5ib3R0b20gLSBlbGVtZW50Lmdlb21ldHJ5LmhlaWdodCAqIHZpZXdGYWN0b3IsXG5cdFx0bGVmdDogZWxlbWVudC5nZW9tZXRyeS5ib3VuZHMubGVmdCArIGVsZW1lbnQuZ2VvbWV0cnkud2lkdGggKiB2aWV3RmFjdG9yXG5cdH07XG5cblx0dmFyIGNvbnRhaW5lckJvdW5kcyA9IHtcblx0XHR0b3A6IGNvbnRhaW5lci5nZW9tZXRyeS5ib3VuZHMudG9wICsgY29udGFpbmVyLnNjcm9sbC50b3AgKyB2aWV3T2Zmc2V0LnRvcCxcblx0XHRyaWdodDogY29udGFpbmVyLmdlb21ldHJ5LmJvdW5kcy5yaWdodCArIGNvbnRhaW5lci5zY3JvbGwubGVmdCAtIHZpZXdPZmZzZXQucmlnaHQsXG5cdFx0Ym90dG9tOlxuXHRcdFx0Y29udGFpbmVyLmdlb21ldHJ5LmJvdW5kcy5ib3R0b20gKyBjb250YWluZXIuc2Nyb2xsLnRvcCAtIHZpZXdPZmZzZXQuYm90dG9tLFxuXHRcdGxlZnQ6IGNvbnRhaW5lci5nZW9tZXRyeS5ib3VuZHMubGVmdCArIGNvbnRhaW5lci5zY3JvbGwubGVmdCArIHZpZXdPZmZzZXQubGVmdFxuXHR9O1xuXG5cdHJldHVybiAoXG5cdFx0KGVsZW1lbnRCb3VuZHMudG9wIDwgY29udGFpbmVyQm91bmRzLmJvdHRvbSAmJlxuXHRcdFx0ZWxlbWVudEJvdW5kcy5yaWdodCA+IGNvbnRhaW5lckJvdW5kcy5sZWZ0ICYmXG5cdFx0XHRlbGVtZW50Qm91bmRzLmJvdHRvbSA+IGNvbnRhaW5lckJvdW5kcy50b3AgJiZcblx0XHRcdGVsZW1lbnRCb3VuZHMubGVmdCA8IGNvbnRhaW5lckJvdW5kcy5yaWdodCkgfHxcblx0XHRlbGVtZW50LnN0eWxlcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJ1xuXHQpXG59XG5cbmZ1bmN0aW9uIGRlbGVnYXRlKFxuXHRldmVudCxcblx0ZWxlbWVudHNcbikge1xuXHR2YXIgdGhpcyQxID0gdGhpcztcblx0aWYgKCBldmVudCA9PT0gdm9pZCAwICkgZXZlbnQgPSB7IHR5cGU6ICdpbml0JyB9O1xuXHRpZiAoIGVsZW1lbnRzID09PSB2b2lkIDAgKSBlbGVtZW50cyA9IHRoaXMuc3RvcmUuZWxlbWVudHM7XG5cblx0cmFmKGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc3RhbGUgPSBldmVudC50eXBlID09PSAnaW5pdCcgfHwgZXZlbnQudHlwZSA9PT0gJ3Jlc2l6ZSc7XG5cblx0XHRlYWNoKHRoaXMkMS5zdG9yZS5jb250YWluZXJzLCBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG5cdFx0XHRpZiAoc3RhbGUpIHtcblx0XHRcdFx0Y29udGFpbmVyLmdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkuY2FsbCh0aGlzJDEsIGNvbnRhaW5lciwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc2Nyb2xsID0gZ2V0U2Nyb2xsZWQuY2FsbCh0aGlzJDEsIGNvbnRhaW5lcik7XG5cdFx0XHRpZiAoY29udGFpbmVyLnNjcm9sbCkge1xuXHRcdFx0XHRjb250YWluZXIuZGlyZWN0aW9uID0ge1xuXHRcdFx0XHRcdHg6IG1hdGhTaWduKHNjcm9sbC5sZWZ0IC0gY29udGFpbmVyLnNjcm9sbC5sZWZ0KSxcblx0XHRcdFx0XHR5OiBtYXRoU2lnbihzY3JvbGwudG9wIC0gY29udGFpbmVyLnNjcm9sbC50b3ApXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuc2Nyb2xsID0gc2Nyb2xsO1xuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogRHVlIHRvIGhvdyB0aGUgc2VxdWVuY2VyIGlzIGltcGxlbWVudGVkLCBpdOKAmXNcblx0XHQgKiBpbXBvcnRhbnQgdGhhdCB3ZSB1cGRhdGUgdGhlIHN0YXRlIG9mIGFsbFxuXHRcdCAqIGVsZW1lbnRzLCBiZWZvcmUgYW55IGFuaW1hdGlvbiBsb2dpYyBpc1xuXHRcdCAqIGV2YWx1YXRlZCAoaW4gdGhlIHNlY29uZCBsb29wIGJlbG93KS5cblx0XHQgKi9cblx0XHRlYWNoKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdFx0aWYgKHN0YWxlKSB7XG5cdFx0XHRcdGVsZW1lbnQuZ2VvbWV0cnkgPSBnZXRHZW9tZXRyeS5jYWxsKHRoaXMkMSwgZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0XHRlbGVtZW50LnZpc2libGUgPSBpc0VsZW1lbnRWaXNpYmxlLmNhbGwodGhpcyQxLCBlbGVtZW50KTtcblx0XHR9KTtcblxuXHRcdGVhY2goZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0XHRpZiAoZWxlbWVudC5zZXF1ZW5jZSkge1xuXHRcdFx0XHRzZXF1ZW5jZS5jYWxsKHRoaXMkMSwgZWxlbWVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhbmltYXRlLmNhbGwodGhpcyQxLCBlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMkMS5wcmlzdGluZSA9IGZhbHNlO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3VwcG9ydGVkKCkge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5cdHJldHVybiAndHJhbnNmb3JtJyBpbiBzdHlsZSB8fCAnV2Via2l0VHJhbnNmb3JtJyBpbiBzdHlsZVxufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uU3VwcG9ydGVkKCkge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5cdHJldHVybiAndHJhbnNpdGlvbicgaW4gc3R5bGUgfHwgJ1dlYmtpdFRyYW5zaXRpb24nIGluIHN0eWxlXG59XG5cbnZhciB2ZXJzaW9uID0gXCI0LjAuNVwiO1xuXG52YXIgYm91bmREZWxlZ2F0ZTtcbnZhciBib3VuZERlc3Ryb3k7XG52YXIgYm91bmRSZXZlYWw7XG52YXIgYm91bmRDbGVhbjtcbnZhciBib3VuZFN5bmM7XG52YXIgY29uZmlnO1xudmFyIGRlYnVnO1xudmFyIGluc3RhbmNlO1xuXG5mdW5jdGlvbiBTY3JvbGxSZXZlYWwob3B0aW9ucykge1xuXHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuXHR2YXIgaW52b2tlZFdpdGhvdXROZXcgPVxuXHRcdHR5cGVvZiB0aGlzID09PSAndW5kZWZpbmVkJyB8fFxuXHRcdE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSAhPT0gU2Nyb2xsUmV2ZWFsLnByb3RvdHlwZTtcblxuXHRpZiAoaW52b2tlZFdpdGhvdXROZXcpIHtcblx0XHRyZXR1cm4gbmV3IFNjcm9sbFJldmVhbChvcHRpb25zKVxuXHR9XG5cblx0aWYgKCFTY3JvbGxSZXZlYWwuaXNTdXBwb3J0ZWQoKSkge1xuXHRcdGxvZ2dlci5jYWxsKHRoaXMsICdJbnN0YW50aWF0aW9uIGZhaWxlZC4nLCAnVGhpcyBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG5cdFx0cmV0dXJuIG1vdW50LmZhaWx1cmUoKVxuXHR9XG5cblx0dmFyIGJ1ZmZlcjtcblx0dHJ5IHtcblx0XHRidWZmZXIgPSBjb25maWdcblx0XHRcdD8gZGVlcEFzc2lnbih7fSwgY29uZmlnLCBvcHRpb25zKVxuXHRcdFx0OiBkZWVwQXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRsb2dnZXIuY2FsbCh0aGlzLCAnSW52YWxpZCBjb25maWd1cmF0aW9uLicsIGUubWVzc2FnZSk7XG5cdFx0cmV0dXJuIG1vdW50LmZhaWx1cmUoKVxuXHR9XG5cblx0dHJ5IHtcblx0XHR2YXIgY29udGFpbmVyID0gJChidWZmZXIuY29udGFpbmVyKVswXTtcblx0XHRpZiAoIWNvbnRhaW5lcikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbnRhaW5lci4nKVxuXHRcdH1cblx0fSBjYXRjaCAoZSkge1xuXHRcdGxvZ2dlci5jYWxsKHRoaXMsIGUubWVzc2FnZSk7XG5cdFx0cmV0dXJuIG1vdW50LmZhaWx1cmUoKVxuXHR9XG5cblx0Y29uZmlnID0gYnVmZmVyO1xuXG5cdGlmICgoIWNvbmZpZy5tb2JpbGUgJiYgaXNNb2JpbGUoKSkgfHwgKCFjb25maWcuZGVza3RvcCAmJiAhaXNNb2JpbGUoKSkpIHtcblx0XHRsb2dnZXIuY2FsbChcblx0XHRcdHRoaXMsXG5cdFx0XHQnVGhpcyBkZXZpY2UgaXMgZGlzYWJsZWQuJyxcblx0XHRcdChcImRlc2t0b3A6IFwiICsgKGNvbmZpZy5kZXNrdG9wKSksXG5cdFx0XHQoXCJtb2JpbGU6IFwiICsgKGNvbmZpZy5tb2JpbGUpKVxuXHRcdCk7XG5cdFx0cmV0dXJuIG1vdW50LmZhaWx1cmUoKVxuXHR9XG5cblx0bW91bnQuc3VjY2VzcygpO1xuXG5cdHRoaXMuc3RvcmUgPSB7XG5cdFx0Y29udGFpbmVyczoge30sXG5cdFx0ZWxlbWVudHM6IHt9LFxuXHRcdGhpc3Rvcnk6IFtdLFxuXHRcdHNlcXVlbmNlczoge31cblx0fTtcblxuXHR0aGlzLnByaXN0aW5lID0gdHJ1ZTtcblxuXHRib3VuZERlbGVnYXRlID0gYm91bmREZWxlZ2F0ZSB8fCBkZWxlZ2F0ZS5iaW5kKHRoaXMpO1xuXHRib3VuZERlc3Ryb3kgPSBib3VuZERlc3Ryb3kgfHwgZGVzdHJveS5iaW5kKHRoaXMpO1xuXHRib3VuZFJldmVhbCA9IGJvdW5kUmV2ZWFsIHx8IHJldmVhbC5iaW5kKHRoaXMpO1xuXHRib3VuZENsZWFuID0gYm91bmRDbGVhbiB8fCBjbGVhbi5iaW5kKHRoaXMpO1xuXHRib3VuZFN5bmMgPSBib3VuZFN5bmMgfHwgc3luYy5iaW5kKHRoaXMpO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZGVsZWdhdGUnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYm91bmREZWxlZ2F0ZTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdkZXN0cm95JywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJvdW5kRGVzdHJveTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZXZlYWwnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYm91bmRSZXZlYWw7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY2xlYW4nLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYm91bmRDbGVhbjsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzeW5jJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJvdW5kU3luYzsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2RlZmF1bHRzJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd2ZXJzaW9uJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZlcnNpb247IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbm9vcCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSB9KTtcblxuXHRyZXR1cm4gaW5zdGFuY2UgPyBpbnN0YW5jZSA6IChpbnN0YW5jZSA9IHRoaXMpXG59XG5cblNjcm9sbFJldmVhbC5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zZm9ybVN1cHBvcnRlZCgpICYmIHRyYW5zaXRpb25TdXBwb3J0ZWQoKTsgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjcm9sbFJldmVhbCwgJ2RlYnVnJywge1xuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlYnVnIHx8IGZhbHNlOyB9LFxuXHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gKGRlYnVnID0gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgPyB2YWx1ZSA6IGRlYnVnKTsgfVxufSk7XG5cblNjcm9sbFJldmVhbCgpO1xuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxSZXZlYWw7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi9hamF4XCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnkgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9ICk7XG59O1xuXG5yZXR1cm4galF1ZXJ5Ll9ldmFsVXJsO1xuXG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi9jb3JlXCIsXG5cdFwiLi4vY29yZS90b1R5cGVcIixcblx0XCIuL3Zhci9ydGFnTmFtZVwiLFxuXHRcIi4vdmFyL3JzY3JpcHRUeXBlXCIsXG5cdFwiLi93cmFwTWFwXCIsXG5cdFwiLi9nZXRBbGxcIixcblx0XCIuL3NldEdsb2JhbEV2YWxcIlxuXSwgZnVuY3Rpb24oIGpRdWVyeSwgdG9UeXBlLCBydGFnTmFtZSwgcnNjcmlwdFR5cGUsIHdyYXBNYXAsIGdldEFsbCwgc2V0R2xvYmFsRXZhbCApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cbnJldHVybiBidWlsZEZyYWdtZW50O1xufSApO1xuIiwiZGVmaW5lKCBbIFwiLi9zZWxlY3Rvci1zaXp6bGVcIiBdLCBmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuL2FyclwiXG5dLCBmdW5jdGlvbiggYXJyICkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRyZXR1cm4gYXJyLmluZGV4T2Y7XG59ICk7XG4iLCJkZWZpbmUoIGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBNYXRjaCBhIHN0YW5kYWxvbmUgdGFnXG5cdHJldHVybiAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG59ICk7XG4iLCJkZWZpbmUoIGZ1bmN0aW9uKCkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cbnJldHVybiBhZGRHZXRIb29rSWY7XG5cbn0gKTtcbiIsImRlZmluZSggZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIEFsbCBzdXBwb3J0IHRlc3RzIGFyZSBkZWZpbmVkIGluIHRoZWlyIHJlc3BlY3RpdmUgbW9kdWxlcy5cblx0cmV0dXJuIHt9O1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi9jb3JlXCIsXG5cdFwiLi9jb3JlL3RvVHlwZVwiLFxuXHRcIi4vdmFyL2lzRnVuY3Rpb25cIixcblx0XCIuL3Zhci9ybm90aHRtbHdoaXRlXCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnksIHRvVHlwZSwgaXNGdW5jdGlvbiwgcm5vdGh0bWx3aGl0ZSApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi9jc3NFeHBhbmRcIlxuXSwgZnVuY3Rpb24oIGNzc0V4cGFuZCApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0cmV0dXJuIG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xufSApO1xuIiwiZGVmaW5lKCBmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0cmV0dXJuIHdpbmRvdy5kb2N1bWVudDtcbn0gKTtcbiIsIi8qIVxuICAqIHZ1ZS1yb3V0ZXIgdjMuMC4yXG4gICogKGMpIDIwMTggRXZhbiBZb3VcbiAgKiBAbGljZW5zZSBNSVRcbiAgKi9cbi8qICAqL1xuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuIChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbmRpdGlvbikge1xuICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4oKFwiW3Z1ZS1yb3V0ZXJdIFwiICsgbWVzc2FnZSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IgKGVycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycikuaW5kZXhPZignRXJyb3InKSA+IC0xXG59XG5cbmZ1bmN0aW9uIGV4dGVuZCAoYSwgYikge1xuICBmb3IgKHZhciBrZXkgaW4gYikge1xuICAgIGFba2V5XSA9IGJba2V5XTtcbiAgfVxuICByZXR1cm4gYVxufVxuXG52YXIgVmlldyA9IHtcbiAgbmFtZTogJ1JvdXRlclZpZXcnLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0J1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKF8sIHJlZikge1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcblxuICAgIC8vIHVzZWQgYnkgZGV2dG9vbHMgdG8gZGlzcGxheSBhIHJvdXRlci12aWV3IGJhZGdlXG4gICAgZGF0YS5yb3V0ZXJWaWV3ID0gdHJ1ZTtcblxuICAgIC8vIGRpcmVjdGx5IHVzZSBwYXJlbnQgY29udGV4dCdzIGNyZWF0ZUVsZW1lbnQoKSBmdW5jdGlvblxuICAgIC8vIHNvIHRoYXQgY29tcG9uZW50cyByZW5kZXJlZCBieSByb3V0ZXItdmlldyBjYW4gcmVzb2x2ZSBuYW1lZCBzbG90c1xuICAgIHZhciBoID0gcGFyZW50LiRjcmVhdGVFbGVtZW50O1xuICAgIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgICB2YXIgcm91dGUgPSBwYXJlbnQuJHJvdXRlO1xuICAgIHZhciBjYWNoZSA9IHBhcmVudC5fcm91dGVyVmlld0NhY2hlIHx8IChwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSA9IHt9KTtcblxuICAgIC8vIGRldGVybWluZSBjdXJyZW50IHZpZXcgZGVwdGgsIGFsc28gY2hlY2sgdG8gc2VlIGlmIHRoZSB0cmVlXG4gICAgLy8gaGFzIGJlZW4gdG9nZ2xlZCBpbmFjdGl2ZSBidXQga2VwdC1hbGl2ZS5cbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHZhciBpbmFjdGl2ZSA9IGZhbHNlO1xuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50Ll9yb3V0ZXJSb290ICE9PSBwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuJHZub2RlICYmIHBhcmVudC4kdm5vZGUuZGF0YS5yb3V0ZXJWaWV3KSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Ll9pbmFjdGl2ZSkge1xuICAgICAgICBpbmFjdGl2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgZGF0YS5yb3V0ZXJWaWV3RGVwdGggPSBkZXB0aDtcblxuICAgIC8vIHJlbmRlciBwcmV2aW91cyB2aWV3IGlmIHRoZSB0cmVlIGlzIGluYWN0aXZlIGFuZCBrZXB0LWFsaXZlXG4gICAgaWYgKGluYWN0aXZlKSB7XG4gICAgICByZXR1cm4gaChjYWNoZVtuYW1lXSwgZGF0YSwgY2hpbGRyZW4pXG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZWQgPSByb3V0ZS5tYXRjaGVkW2RlcHRoXTtcbiAgICAvLyByZW5kZXIgZW1wdHkgbm9kZSBpZiBubyBtYXRjaGVkIHJvdXRlXG4gICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICBjYWNoZVtuYW1lXSA9IG51bGw7XG4gICAgICByZXR1cm4gaCgpXG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudCA9IGNhY2hlW25hbWVdID0gbWF0Y2hlZC5jb21wb25lbnRzW25hbWVdO1xuXG4gICAgLy8gYXR0YWNoIGluc3RhbmNlIHJlZ2lzdHJhdGlvbiBob29rXG4gICAgLy8gdGhpcyB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgaW5zdGFuY2UncyBpbmplY3RlZCBsaWZlY3ljbGUgaG9va3NcbiAgICBkYXRhLnJlZ2lzdGVyUm91dGVJbnN0YW5jZSA9IGZ1bmN0aW9uICh2bSwgdmFsKSB7XG4gICAgICAvLyB2YWwgY291bGQgYmUgdW5kZWZpbmVkIGZvciB1bnJlZ2lzdHJhdGlvblxuICAgICAgdmFyIGN1cnJlbnQgPSBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgKHZhbCAmJiBjdXJyZW50ICE9PSB2bSkgfHxcbiAgICAgICAgKCF2YWwgJiYgY3VycmVudCA9PT0gdm0pXG4gICAgICApIHtcbiAgICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWxzbyByZWdpc3RlciBpbnN0YW5jZSBpbiBwcmVwYXRjaCBob29rXG4gICAgLy8gaW4gY2FzZSB0aGUgc2FtZSBjb21wb25lbnQgaW5zdGFuY2UgaXMgcmV1c2VkIGFjcm9zcyBkaWZmZXJlbnQgcm91dGVzXG4gICAgOyhkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KSkucHJlcGF0Y2ggPSBmdW5jdGlvbiAoXywgdm5vZGUpIHtcbiAgICAgIG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgfTtcblxuICAgIC8vIHJlc29sdmUgcHJvcHNcbiAgICB2YXIgcHJvcHNUb1Bhc3MgPSBkYXRhLnByb3BzID0gcmVzb2x2ZVByb3BzKHJvdXRlLCBtYXRjaGVkLnByb3BzICYmIG1hdGNoZWQucHJvcHNbbmFtZV0pO1xuICAgIGlmIChwcm9wc1RvUGFzcykge1xuICAgICAgLy8gY2xvbmUgdG8gcHJldmVudCBtdXRhdGlvblxuICAgICAgcHJvcHNUb1Bhc3MgPSBkYXRhLnByb3BzID0gZXh0ZW5kKHt9LCBwcm9wc1RvUGFzcyk7XG4gICAgICAvLyBwYXNzIG5vbi1kZWNsYXJlZCBwcm9wcyBhcyBhdHRyc1xuICAgICAgdmFyIGF0dHJzID0gZGF0YS5hdHRycyA9IGRhdGEuYXR0cnMgfHwge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHNUb1Bhc3MpIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnQucHJvcHMgfHwgIShrZXkgaW4gY29tcG9uZW50LnByb3BzKSkge1xuICAgICAgICAgIGF0dHJzW2tleV0gPSBwcm9wc1RvUGFzc1trZXldO1xuICAgICAgICAgIGRlbGV0ZSBwcm9wc1RvUGFzc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGgoY29tcG9uZW50LCBkYXRhLCBjaGlsZHJlbilcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUHJvcHMgKHJvdXRlLCBjb25maWcpIHtcbiAgc3dpdGNoICh0eXBlb2YgY29uZmlnKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVyblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gY29uZmlnXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIGNvbmZpZyhyb3V0ZSlcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBjb25maWcgPyByb3V0ZS5wYXJhbXMgOiB1bmRlZmluZWRcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcInByb3BzIGluIFxcXCJcIiArIChyb3V0ZS5wYXRoKSArIFwiXFxcIiBpcyBhIFwiICsgKHR5cGVvZiBjb25maWcpICsgXCIsIFwiICtcbiAgICAgICAgICBcImV4cGVjdGluZyBhbiBvYmplY3QsIGZ1bmN0aW9uIG9yIGJvb2xlYW4uXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGVuY29kZVJlc2VydmVSRSA9IC9bIScoKSpdL2c7XG52YXIgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7IH07XG52YXIgY29tbWFSRSA9IC8lMkMvZztcblxuLy8gZml4ZWQgZW5jb2RlVVJJQ29tcG9uZW50IHdoaWNoIGlzIG1vcmUgY29uZm9ybWFudCB0byBSRkMzOTg2OlxuLy8gLSBlc2NhcGVzIFshJygpKl1cbi8vIC0gcHJlc2VydmUgY29tbWFzXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgLnJlcGxhY2UoZW5jb2RlUmVzZXJ2ZVJFLCBlbmNvZGVSZXNlcnZlUmVwbGFjZXIpXG4gIC5yZXBsYWNlKGNvbW1hUkUsICcsJyk7IH07XG5cbnZhciBkZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWVyeSAoXG4gIHF1ZXJ5LFxuICBleHRyYVF1ZXJ5LFxuICBfcGFyc2VRdWVyeVxuKSB7XG4gIGlmICggZXh0cmFRdWVyeSA9PT0gdm9pZCAwICkgZXh0cmFRdWVyeSA9IHt9O1xuXG4gIHZhciBwYXJzZSA9IF9wYXJzZVF1ZXJ5IHx8IHBhcnNlUXVlcnk7XG4gIHZhciBwYXJzZWRRdWVyeTtcbiAgdHJ5IHtcbiAgICBwYXJzZWRRdWVyeSA9IHBhcnNlKHF1ZXJ5IHx8ICcnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihmYWxzZSwgZS5tZXNzYWdlKTtcbiAgICBwYXJzZWRRdWVyeSA9IHt9O1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBleHRyYVF1ZXJ5KSB7XG4gICAgcGFyc2VkUXVlcnlba2V5XSA9IGV4dHJhUXVlcnlba2V5XTtcbiAgfVxuICByZXR1cm4gcGFyc2VkUXVlcnlcbn1cblxuZnVuY3Rpb24gcGFyc2VRdWVyeSAocXVlcnkpIHtcbiAgdmFyIHJlcyA9IHt9O1xuXG4gIHF1ZXJ5ID0gcXVlcnkudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG5cbiAgaWYgKCFxdWVyeSkge1xuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIHF1ZXJ5LnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydHMuc2hpZnQoKSk7XG4gICAgdmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDBcbiAgICAgID8gZGVjb2RlKHBhcnRzLmpvaW4oJz0nKSlcbiAgICAgIDogbnVsbDtcblxuICAgIGlmIChyZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXNba2V5XSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzW2tleV0pKSB7XG4gICAgICByZXNba2V5XS5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1trZXldID0gW3Jlc1trZXldLCB2YWxdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlRdWVyeSAob2JqKSB7XG4gIHZhciByZXMgPSBvYmogPyBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbCA9IG9ialtrZXldO1xuXG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZW5jb2RlKGtleSlcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbiAodmFsMikge1xuICAgICAgICBpZiAodmFsMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbDIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsMikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQuam9pbignJicpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHZhbClcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lmxlbmd0aCA+IDA7IH0pLmpvaW4oJyYnKSA6IG51bGw7XG4gIHJldHVybiByZXMgPyAoXCI/XCIgKyByZXMpIDogJydcbn1cblxuLyogICovXG5cbnZhciB0cmFpbGluZ1NsYXNoUkUgPSAvXFwvPyQvO1xuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZSAoXG4gIHJlY29yZCxcbiAgbG9jYXRpb24sXG4gIHJlZGlyZWN0ZWRGcm9tLFxuICByb3V0ZXJcbikge1xuICB2YXIgc3RyaW5naWZ5UXVlcnkkJDEgPSByb3V0ZXIgJiYgcm91dGVyLm9wdGlvbnMuc3RyaW5naWZ5UXVlcnk7XG5cbiAgdmFyIHF1ZXJ5ID0gbG9jYXRpb24ucXVlcnkgfHwge307XG4gIHRyeSB7XG4gICAgcXVlcnkgPSBjbG9uZShxdWVyeSk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJvdXRlID0ge1xuICAgIG5hbWU6IGxvY2F0aW9uLm5hbWUgfHwgKHJlY29yZCAmJiByZWNvcmQubmFtZSksXG4gICAgbWV0YTogKHJlY29yZCAmJiByZWNvcmQubWV0YSkgfHwge30sXG4gICAgcGF0aDogbG9jYXRpb24ucGF0aCB8fCAnLycsXG4gICAgaGFzaDogbG9jYXRpb24uaGFzaCB8fCAnJyxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgcGFyYW1zOiBsb2NhdGlvbi5wYXJhbXMgfHwge30sXG4gICAgZnVsbFBhdGg6IGdldEZ1bGxQYXRoKGxvY2F0aW9uLCBzdHJpbmdpZnlRdWVyeSQkMSksXG4gICAgbWF0Y2hlZDogcmVjb3JkID8gZm9ybWF0TWF0Y2gocmVjb3JkKSA6IFtdXG4gIH07XG4gIGlmIChyZWRpcmVjdGVkRnJvbSkge1xuICAgIHJvdXRlLnJlZGlyZWN0ZWRGcm9tID0gZ2V0RnVsbFBhdGgocmVkaXJlY3RlZEZyb20sIHN0cmluZ2lmeVF1ZXJ5JCQxKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyb3V0ZSlcbn1cblxuZnVuY3Rpb24gY2xvbmUgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5tYXAoY2xvbmUpXG4gIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIHJlc1trZXldID0gY2xvbmUodmFsdWVba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuXG4vLyB0aGUgc3RhcnRpbmcgcm91dGUgdGhhdCByZXByZXNlbnRzIHRoZSBpbml0aWFsIHN0YXRlXG52YXIgU1RBUlQgPSBjcmVhdGVSb3V0ZShudWxsLCB7XG4gIHBhdGg6ICcvJ1xufSk7XG5cbmZ1bmN0aW9uIGZvcm1hdE1hdGNoIChyZWNvcmQpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB3aGlsZSAocmVjb3JkKSB7XG4gICAgcmVzLnVuc2hpZnQocmVjb3JkKTtcbiAgICByZWNvcmQgPSByZWNvcmQucGFyZW50O1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0RnVsbFBhdGggKFxuICByZWYsXG4gIF9zdHJpbmdpZnlRdWVyeVxuKSB7XG4gIHZhciBwYXRoID0gcmVmLnBhdGg7XG4gIHZhciBxdWVyeSA9IHJlZi5xdWVyeTsgaWYgKCBxdWVyeSA9PT0gdm9pZCAwICkgcXVlcnkgPSB7fTtcbiAgdmFyIGhhc2ggPSByZWYuaGFzaDsgaWYgKCBoYXNoID09PSB2b2lkIDAgKSBoYXNoID0gJyc7XG5cbiAgdmFyIHN0cmluZ2lmeSA9IF9zdHJpbmdpZnlRdWVyeSB8fCBzdHJpbmdpZnlRdWVyeTtcbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyBzdHJpbmdpZnkocXVlcnkpICsgaGFzaFxufVxuXG5mdW5jdGlvbiBpc1NhbWVSb3V0ZSAoYSwgYikge1xuICBpZiAoYiA9PT0gU1RBUlQpIHtcbiAgICByZXR1cm4gYSA9PT0gYlxuICB9IGVsc2UgaWYgKCFiKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoYS5wYXRoICYmIGIucGF0aCkge1xuICAgIHJldHVybiAoXG4gICAgICBhLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSA9PT0gYi5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnJykgJiZcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpXG4gICAgKVxuICB9IGVsc2UgaWYgKGEubmFtZSAmJiBiLm5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYS5uYW1lID09PSBiLm5hbWUgJiZcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucGFyYW1zLCBiLnBhcmFtcylcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNPYmplY3RFcXVhbCAoYSwgYikge1xuICBpZiAoIGEgPT09IHZvaWQgMCApIGEgPSB7fTtcbiAgaWYgKCBiID09PSB2b2lkIDAgKSBiID0ge307XG5cbiAgLy8gaGFuZGxlIG51bGwgdmFsdWUgIzE1NjZcbiAgaWYgKCFhIHx8ICFiKSB7IHJldHVybiBhID09PSBiIH1cbiAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBhVmFsID0gYVtrZXldO1xuICAgIHZhciBiVmFsID0gYltrZXldO1xuICAgIC8vIGNoZWNrIG5lc3RlZCBlcXVhbGl0eVxuICAgIGlmICh0eXBlb2YgYVZhbCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGJWYWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RFcXVhbChhVmFsLCBiVmFsKVxuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGFWYWwpID09PSBTdHJpbmcoYlZhbClcbiAgfSlcbn1cblxuZnVuY3Rpb24gaXNJbmNsdWRlZFJvdXRlIChjdXJyZW50LCB0YXJnZXQpIHtcbiAgcmV0dXJuIChcbiAgICBjdXJyZW50LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJykuaW5kZXhPZihcbiAgICAgIHRhcmdldC5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnLycpXG4gICAgKSA9PT0gMCAmJlxuICAgICghdGFyZ2V0Lmhhc2ggfHwgY3VycmVudC5oYXNoID09PSB0YXJnZXQuaGFzaCkgJiZcbiAgICBxdWVyeUluY2x1ZGVzKGN1cnJlbnQucXVlcnksIHRhcmdldC5xdWVyeSlcbiAgKVxufVxuXG5mdW5jdGlvbiBxdWVyeUluY2x1ZGVzIChjdXJyZW50LCB0YXJnZXQpIHtcbiAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuICAgIGlmICghKGtleSBpbiBjdXJyZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qICAqL1xuXG4vLyB3b3JrIGFyb3VuZCB3ZWlyZCBmbG93IGJ1Z1xudmFyIHRvVHlwZXMgPSBbU3RyaW5nLCBPYmplY3RdO1xudmFyIGV2ZW50VHlwZXMgPSBbU3RyaW5nLCBBcnJheV07XG5cbnZhciBMaW5rID0ge1xuICBuYW1lOiAnUm91dGVyTGluaycsXG4gIHByb3BzOiB7XG4gICAgdG86IHtcbiAgICAgIHR5cGU6IHRvVHlwZXMsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnYSdcbiAgICB9LFxuICAgIGV4YWN0OiBCb29sZWFuLFxuICAgIGFwcGVuZDogQm9vbGVhbixcbiAgICByZXBsYWNlOiBCb29sZWFuLFxuICAgIGFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXhhY3RBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGV2ZW50OiB7XG4gICAgICB0eXBlOiBldmVudFR5cGVzLFxuICAgICAgZGVmYXVsdDogJ2NsaWNrJ1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByb3V0ZXIgPSB0aGlzLiRyb3V0ZXI7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLiRyb3V0ZTtcbiAgICB2YXIgcmVmID0gcm91dGVyLnJlc29sdmUodGhpcy50bywgY3VycmVudCwgdGhpcy5hcHBlbmQpO1xuICAgIHZhciBsb2NhdGlvbiA9IHJlZi5sb2NhdGlvbjtcbiAgICB2YXIgcm91dGUgPSByZWYucm91dGU7XG4gICAgdmFyIGhyZWYgPSByZWYuaHJlZjtcblxuICAgIHZhciBjbGFzc2VzID0ge307XG4gICAgdmFyIGdsb2JhbEFjdGl2ZUNsYXNzID0gcm91dGVyLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzO1xuICAgIHZhciBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzID0gcm91dGVyLm9wdGlvbnMubGlua0V4YWN0QWN0aXZlQ2xhc3M7XG4gICAgLy8gU3VwcG9ydCBnbG9iYWwgZW1wdHkgYWN0aXZlIGNsYXNzXG4gICAgdmFyIGFjdGl2ZUNsYXNzRmFsbGJhY2sgPSBnbG9iYWxBY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICA/ICdyb3V0ZXItbGluay1hY3RpdmUnXG4gICAgICA6IGdsb2JhbEFjdGl2ZUNsYXNzO1xuICAgIHZhciBleGFjdEFjdGl2ZUNsYXNzRmFsbGJhY2sgPSBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgID8gJ3JvdXRlci1saW5rLWV4YWN0LWFjdGl2ZSdcbiAgICAgIDogZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcztcbiAgICB2YXIgYWN0aXZlQ2xhc3MgPSB0aGlzLmFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgID8gYWN0aXZlQ2xhc3NGYWxsYmFja1xuICAgICAgOiB0aGlzLmFjdGl2ZUNsYXNzO1xuICAgIHZhciBleGFjdEFjdGl2ZUNsYXNzID0gdGhpcy5leGFjdEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgID8gZXhhY3RBY3RpdmVDbGFzc0ZhbGxiYWNrXG4gICAgICA6IHRoaXMuZXhhY3RBY3RpdmVDbGFzcztcbiAgICB2YXIgY29tcGFyZVRhcmdldCA9IGxvY2F0aW9uLnBhdGhcbiAgICAgID8gY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24sIG51bGwsIHJvdXRlcilcbiAgICAgIDogcm91dGU7XG5cbiAgICBjbGFzc2VzW2V4YWN0QWN0aXZlQ2xhc3NdID0gaXNTYW1lUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldCk7XG4gICAgY2xhc3Nlc1thY3RpdmVDbGFzc10gPSB0aGlzLmV4YWN0XG4gICAgICA/IGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc11cbiAgICAgIDogaXNJbmNsdWRlZFJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGd1YXJkRXZlbnQoZSkpIHtcbiAgICAgICAgaWYgKHRoaXMkMS5yZXBsYWNlKSB7XG4gICAgICAgICAgcm91dGVyLnJlcGxhY2UobG9jYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRlci5wdXNoKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb24gPSB7IGNsaWNrOiBndWFyZEV2ZW50IH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5ldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnQuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyBvbltlXSA9IGhhbmRsZXI7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvblt0aGlzLmV2ZW50XSA9IGhhbmRsZXI7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBjbGFzczogY2xhc3Nlc1xuICAgIH07XG5cbiAgICBpZiAodGhpcy50YWcgPT09ICdhJykge1xuICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgZGF0YS5hdHRycyA9IHsgaHJlZjogaHJlZiB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaW5kIHRoZSBmaXJzdCA8YT4gY2hpbGQgYW5kIGFwcGx5IGxpc3RlbmVyIGFuZCBocmVmXG4gICAgICB2YXIgYSA9IGZpbmRBbmNob3IodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgICBpZiAoYSkge1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSA8YT4gaXMgYSBzdGF0aWMgbm9kZVxuICAgICAgICBhLmlzU3RhdGljID0gZmFsc2U7XG4gICAgICAgIHZhciBhRGF0YSA9IGEuZGF0YSA9IGV4dGVuZCh7fSwgYS5kYXRhKTtcbiAgICAgICAgYURhdGEub24gPSBvbjtcbiAgICAgICAgdmFyIGFBdHRycyA9IGEuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYS5kYXRhLmF0dHJzKTtcbiAgICAgICAgYUF0dHJzLmhyZWYgPSBocmVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG9lc24ndCBoYXZlIDxhPiBjaGlsZCwgYXBwbHkgbGlzdGVuZXIgdG8gc2VsZlxuICAgICAgICBkYXRhLm9uID0gb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGhpcy50YWcsIGRhdGEsIHRoaXMuJHNsb3RzLmRlZmF1bHQpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ3VhcmRFdmVudCAoZSkge1xuICAvLyBkb24ndCByZWRpcmVjdCB3aXRoIGNvbnRyb2wga2V5c1xuICBpZiAoZS5tZXRhS2V5IHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdoZW4gcHJldmVudERlZmF1bHQgY2FsbGVkXG4gIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgb24gcmlnaHQgY2xpY2tcbiAgaWYgKGUuYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgZS5idXR0b24gIT09IDApIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3QgaWYgYHRhcmdldD1cIl9ibGFua1wiYFxuICBpZiAoZS5jdXJyZW50VGFyZ2V0ICYmIGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgaWYgKC9cXGJfYmxhbmtcXGIvaS50ZXN0KHRhcmdldCkpIHsgcmV0dXJuIH1cbiAgfVxuICAvLyB0aGlzIG1heSBiZSBhIFdlZXggZXZlbnQgd2hpY2ggZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kXG4gIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGZpbmRBbmNob3IgKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIHZhciBjaGlsZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ2EnKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuICYmIChjaGlsZCA9IGZpbmRBbmNob3IoY2hpbGQuY2hpbGRyZW4pKSkge1xuICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIF9WdWU7XG5cbmZ1bmN0aW9uIGluc3RhbGwgKFZ1ZSkge1xuICBpZiAoaW5zdGFsbC5pbnN0YWxsZWQgJiYgX1Z1ZSA9PT0gVnVlKSB7IHJldHVybiB9XG4gIGluc3RhbGwuaW5zdGFsbGVkID0gdHJ1ZTtcblxuICBfVnVlID0gVnVlO1xuXG4gIHZhciBpc0RlZiA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICE9PSB1bmRlZmluZWQ7IH07XG5cbiAgdmFyIHJlZ2lzdGVySW5zdGFuY2UgPSBmdW5jdGlvbiAodm0sIGNhbGxWYWwpIHtcbiAgICB2YXIgaSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgICBpZiAoaXNEZWYoaSkgJiYgaXNEZWYoaSA9IGkuZGF0YSkgJiYgaXNEZWYoaSA9IGkucmVnaXN0ZXJSb3V0ZUluc3RhbmNlKSkge1xuICAgICAgaSh2bSwgY2FsbFZhbCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5taXhpbih7XG4gICAgYmVmb3JlQ3JlYXRlOiBmdW5jdGlvbiBiZWZvcmVDcmVhdGUgKCkge1xuICAgICAgaWYgKGlzRGVmKHRoaXMuJG9wdGlvbnMucm91dGVyKSkge1xuICAgICAgICB0aGlzLl9yb3V0ZXJSb290ID0gdGhpcztcbiAgICAgICAgdGhpcy5fcm91dGVyID0gdGhpcy4kb3B0aW9ucy5yb3V0ZXI7XG4gICAgICAgIHRoaXMuX3JvdXRlci5pbml0KHRoaXMpO1xuICAgICAgICBWdWUudXRpbC5kZWZpbmVSZWFjdGl2ZSh0aGlzLCAnX3JvdXRlJywgdGhpcy5fcm91dGVyLmhpc3RvcnkuY3VycmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yb3V0ZXJSb290ID0gKHRoaXMuJHBhcmVudCAmJiB0aGlzLiRwYXJlbnQuX3JvdXRlclJvb3QpIHx8IHRoaXM7XG4gICAgICB9XG4gICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIHRoaXMpO1xuICAgIH0sXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHJvdXRlcicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJSb290Ll9yb3V0ZXIgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJSb290Ll9yb3V0ZSB9XG4gIH0pO1xuXG4gIFZ1ZS5jb21wb25lbnQoJ1JvdXRlclZpZXcnLCBWaWV3KTtcbiAgVnVlLmNvbXBvbmVudCgnUm91dGVyTGluaycsIExpbmspO1xuXG4gIHZhciBzdHJhdHMgPSBWdWUuY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcbiAgLy8gdXNlIHRoZSBzYW1lIGhvb2sgbWVyZ2luZyBzdHJhdGVneSBmb3Igcm91dGUgaG9va3NcbiAgc3RyYXRzLmJlZm9yZVJvdXRlRW50ZXIgPSBzdHJhdHMuYmVmb3JlUm91dGVMZWF2ZSA9IHN0cmF0cy5iZWZvcmVSb3V0ZVVwZGF0ZSA9IHN0cmF0cy5jcmVhdGVkO1xufVxuXG4vKiAgKi9cblxudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVBhdGggKFxuICByZWxhdGl2ZSxcbiAgYmFzZSxcbiAgYXBwZW5kXG4pIHtcbiAgdmFyIGZpcnN0Q2hhciA9IHJlbGF0aXZlLmNoYXJBdCgwKTtcbiAgaWYgKGZpcnN0Q2hhciA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlXG4gIH1cblxuICBpZiAoZmlyc3RDaGFyID09PSAnPycgfHwgZmlyc3RDaGFyID09PSAnIycpIHtcbiAgICByZXR1cm4gYmFzZSArIHJlbGF0aXZlXG4gIH1cblxuICB2YXIgc3RhY2sgPSBiYXNlLnNwbGl0KCcvJyk7XG5cbiAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNlZ21lbnQgaWY6XG4gIC8vIC0gbm90IGFwcGVuZGluZ1xuICAvLyAtIGFwcGVuZGluZyB0byB0cmFpbGluZyBzbGFzaCAobGFzdCBzZWdtZW50IGlzIGVtcHR5KVxuICBpZiAoIWFwcGVuZCB8fCAhc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICBzdGFjay5wb3AoKTtcbiAgfVxuXG4gIC8vIHJlc29sdmUgcmVsYXRpdmUgcGF0aFxuICB2YXIgc2VnbWVudHMgPSByZWxhdGl2ZS5yZXBsYWNlKC9eXFwvLywgJycpLnNwbGl0KCcvJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGlmIChzZWdtZW50ID09PSAnLi4nKSB7XG4gICAgICBzdGFjay5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09ICcuJykge1xuICAgICAgc3RhY2sucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBlbnN1cmUgbGVhZGluZyBzbGFzaFxuICBpZiAoc3RhY2tbMF0gIT09ICcnKSB7XG4gICAgc3RhY2sudW5zaGlmdCgnJyk7XG4gIH1cblxuICByZXR1cm4gc3RhY2suam9pbignLycpXG59XG5cbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICB2YXIgaGFzaCA9ICcnO1xuICB2YXIgcXVlcnkgPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgIGhhc2ggPSBwYXRoLnNsaWNlKGhhc2hJbmRleCk7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxdWVyeUluZGV4ID49IDApIHtcbiAgICBxdWVyeSA9IHBhdGguc2xpY2UocXVlcnlJbmRleCArIDEpO1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIHF1ZXJ5SW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBwYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBoYXNoOiBoYXNoXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5QYXRoIChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcL1xcLy9nLCAnLycpXG59XG5cbnZhciBpc2FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYHBhdGhUb1JlZ2V4cGAuXG4gKi9cbnZhciBwYXRoVG9SZWdleHBfMSA9IHBhdGhUb1JlZ2V4cDtcbnZhciBwYXJzZV8xID0gcGFyc2U7XG52YXIgY29tcGlsZV8xID0gY29tcGlsZTtcbnZhciB0b2tlbnNUb0Z1bmN0aW9uXzEgPSB0b2tlbnNUb0Z1bmN0aW9uO1xudmFyIHRva2Vuc1RvUmVnRXhwXzEgPSB0b2tlbnNUb1JlZ0V4cDtcblxuLyoqXG4gKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xuICAvLyBNYXRjaCBlc2NhcGVkIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYXBwZWFyIGluIGZ1dHVyZSBtYXRjaGVzLlxuICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgd29uJ3QgdHJhbnNmb3JtLlxuICAnKFxcXFxcXFxcLiknLFxuICAvLyBNYXRjaCBFeHByZXNzLXN0eWxlIHBhcmFtZXRlcnMgYW5kIHVuLW5hbWVkIHBhcmFtZXRlcnMgd2l0aCBhIHByZWZpeFxuICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuICAvL1xuICAvLyBcIi86dGVzdChcXFxcZCspP1wiID0+IFtcIi9cIiwgXCJ0ZXN0XCIsIFwiXFxkK1wiLCB1bmRlZmluZWQsIFwiP1wiLCB1bmRlZmluZWRdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiAgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgLy8gXCIvKlwiICAgICAgICAgICAgPT4gW1wiL1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiKlwiXVxuICAnKFtcXFxcLy5dKT8oPzooPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpKFsrKj9dKT98KFxcXFwqKSknXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIga2V5ID0gMDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHBhdGggPSAnJztcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJztcbiAgdmFyIHJlcztcblxuICB3aGlsZSAoKHJlcyA9IFBBVEhfUkVHRVhQLmV4ZWMoc3RyKSkgIT0gbnVsbCkge1xuICAgIHZhciBtID0gcmVzWzBdO1xuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdO1xuICAgIHZhciBvZmZzZXQgPSByZXMuaW5kZXg7XG4gICAgcGF0aCArPSBzdHIuc2xpY2UoaW5kZXgsIG9mZnNldCk7XG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aDtcblxuICAgIC8vIElnbm9yZSBhbHJlYWR5IGVzY2FwZWQgc2VxdWVuY2VzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICBwYXRoICs9IGVzY2FwZWRbMV07XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciBuZXh0ID0gc3RyW2luZGV4XTtcbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdO1xuICAgIHZhciBuYW1lID0gcmVzWzNdO1xuICAgIHZhciBjYXB0dXJlID0gcmVzWzRdO1xuICAgIHZhciBncm91cCA9IHJlc1s1XTtcbiAgICB2YXIgbW9kaWZpZXIgPSByZXNbNl07XG4gICAgdmFyIGFzdGVyaXNrID0gcmVzWzddO1xuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aCk7XG4gICAgICBwYXRoID0gJyc7XG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWwgPSBwcmVmaXggIT0gbnVsbCAmJiBuZXh0ICE9IG51bGwgJiYgbmV4dCAhPT0gcHJlZml4O1xuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKic7XG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonO1xuICAgIHZhciBkZWxpbWl0ZXIgPSByZXNbMl0gfHwgZGVmYXVsdERlbGltaXRlcjtcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXA7XG5cbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgcHJlZml4OiBwcmVmaXggfHwgJycsXG4gICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogcmVwZWF0LFxuICAgICAgcGFydGlhbDogcGFydGlhbCxcbiAgICAgIGFzdGVyaXNrOiAhIWFzdGVyaXNrLFxuICAgICAgcGF0dGVybjogcGF0dGVybiA/IGVzY2FwZUdyb3VwKHBhdHRlcm4pIDogKGFzdGVyaXNrID8gJy4qJyA6ICdbXicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICddKz8nKVxuICAgIH0pO1xuICB9XG5cbiAgLy8gTWF0Y2ggYW55IGNoYXJhY3RlcnMgc3RpbGwgcmVtYWluaW5nLlxuICBpZiAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgcGF0aCArPSBzdHIuc3Vic3RyKGluZGV4KTtcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aCk7XG4gIH1cblxuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshZnVuY3Rpb24oT2JqZWN0PSwgT2JqZWN0PSl9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKHN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpKVxufVxuXG4vKipcbiAqIFByZXR0aWVyIGVuY29kaW5nIG9mIFVSSSBwYXRoIHNlZ21lbnRzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1tcXC8/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRW5jb2RlIHRoZSBhc3RlcmlzayBwYXJhbWV0ZXIuIFNpbWlsYXIgdG8gYHByZXR0eWAsIGJ1dCBhbGxvd3Mgc2xhc2hlcy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZUFzdGVyaXNrIChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24gKHRva2Vucykge1xuICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXkodG9rZW5zLmxlbmd0aCk7XG5cbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHBhdHRlcm5zIGJlZm9yZSBjb21waWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1hdGNoZXNbaV0gPSBuZXcgUmVnRXhwKCdeKD86JyArIHRva2Vuc1tpXS5wYXR0ZXJuICsgJykkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICB2YXIgcGF0aCA9ICcnO1xuICAgIHZhciBkYXRhID0gb2JqIHx8IHt9O1xuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5wcmV0dHkgPyBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgOiBlbmNvZGVVUklDb21wb25lbnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuO1xuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV07XG4gICAgICB2YXIgc2VnbWVudDtcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNhcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSk7XG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKTtcblxuICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICB9XG5cbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18XFwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5cztcbiAgcmV0dXJuIHJlXG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSdcbn1cblxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAgKHBhdGgsIGtleXMpIHtcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpO1xuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cylcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSk7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpO1xuXG4gIHJldHVybiBhdHRhY2hLZXlzKHJlZ2V4cCwga2V5cylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9SZWdFeHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICAgICAgICAgIHRva2Vuc1xuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnRXhwICh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlO1xuICB2YXIgcm91dGUgPSAnJztcblxuICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeCk7XG4gICAgICB2YXIgY2FwdHVyZSA9ICcoPzonICsgdG9rZW4ucGF0dGVybiArICcpJztcblxuICAgICAga2V5cy5wdXNoKHRva2VuKTtcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKic7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICBpZiAoIXRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICBjYXB0dXJlID0gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJztcbiAgICAgIH1cblxuICAgICAgcm91dGUgKz0gY2FwdHVyZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsaW1pdGVyID0gZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJyk7XG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyO1xuXG4gIC8vIEluIG5vbi1zdHJpY3QgbW9kZSB3ZSBhbGxvdyBhIHNsYXNoIGF0IHRoZSBlbmQgb2YgbWF0Y2guIElmIHRoZSBwYXRoIHRvXG4gIC8vIG1hdGNoIGFscmVhZHkgZW5kcyB3aXRoIGEgc2xhc2gsIHdlIHJlbW92ZSBpdCBmb3IgY29uc2lzdGVuY3kuIFRoZSBzbGFzaFxuICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XG4gIC8vIGluIG5vbi1lbmRpbmcgbW9kZSwgd2hlcmUgXCIvdGVzdC9cIiBzaG91bGRuJ3QgbWF0Y2ggXCIvdGVzdC8vcm91dGVcIi5cbiAgaWYgKCFzdHJpY3QpIHtcbiAgICByb3V0ZSA9IChlbmRzV2l0aERlbGltaXRlciA/IHJvdXRlLnNsaWNlKDAsIC1kZWxpbWl0ZXIubGVuZ3RoKSA6IHJvdXRlKSArICcoPzonICsgZGVsaW1pdGVyICsgJyg/PSQpKT8nO1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJztcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknO1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyByb3V0ZSwgZmxhZ3Mob3B0aW9ucykpLCBrZXlzKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKlxuICogQHBhcmFtICB7KHN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19ICAgICAgIGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpO1xuICAgIGtleXMgPSBbXTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cykpXG4gIH1cblxuICBpZiAoaXNhcnJheShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKC8qKiBAdHlwZSB7IUFycmF5fSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbn1cbnBhdGhUb1JlZ2V4cF8xLnBhcnNlID0gcGFyc2VfMTtcbnBhdGhUb1JlZ2V4cF8xLmNvbXBpbGUgPSBjb21waWxlXzE7XG5wYXRoVG9SZWdleHBfMS50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvbl8xO1xucGF0aFRvUmVnZXhwXzEudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cF8xO1xuXG4vKiAgKi9cblxuLy8gJGZsb3ctZGlzYWJsZS1saW5lXG52YXIgcmVnZXhwQ29tcGlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gZmlsbFBhcmFtcyAoXG4gIHBhdGgsXG4gIHBhcmFtcyxcbiAgcm91dGVNc2dcbikge1xuICB0cnkge1xuICAgIHZhciBmaWxsZXIgPVxuICAgICAgcmVnZXhwQ29tcGlsZUNhY2hlW3BhdGhdIHx8XG4gICAgICAocmVnZXhwQ29tcGlsZUNhY2hlW3BhdGhdID0gcGF0aFRvUmVnZXhwXzEuY29tcGlsZShwYXRoKSk7XG4gICAgcmV0dXJuIGZpbGxlcihwYXJhbXMgfHwge30sIHsgcHJldHR5OiB0cnVlIH0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybihmYWxzZSwgKFwibWlzc2luZyBwYXJhbSBmb3IgXCIgKyByb3V0ZU1zZyArIFwiOiBcIiArIChlLm1lc3NhZ2UpKSk7XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZU1hcCAoXG4gIHJvdXRlcyxcbiAgb2xkUGF0aExpc3QsXG4gIG9sZFBhdGhNYXAsXG4gIG9sZE5hbWVNYXBcbikge1xuICAvLyB0aGUgcGF0aCBsaXN0IGlzIHVzZWQgdG8gY29udHJvbCBwYXRoIG1hdGNoaW5nIHByaW9yaXR5XG4gIHZhciBwYXRoTGlzdCA9IG9sZFBhdGhMaXN0IHx8IFtdO1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIHBhdGhNYXAgPSBvbGRQYXRoTWFwIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgbmFtZU1hcCA9IG9sZE5hbWVNYXAgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByb3V0ZXMuZm9yRWFjaChmdW5jdGlvbiAocm91dGUpIHtcbiAgICBhZGRSb3V0ZVJlY29yZChwYXRoTGlzdCwgcGF0aE1hcCwgbmFtZU1hcCwgcm91dGUpO1xuICB9KTtcblxuICAvLyBlbnN1cmUgd2lsZGNhcmQgcm91dGVzIGFyZSBhbHdheXMgYXQgdGhlIGVuZFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChwYXRoTGlzdFtpXSA9PT0gJyonKSB7XG4gICAgICBwYXRoTGlzdC5wdXNoKHBhdGhMaXN0LnNwbGljZShpLCAxKVswXSk7XG4gICAgICBsLS07XG4gICAgICBpLS07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoTGlzdDogcGF0aExpc3QsXG4gICAgcGF0aE1hcDogcGF0aE1hcCxcbiAgICBuYW1lTWFwOiBuYW1lTWFwXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUm91dGVSZWNvcmQgKFxuICBwYXRoTGlzdCxcbiAgcGF0aE1hcCxcbiAgbmFtZU1hcCxcbiAgcm91dGUsXG4gIHBhcmVudCxcbiAgbWF0Y2hBc1xuKSB7XG4gIHZhciBwYXRoID0gcm91dGUucGF0aDtcbiAgdmFyIG5hbWUgPSByb3V0ZS5uYW1lO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChwYXRoICE9IG51bGwsIFwiXFxcInBhdGhcXFwiIGlzIHJlcXVpcmVkIGluIGEgcm91dGUgY29uZmlndXJhdGlvbi5cIik7XG4gICAgYXNzZXJ0KFxuICAgICAgdHlwZW9mIHJvdXRlLmNvbXBvbmVudCAhPT0gJ3N0cmluZycsXG4gICAgICBcInJvdXRlIGNvbmZpZyBcXFwiY29tcG9uZW50XFxcIiBmb3IgcGF0aDogXCIgKyAoU3RyaW5nKHBhdGggfHwgbmFtZSkpICsgXCIgY2Fubm90IGJlIGEgXCIgK1xuICAgICAgXCJzdHJpbmcgaWQuIFVzZSBhbiBhY3R1YWwgY29tcG9uZW50IGluc3RlYWQuXCJcbiAgICApO1xuICB9XG5cbiAgdmFyIHBhdGhUb1JlZ2V4cE9wdGlvbnMgPSByb3V0ZS5wYXRoVG9SZWdleHBPcHRpb25zIHx8IHt9O1xuICB2YXIgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVQYXRoKFxuICAgIHBhdGgsXG4gICAgcGFyZW50LFxuICAgIHBhdGhUb1JlZ2V4cE9wdGlvbnMuc3RyaWN0XG4gICk7XG5cbiAgaWYgKHR5cGVvZiByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSAnYm9vbGVhbicpIHtcbiAgICBwYXRoVG9SZWdleHBPcHRpb25zLnNlbnNpdGl2ZSA9IHJvdXRlLmNhc2VTZW5zaXRpdmU7XG4gIH1cblxuICB2YXIgcmVjb3JkID0ge1xuICAgIHBhdGg6IG5vcm1hbGl6ZWRQYXRoLFxuICAgIHJlZ2V4OiBjb21waWxlUm91dGVSZWdleChub3JtYWxpemVkUGF0aCwgcGF0aFRvUmVnZXhwT3B0aW9ucyksXG4gICAgY29tcG9uZW50czogcm91dGUuY29tcG9uZW50cyB8fCB7IGRlZmF1bHQ6IHJvdXRlLmNvbXBvbmVudCB9LFxuICAgIGluc3RhbmNlczoge30sXG4gICAgbmFtZTogbmFtZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBtYXRjaEFzOiBtYXRjaEFzLFxuICAgIHJlZGlyZWN0OiByb3V0ZS5yZWRpcmVjdCxcbiAgICBiZWZvcmVFbnRlcjogcm91dGUuYmVmb3JlRW50ZXIsXG4gICAgbWV0YTogcm91dGUubWV0YSB8fCB7fSxcbiAgICBwcm9wczogcm91dGUucHJvcHMgPT0gbnVsbFxuICAgICAgPyB7fVxuICAgICAgOiByb3V0ZS5jb21wb25lbnRzXG4gICAgICAgID8gcm91dGUucHJvcHNcbiAgICAgICAgOiB7IGRlZmF1bHQ6IHJvdXRlLnByb3BzIH1cbiAgfTtcblxuICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAvLyBXYXJuIGlmIHJvdXRlIGlzIG5hbWVkLCBkb2VzIG5vdCByZWRpcmVjdCBhbmQgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS5cbiAgICAvLyBJZiB1c2VycyBuYXZpZ2F0ZSB0byB0aGlzIHJvdXRlIGJ5IG5hbWUsIHRoZSBkZWZhdWx0IGNoaWxkIHdpbGxcbiAgICAvLyBub3QgYmUgcmVuZGVyZWQgKEdIIElzc3VlICM2MjkpXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChyb3V0ZS5uYW1lICYmICFyb3V0ZS5yZWRpcmVjdCAmJiByb3V0ZS5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gL15cXC8/JC8udGVzdChjaGlsZC5wYXRoKTsgfSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIk5hbWVkIFJvdXRlICdcIiArIChyb3V0ZS5uYW1lKSArIFwiJyBoYXMgYSBkZWZhdWx0IGNoaWxkIHJvdXRlLiBcIiArXG4gICAgICAgICAgXCJXaGVuIG5hdmlnYXRpbmcgdG8gdGhpcyBuYW1lZCByb3V0ZSAoOnRvPVxcXCJ7bmFtZTogJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInXFxcIiksIFwiICtcbiAgICAgICAgICBcInRoZSBkZWZhdWx0IGNoaWxkIHJvdXRlIHdpbGwgbm90IGJlIHJlbmRlcmVkLiBSZW1vdmUgdGhlIG5hbWUgZnJvbSBcIiArXG4gICAgICAgICAgXCJ0aGlzIHJvdXRlIGFuZCB1c2UgdGhlIG5hbWUgb2YgdGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgZm9yIG5hbWVkIFwiICtcbiAgICAgICAgICBcImxpbmtzIGluc3RlYWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcm91dGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZE1hdGNoQXMgPSBtYXRjaEFzXG4gICAgICAgID8gY2xlYW5QYXRoKChtYXRjaEFzICsgXCIvXCIgKyAoY2hpbGQucGF0aCkpKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwLCBjaGlsZCwgcmVjb3JkLCBjaGlsZE1hdGNoQXMpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJvdXRlLmFsaWFzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgYWxpYXNlcyA9IEFycmF5LmlzQXJyYXkocm91dGUuYWxpYXMpXG4gICAgICA/IHJvdXRlLmFsaWFzXG4gICAgICA6IFtyb3V0ZS5hbGlhc107XG5cbiAgICBhbGlhc2VzLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICB2YXIgYWxpYXNSb3V0ZSA9IHtcbiAgICAgICAgcGF0aDogYWxpYXMsXG4gICAgICAgIGNoaWxkcmVuOiByb3V0ZS5jaGlsZHJlblxuICAgICAgfTtcbiAgICAgIGFkZFJvdXRlUmVjb3JkKFxuICAgICAgICBwYXRoTGlzdCxcbiAgICAgICAgcGF0aE1hcCxcbiAgICAgICAgbmFtZU1hcCxcbiAgICAgICAgYWxpYXNSb3V0ZSxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICByZWNvcmQucGF0aCB8fCAnLycgLy8gbWF0Y2hBc1xuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghcGF0aE1hcFtyZWNvcmQucGF0aF0pIHtcbiAgICBwYXRoTGlzdC5wdXNoKHJlY29yZC5wYXRoKTtcbiAgICBwYXRoTWFwW3JlY29yZC5wYXRoXSA9IHJlY29yZDtcbiAgfVxuXG4gIGlmIChuYW1lKSB7XG4gICAgaWYgKCFuYW1lTWFwW25hbWVdKSB7XG4gICAgICBuYW1lTWFwW25hbWVdID0gcmVjb3JkO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhbWF0Y2hBcykge1xuICAgICAgd2FybihcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiRHVwbGljYXRlIG5hbWVkIHJvdXRlcyBkZWZpbml0aW9uOiBcIiArXG4gICAgICAgIFwieyBuYW1lOiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBwYXRoOiBcXFwiXCIgKyAocmVjb3JkLnBhdGgpICsgXCJcXFwiIH1cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGlsZVJvdXRlUmVnZXggKHBhdGgsIHBhdGhUb1JlZ2V4cE9wdGlvbnMpIHtcbiAgdmFyIHJlZ2V4ID0gcGF0aFRvUmVnZXhwXzEocGF0aCwgW10sIHBhdGhUb1JlZ2V4cE9wdGlvbnMpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZWdleC5rZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgd2Fybigha2V5c1trZXkubmFtZV0sIChcIkR1cGxpY2F0ZSBwYXJhbSBrZXlzIGluIHJvdXRlIHdpdGggcGF0aDogXFxcIlwiICsgcGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICBrZXlzW2tleS5uYW1lXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlZ2V4XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGggKHBhdGgsIHBhcmVudCwgc3RyaWN0KSB7XG4gIGlmICghc3RyaWN0KSB7IHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCAnJyk7IH1cbiAgaWYgKHBhdGhbMF0gPT09ICcvJykgeyByZXR1cm4gcGF0aCB9XG4gIGlmIChwYXJlbnQgPT0gbnVsbCkgeyByZXR1cm4gcGF0aCB9XG4gIHJldHVybiBjbGVhblBhdGgoKChwYXJlbnQucGF0aCkgKyBcIi9cIiArIHBhdGgpKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplTG9jYXRpb24gKFxuICByYXcsXG4gIGN1cnJlbnQsXG4gIGFwcGVuZCxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIG5leHQgPSB0eXBlb2YgcmF3ID09PSAnc3RyaW5nJyA/IHsgcGF0aDogcmF3IH0gOiByYXc7XG4gIC8vIG5hbWVkIHRhcmdldFxuICBpZiAobmV4dC5uYW1lIHx8IG5leHQuX25vcm1hbGl6ZWQpIHtcbiAgICByZXR1cm4gbmV4dFxuICB9XG5cbiAgLy8gcmVsYXRpdmUgcGFyYW1zXG4gIGlmICghbmV4dC5wYXRoICYmIG5leHQucGFyYW1zICYmIGN1cnJlbnQpIHtcbiAgICBuZXh0ID0gZXh0ZW5kKHt9LCBuZXh0KTtcbiAgICBuZXh0Ll9ub3JtYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgcGFyYW1zID0gZXh0ZW5kKGV4dGVuZCh7fSwgY3VycmVudC5wYXJhbXMpLCBuZXh0LnBhcmFtcyk7XG4gICAgaWYgKGN1cnJlbnQubmFtZSkge1xuICAgICAgbmV4dC5uYW1lID0gY3VycmVudC5uYW1lO1xuICAgICAgbmV4dC5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50Lm1hdGNoZWQubGVuZ3RoKSB7XG4gICAgICB2YXIgcmF3UGF0aCA9IGN1cnJlbnQubWF0Y2hlZFtjdXJyZW50Lm1hdGNoZWQubGVuZ3RoIC0gMV0ucGF0aDtcbiAgICAgIG5leHQucGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJwYXRoIFwiICsgKGN1cnJlbnQucGF0aCkpKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oZmFsc2UsIFwicmVsYXRpdmUgcGFyYW1zIG5hdmlnYXRpb24gcmVxdWlyZXMgYSBjdXJyZW50IHJvdXRlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG4gIHZhciBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKG5leHQucGF0aCB8fCAnJyk7XG4gIHZhciBiYXNlUGF0aCA9IChjdXJyZW50ICYmIGN1cnJlbnQucGF0aCkgfHwgJy8nO1xuICB2YXIgcGF0aCA9IHBhcnNlZFBhdGgucGF0aFxuICAgID8gcmVzb2x2ZVBhdGgocGFyc2VkUGF0aC5wYXRoLCBiYXNlUGF0aCwgYXBwZW5kIHx8IG5leHQuYXBwZW5kKVxuICAgIDogYmFzZVBhdGg7XG5cbiAgdmFyIHF1ZXJ5ID0gcmVzb2x2ZVF1ZXJ5KFxuICAgIHBhcnNlZFBhdGgucXVlcnksXG4gICAgbmV4dC5xdWVyeSxcbiAgICByb3V0ZXIgJiYgcm91dGVyLm9wdGlvbnMucGFyc2VRdWVyeVxuICApO1xuXG4gIHZhciBoYXNoID0gbmV4dC5oYXNoIHx8IHBhcnNlZFBhdGguaGFzaDtcbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykge1xuICAgIGhhc2ggPSBcIiNcIiArIGhhc2g7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXIgKFxuICByb3V0ZXMsXG4gIHJvdXRlclxuKSB7XG4gIHZhciByZWYgPSBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMpO1xuICB2YXIgcGF0aExpc3QgPSByZWYucGF0aExpc3Q7XG4gIHZhciBwYXRoTWFwID0gcmVmLnBhdGhNYXA7XG4gIHZhciBuYW1lTWFwID0gcmVmLm5hbWVNYXA7XG5cbiAgZnVuY3Rpb24gYWRkUm91dGVzIChyb3V0ZXMpIHtcbiAgICBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMsIHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoIChcbiAgICByYXcsXG4gICAgY3VycmVudFJvdXRlLFxuICAgIHJlZGlyZWN0ZWRGcm9tXG4gICkge1xuICAgIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKHJhdywgY3VycmVudFJvdXRlLCBmYWxzZSwgcm91dGVyKTtcbiAgICB2YXIgbmFtZSA9IGxvY2F0aW9uLm5hbWU7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgdmFyIHJlY29yZCA9IG5hbWVNYXBbbmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKHJlY29yZCwgKFwiUm91dGUgd2l0aCBuYW1lICdcIiArIG5hbWUgKyBcIicgZG9lcyBub3QgZXhpc3RcIikpO1xuICAgICAgfVxuICAgICAgaWYgKCFyZWNvcmQpIHsgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbikgfVxuICAgICAgdmFyIHBhcmFtTmFtZXMgPSByZWNvcmQucmVnZXgua2V5c1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICFrZXkub3B0aW9uYWw7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5Lm5hbWU7IH0pO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uLnBhcmFtcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbG9jYXRpb24ucGFyYW1zID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50Um91dGUgJiYgdHlwZW9mIGN1cnJlbnRSb3V0ZS5wYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50Um91dGUucGFyYW1zKSB7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIGxvY2F0aW9uLnBhcmFtcykgJiYgcGFyYW1OYW1lcy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICAgbG9jYXRpb24ucGFyYW1zW2tleV0gPSBjdXJyZW50Um91dGUucGFyYW1zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgbG9jYXRpb24ucGF0aCA9IGZpbGxQYXJhbXMocmVjb3JkLnBhdGgsIGxvY2F0aW9uLnBhcmFtcywgKFwibmFtZWQgcm91dGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSk7XG4gICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRoKSB7XG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoTGlzdFtpXTtcbiAgICAgICAgdmFyIHJlY29yZCQxID0gcGF0aE1hcFtwYXRoXTtcbiAgICAgICAgaWYgKG1hdGNoUm91dGUocmVjb3JkJDEucmVnZXgsIGxvY2F0aW9uLnBhdGgsIGxvY2F0aW9uLnBhcmFtcykpIHtcbiAgICAgICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKHJlY29yZCQxLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm8gbWF0Y2hcbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVkaXJlY3QgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvblxuICApIHtcbiAgICB2YXIgb3JpZ2luYWxSZWRpcmVjdCA9IHJlY29yZC5yZWRpcmVjdDtcbiAgICB2YXIgcmVkaXJlY3QgPSB0eXBlb2Ygb3JpZ2luYWxSZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBvcmlnaW5hbFJlZGlyZWN0KGNyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIG51bGwsIHJvdXRlcikpXG4gICAgICA6IG9yaWdpbmFsUmVkaXJlY3Q7XG5cbiAgICBpZiAodHlwZW9mIHJlZGlyZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmVkaXJlY3QgPSB7IHBhdGg6IHJlZGlyZWN0IH07XG4gICAgfVxuXG4gICAgaWYgKCFyZWRpcmVjdCB8fCB0eXBlb2YgcmVkaXJlY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuXG4gICAgdmFyIHJlID0gcmVkaXJlY3Q7XG4gICAgdmFyIG5hbWUgPSByZS5uYW1lO1xuICAgIHZhciBwYXRoID0gcmUucGF0aDtcbiAgICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHBhcmFtcyA9IGxvY2F0aW9uLnBhcmFtcztcbiAgICBxdWVyeSA9IHJlLmhhc093blByb3BlcnR5KCdxdWVyeScpID8gcmUucXVlcnkgOiBxdWVyeTtcbiAgICBoYXNoID0gcmUuaGFzT3duUHJvcGVydHkoJ2hhc2gnKSA/IHJlLmhhc2ggOiBoYXNoO1xuICAgIHBhcmFtcyA9IHJlLmhhc093blByb3BlcnR5KCdwYXJhbXMnKSA/IHJlLnBhcmFtcyA6IHBhcmFtcztcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICAvLyByZXNvbHZlZCBuYW1lZCBkaXJlY3RcbiAgICAgIHZhciB0YXJnZXRSZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KHRhcmdldFJlY29yZCwgKFwicmVkaXJlY3QgZmFpbGVkOiBuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIG5vdCBmb3VuZC5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIGlmIChwYXRoKSB7XG4gICAgICAvLyAxLiByZXNvbHZlIHJlbGF0aXZlIHJlZGlyZWN0XG4gICAgICB2YXIgcmF3UGF0aCA9IHJlc29sdmVSZWNvcmRQYXRoKHBhdGgsIHJlY29yZCk7XG4gICAgICAvLyAyLiByZXNvbHZlIHBhcmFtc1xuICAgICAgdmFyIHJlc29sdmVkUGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJyZWRpcmVjdCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgcmF3UGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICAvLyAzLiByZW1hdGNoIHdpdGggZXhpc3RpbmcgcXVlcnkgYW5kIGhhc2hcbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBwYXRoOiByZXNvbHZlZFBhdGgsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaFxuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWxpYXMgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICBtYXRjaEFzXG4gICkge1xuICAgIHZhciBhbGlhc2VkUGF0aCA9IGZpbGxQYXJhbXMobWF0Y2hBcywgbG9jYXRpb24ucGFyYW1zLCAoXCJhbGlhc2VkIHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyBtYXRjaEFzICsgXCJcXFwiXCIpKTtcbiAgICB2YXIgYWxpYXNlZE1hdGNoID0gbWF0Y2goe1xuICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICBwYXRoOiBhbGlhc2VkUGF0aFxuICAgIH0pO1xuICAgIGlmIChhbGlhc2VkTWF0Y2gpIHtcbiAgICAgIHZhciBtYXRjaGVkID0gYWxpYXNlZE1hdGNoLm1hdGNoZWQ7XG4gICAgICB2YXIgYWxpYXNlZFJlY29yZCA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IGFsaWFzZWRNYXRjaC5wYXJhbXM7XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKGFsaWFzZWRSZWNvcmQsIGxvY2F0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZVJvdXRlIChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb24sXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQucmVkaXJlY3QpIHtcbiAgICAgIHJldHVybiByZWRpcmVjdChyZWNvcmQsIHJlZGlyZWN0ZWRGcm9tIHx8IGxvY2F0aW9uKVxuICAgIH1cbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5tYXRjaEFzKSB7XG4gICAgICByZXR1cm4gYWxpYXMocmVjb3JkLCBsb2NhdGlvbiwgcmVjb3JkLm1hdGNoQXMpXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSwgcm91dGVyKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgYWRkUm91dGVzOiBhZGRSb3V0ZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlIChcbiAgcmVnZXgsXG4gIHBhdGgsXG4gIHBhcmFtc1xuKSB7XG4gIHZhciBtID0gcGF0aC5tYXRjaChyZWdleCk7XG5cbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmb3IgKHZhciBpID0gMSwgbGVuID0gbS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBrZXkgPSByZWdleC5rZXlzW2kgLSAxXTtcbiAgICB2YXIgdmFsID0gdHlwZW9mIG1baV0gPT09ICdzdHJpbmcnID8gZGVjb2RlVVJJQ29tcG9uZW50KG1baV0pIDogbVtpXTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICAvLyBGaXggIzE5OTQ6IHVzaW5nICogd2l0aCBwcm9wczogdHJ1ZSBnZW5lcmF0ZXMgYSBwYXJhbSBuYW1lZCAwXG4gICAgICBwYXJhbXNba2V5Lm5hbWUgfHwgJ3BhdGhNYXRjaCddID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVSZWNvcmRQYXRoIChwYXRoLCByZWNvcmQpIHtcbiAgcmV0dXJuIHJlc29sdmVQYXRoKHBhdGgsIHJlY29yZC5wYXJlbnQgPyByZWNvcmQucGFyZW50LnBhdGggOiAnLycsIHRydWUpXG59XG5cbi8qICAqL1xuXG52YXIgcG9zaXRpb25TdG9yZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIHNldHVwU2Nyb2xsICgpIHtcbiAgLy8gRml4IGZvciAjMTU4NSBmb3IgRmlyZWZveFxuICAvLyBGaXggZm9yICMyMTk1IEFkZCBvcHRpb25hbCB0aGlyZCBhdHRyaWJ1dGUgdG8gd29ya2Fyb3VuZCBhIGJ1ZyBpbiBzYWZhcmkgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4MjY3OFxuICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IGdldFN0YXRlS2V5KCkgfSwgJycsIHdpbmRvdy5sb2NhdGlvbi5ocmVmLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLm9yaWdpbiwgJycpKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgICBpZiAoZS5zdGF0ZSAmJiBlLnN0YXRlLmtleSkge1xuICAgICAgc2V0U3RhdGVLZXkoZS5zdGF0ZS5rZXkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVNjcm9sbCAoXG4gIHJvdXRlcixcbiAgdG8sXG4gIGZyb20sXG4gIGlzUG9wXG4pIHtcbiAgaWYgKCFyb3V0ZXIuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmVoYXZpb3IgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcbiAgaWYgKCFiZWhhdmlvcikge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJlaGF2aW9yID09PSAnZnVuY3Rpb24nLCBcInNjcm9sbEJlaGF2aW9yIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIC8vIHdhaXQgdW50aWwgcmUtcmVuZGVyIGZpbmlzaGVzIGJlZm9yZSBzY3JvbGxpbmdcbiAgcm91dGVyLmFwcC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgdmFyIHNob3VsZFNjcm9sbCA9IGJlaGF2aW9yLmNhbGwocm91dGVyLCB0bywgZnJvbSwgaXNQb3AgPyBwb3NpdGlvbiA6IG51bGwpO1xuXG4gICAgaWYgKCFzaG91bGRTY3JvbGwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2hvdWxkU2Nyb2xsLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNob3VsZFNjcm9sbC50aGVuKGZ1bmN0aW9uIChzaG91bGRTY3JvbGwpIHtcbiAgICAgICAgc2Nyb2xsVG9Qb3NpdGlvbigoc2hvdWxkU2Nyb2xsKSwgcG9zaXRpb24pO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGFzc2VydChmYWxzZSwgZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Nyb2xsVG9Qb3NpdGlvbihzaG91bGRTY3JvbGwsIHBvc2l0aW9uKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHBvc2l0aW9uU3RvcmVba2V5XSA9IHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHJldHVybiBwb3NpdGlvblN0b3JlW2tleV1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50UG9zaXRpb24gKGVsLCBvZmZzZXQpIHtcbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgZG9jUmVjdCA9IGRvY0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgeDogZWxSZWN0LmxlZnQgLSBkb2NSZWN0LmxlZnQgLSBvZmZzZXQueCxcbiAgICB5OiBlbFJlY3QudG9wIC0gZG9jUmVjdC50b3AgLSBvZmZzZXQueVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRQb3NpdGlvbiAob2JqKSB7XG4gIHJldHVybiBpc051bWJlcihvYmoueCkgfHwgaXNOdW1iZXIob2JqLnkpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICB5OiBpc051bWJlcihvYmoueSkgPyBvYmoueSA6IHdpbmRvdy5wYWdlWU9mZnNldFxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9mZnNldCAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgeDogaXNOdW1iZXIob2JqLngpID8gb2JqLnggOiAwLFxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogMFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyICh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gc2Nyb2xsVG9Qb3NpdGlvbiAoc2hvdWxkU2Nyb2xsLCBwb3NpdGlvbikge1xuICB2YXIgaXNPYmplY3QgPSB0eXBlb2Ygc2hvdWxkU2Nyb2xsID09PSAnb2JqZWN0JztcbiAgaWYgKGlzT2JqZWN0ICYmIHR5cGVvZiBzaG91bGRTY3JvbGwuc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzaG91bGRTY3JvbGwuc2VsZWN0b3IpO1xuICAgIGlmIChlbCkge1xuICAgICAgdmFyIG9mZnNldCA9IHNob3VsZFNjcm9sbC5vZmZzZXQgJiYgdHlwZW9mIHNob3VsZFNjcm9sbC5vZmZzZXQgPT09ICdvYmplY3QnID8gc2hvdWxkU2Nyb2xsLm9mZnNldCA6IHt9O1xuICAgICAgb2Zmc2V0ID0gbm9ybWFsaXplT2Zmc2V0KG9mZnNldCk7XG4gICAgICBwb3NpdGlvbiA9IGdldEVsZW1lbnRQb3NpdGlvbihlbCwgb2Zmc2V0KTtcbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XG4gICAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKHNob3VsZFNjcm9sbCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0ICYmIGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XG4gICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xuICB9XG5cbiAgaWYgKHBvc2l0aW9uKSB7XG4gICAgd2luZG93LnNjcm9sbFRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSBpbkJyb3dzZXIgJiYgKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgaWYgKFxuICAgICh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJlxuICAgIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiZcbiAgICB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiZcbiAgICB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5XG59KSgpO1xuXG4vLyB1c2UgVXNlciBUaW1pbmcgYXBpIChpZiBwcmVzZW50KSBmb3IgbW9yZSBhY2N1cmF0ZSBrZXkgcHJlY2lzaW9uXG52YXIgVGltZSA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vd1xuICA/IHdpbmRvdy5wZXJmb3JtYW5jZVxuICA6IERhdGU7XG5cbnZhciBfa2V5ID0gZ2VuS2V5KCk7XG5cbmZ1bmN0aW9uIGdlbktleSAoKSB7XG4gIHJldHVybiBUaW1lLm5vdygpLnRvRml4ZWQoMylcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVLZXkgKCkge1xuICByZXR1cm4gX2tleVxufVxuXG5mdW5jdGlvbiBzZXRTdGF0ZUtleSAoa2V5KSB7XG4gIF9rZXkgPSBrZXk7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGF0ZSAodXJsLCByZXBsYWNlKSB7XG4gIHNhdmVTY3JvbGxQb3NpdGlvbigpO1xuICAvLyB0cnkuLi5jYXRjaCB0aGUgcHVzaFN0YXRlIGNhbGwgdG8gZ2V0IGFyb3VuZCBTYWZhcmlcbiAgLy8gRE9NIEV4Y2VwdGlvbiAxOCB3aGVyZSBpdCBsaW1pdHMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxsc1xuICB2YXIgaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2tleSA9IGdlbktleSgpO1xuICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IF9rZXkgfSwgJycsIHVybCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgd2luZG93LmxvY2F0aW9uW3JlcGxhY2UgPyAncmVwbGFjZScgOiAnYXNzaWduJ10odXJsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlU3RhdGUgKHVybCkge1xuICBwdXNoU3RhdGUodXJsLCB0cnVlKTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJ1blF1ZXVlIChxdWV1ZSwgZm4sIGNiKSB7XG4gIHZhciBzdGVwID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHF1ZXVlW2luZGV4XSkge1xuICAgICAgICBmbihxdWV1ZVtpbmRleF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RlcChpbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3RlcCgwKTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudHMgKG1hdGNoZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHZhciBoYXNBc3luYyA9IGZhbHNlO1xuICAgIHZhciBwZW5kaW5nID0gMDtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuXG4gICAgZmxhdE1hcENvbXBvbmVudHMobWF0Y2hlZCwgZnVuY3Rpb24gKGRlZiwgXywgbWF0Y2gsIGtleSkge1xuICAgICAgLy8gaWYgaXQncyBhIGZ1bmN0aW9uIGFuZCBkb2Vzbid0IGhhdmUgY2lkIGF0dGFjaGVkLFxuICAgICAgLy8gYXNzdW1lIGl0J3MgYW4gYXN5bmMgY29tcG9uZW50IHJlc29sdmUgZnVuY3Rpb24uXG4gICAgICAvLyB3ZSBhcmUgbm90IHVzaW5nIFZ1ZSdzIGRlZmF1bHQgYXN5bmMgcmVzb2x2aW5nIG1lY2hhbmlzbSBiZWNhdXNlXG4gICAgICAvLyB3ZSB3YW50IHRvIGhhbHQgdGhlIG5hdmlnYXRpb24gdW50aWwgdGhlIGluY29taW5nIGNvbXBvbmVudCBoYXMgYmVlblxuICAgICAgLy8gcmVzb2x2ZWQuXG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWYuY2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGFzQXN5bmMgPSB0cnVlO1xuICAgICAgICBwZW5kaW5nKys7XG5cbiAgICAgICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXNvbHZlZERlZikge1xuICAgICAgICAgIGlmIChpc0VTTW9kdWxlKHJlc29sdmVkRGVmKSkge1xuICAgICAgICAgICAgcmVzb2x2ZWREZWYgPSByZXNvbHZlZERlZi5kZWZhdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzYXZlIHJlc29sdmVkIG9uIGFzeW5jIGZhY3RvcnkgaW4gY2FzZSBpdCdzIHVzZWQgZWxzZXdoZXJlXG4gICAgICAgICAgZGVmLnJlc29sdmVkID0gdHlwZW9mIHJlc29sdmVkRGVmID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHJlc29sdmVkRGVmXG4gICAgICAgICAgICA6IF9WdWUuZXh0ZW5kKHJlc29sdmVkRGVmKTtcbiAgICAgICAgICBtYXRjaC5jb21wb25lbnRzW2tleV0gPSByZXNvbHZlZERlZjtcbiAgICAgICAgICBwZW5kaW5nLS07XG4gICAgICAgICAgaWYgKHBlbmRpbmcgPD0gMCkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIHZhciBtc2cgPSBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudCBcIiArIGtleSArIFwiOiBcIiArIHJlYXNvbjtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oZmFsc2UsIG1zZyk7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IgPSBpc0Vycm9yKHJlYXNvbilcbiAgICAgICAgICAgICAgPyByZWFzb25cbiAgICAgICAgICAgICAgOiBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIG5leHQoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSBkZWYocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbmV3IHN5bnRheCBpbiBWdWUgMi4zXG4gICAgICAgICAgICB2YXIgY29tcCA9IHJlcy5jb21wb25lbnQ7XG4gICAgICAgICAgICBpZiAoY29tcCAmJiB0eXBlb2YgY29tcC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNvbXAudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFoYXNBc3luYykgeyBuZXh0KCk7IH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0TWFwQ29tcG9uZW50cyAoXG4gIG1hdGNoZWQsXG4gIGZuXG4pIHtcbiAgcmV0dXJuIGZsYXR0ZW4obWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZm4oXG4gICAgICBtLmNvbXBvbmVudHNba2V5XSxcbiAgICAgIG0uaW5zdGFuY2VzW2tleV0sXG4gICAgICBtLCBrZXlcbiAgICApOyB9KVxuICB9KSlcbn1cblxuZnVuY3Rpb24gZmxhdHRlbiAoYXJyKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG5mdW5jdGlvbiBpc0VTTW9kdWxlIChvYmopIHtcbiAgcmV0dXJuIG9iai5fX2VzTW9kdWxlIHx8IChoYXNTeW1ib2wgJiYgb2JqW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxufVxuXG4vLyBpbiBXZWJwYWNrIDIsIHJlcXVpcmUuZW5zdXJlIG5vdyBhbHNvIHJldHVybnMgYSBQcm9taXNlXG4vLyBzbyB0aGUgcmVzb2x2ZS9yZWplY3QgZnVuY3Rpb25zIG1heSBnZXQgY2FsbGVkIGFuIGV4dHJhIHRpbWVcbi8vIGlmIHRoZSB1c2VyIHVzZXMgYW4gYXJyb3cgZnVuY3Rpb24gc2hvcnRoYW5kIHRoYXQgaGFwcGVucyB0b1xuLy8gcmV0dXJuIHRoYXQgUHJvbWlzZS5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICBpZiAoY2FsbGVkKSB7IHJldHVybiB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIEhpc3RvcnkgPSBmdW5jdGlvbiBIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gIHRoaXMuYmFzZSA9IG5vcm1hbGl6ZUJhc2UoYmFzZSk7XG4gIC8vIHN0YXJ0IHdpdGggYSByb3V0ZSBvYmplY3QgdGhhdCBzdGFuZHMgZm9yIFwibm93aGVyZVwiXG4gIHRoaXMuY3VycmVudCA9IFNUQVJUO1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gIHRoaXMucmVhZHlDYnMgPSBbXTtcbiAgdGhpcy5yZWFkeUVycm9yQ2JzID0gW107XG4gIHRoaXMuZXJyb3JDYnMgPSBbXTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbiAoY2IpIHtcbiAgdGhpcy5jYiA9IGNiO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XG4gIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgY2IoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlYWR5Q2JzLnB1c2goY2IpO1xuICAgIGlmIChlcnJvckNiKSB7XG4gICAgICB0aGlzLnJlYWR5RXJyb3JDYnMucHVzaChlcnJvckNiKTtcbiAgICB9XG4gIH1cbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yIChlcnJvckNiKSB7XG4gIHRoaXMuZXJyb3JDYnMucHVzaChlcnJvckNiKTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLnRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25UbyAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgcm91dGUgPSB0aGlzLnJvdXRlci5tYXRjaChsb2NhdGlvbiwgdGhpcy5jdXJyZW50KTtcbiAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMkMS51cGRhdGVSb3V0ZShyb3V0ZSk7XG4gICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB0aGlzJDEuZW5zdXJlVVJMKCk7XG5cbiAgICAvLyBmaXJlIHJlYWR5IGNicyBvbmNlXG4gICAgaWYgKCF0aGlzJDEucmVhZHkpIHtcbiAgICAgIHRoaXMkMS5yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzJDEucmVhZHlDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2Iocm91dGUpOyB9KTtcbiAgICB9XG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAob25BYm9ydCkge1xuICAgICAgb25BYm9ydChlcnIpO1xuICAgIH1cbiAgICBpZiAoZXJyICYmICF0aGlzJDEucmVhZHkpIHtcbiAgICAgIHRoaXMkMS5yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzJDEucmVhZHlFcnJvckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYihlcnIpOyB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUuY29uZmlybVRyYW5zaXRpb24gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvbiAocm91dGUsIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChpc0Vycm9yKGVycikpIHtcbiAgICAgIGlmICh0aGlzJDEuZXJyb3JDYnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMkMS5lcnJvckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYihlcnIpOyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oZmFsc2UsICd1bmNhdWdodCBlcnJvciBkdXJpbmcgcm91dGUgbmF2aWdhdGlvbjonKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBvbkFib3J0ICYmIG9uQWJvcnQoZXJyKTtcbiAgfTtcbiAgaWYgKFxuICAgIGlzU2FtZVJvdXRlKHJvdXRlLCBjdXJyZW50KSAmJlxuICAgIC8vIGluIHRoZSBjYXNlIHRoZSByb3V0ZSBtYXAgaGFzIGJlZW4gZHluYW1pY2FsbHkgYXBwZW5kZWQgdG9cbiAgICByb3V0ZS5tYXRjaGVkLmxlbmd0aCA9PT0gY3VycmVudC5tYXRjaGVkLmxlbmd0aFxuICApIHtcbiAgICB0aGlzLmVuc3VyZVVSTCgpO1xuICAgIHJldHVybiBhYm9ydCgpXG4gIH1cblxuICB2YXIgcmVmID0gcmVzb2x2ZVF1ZXVlKHRoaXMuY3VycmVudC5tYXRjaGVkLCByb3V0ZS5tYXRjaGVkKTtcbiAgICB2YXIgdXBkYXRlZCA9IHJlZi51cGRhdGVkO1xuICAgIHZhciBkZWFjdGl2YXRlZCA9IHJlZi5kZWFjdGl2YXRlZDtcbiAgICB2YXIgYWN0aXZhdGVkID0gcmVmLmFjdGl2YXRlZDtcblxuICB2YXIgcXVldWUgPSBbXS5jb25jYXQoXG4gICAgLy8gaW4tY29tcG9uZW50IGxlYXZlIGd1YXJkc1xuICAgIGV4dHJhY3RMZWF2ZUd1YXJkcyhkZWFjdGl2YXRlZCksXG4gICAgLy8gZ2xvYmFsIGJlZm9yZSBob29rc1xuICAgIHRoaXMucm91dGVyLmJlZm9yZUhvb2tzLFxuICAgIC8vIGluLWNvbXBvbmVudCB1cGRhdGUgaG9va3NcbiAgICBleHRyYWN0VXBkYXRlSG9va3ModXBkYXRlZCksXG4gICAgLy8gaW4tY29uZmlnIGVudGVyIGd1YXJkc1xuICAgIGFjdGl2YXRlZC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uYmVmb3JlRW50ZXI7IH0pLFxuICAgIC8vIGFzeW5jIGNvbXBvbmVudHNcbiAgICByZXNvbHZlQXN5bmNDb21wb25lbnRzKGFjdGl2YXRlZClcbiAgKTtcblxuICB0aGlzLnBlbmRpbmcgPSByb3V0ZTtcbiAgdmFyIGl0ZXJhdG9yID0gZnVuY3Rpb24gKGhvb2ssIG5leHQpIHtcbiAgICBpZiAodGhpcyQxLnBlbmRpbmcgIT09IHJvdXRlKSB7XG4gICAgICByZXR1cm4gYWJvcnQoKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgaG9vayhyb3V0ZSwgY3VycmVudCwgZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgIGlmICh0byA9PT0gZmFsc2UgfHwgaXNFcnJvcih0bykpIHtcbiAgICAgICAgICAvLyBuZXh0KGZhbHNlKSAtPiBhYm9ydCBuYXZpZ2F0aW9uLCBlbnN1cmUgY3VycmVudCBVUkxcbiAgICAgICAgICB0aGlzJDEuZW5zdXJlVVJMKHRydWUpO1xuICAgICAgICAgIGFib3J0KHRvKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0eXBlb2YgdG8gPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgKHR5cGVvZiB0byA9PT0gJ29iamVjdCcgJiYgKFxuICAgICAgICAgICAgdHlwZW9mIHRvLnBhdGggPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB0eXBlb2YgdG8ubmFtZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICApKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBuZXh0KCcvJykgb3IgbmV4dCh7IHBhdGg6ICcvJyB9KSAtPiByZWRpcmVjdFxuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gJ29iamVjdCcgJiYgdG8ucmVwbGFjZSkge1xuICAgICAgICAgICAgdGhpcyQxLnJlcGxhY2UodG8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzJDEucHVzaCh0byk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbmZpcm0gdHJhbnNpdGlvbiBhbmQgcGFzcyBvbiB0aGUgdmFsdWVcbiAgICAgICAgICBuZXh0KHRvKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYWJvcnQoZSk7XG4gICAgfVxuICB9O1xuXG4gIHJ1blF1ZXVlKHF1ZXVlLCBpdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3N0RW50ZXJDYnMgPSBbXTtcbiAgICB2YXIgaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5jdXJyZW50ID09PSByb3V0ZTsgfTtcbiAgICAvLyB3YWl0IHVudGlsIGFzeW5jIGNvbXBvbmVudHMgYXJlIHJlc29sdmVkIGJlZm9yZVxuICAgIC8vIGV4dHJhY3RpbmcgaW4tY29tcG9uZW50IGVudGVyIGd1YXJkc1xuICAgIHZhciBlbnRlckd1YXJkcyA9IGV4dHJhY3RFbnRlckd1YXJkcyhhY3RpdmF0ZWQsIHBvc3RFbnRlckNicywgaXNWYWxpZCk7XG4gICAgdmFyIHF1ZXVlID0gZW50ZXJHdWFyZHMuY29uY2F0KHRoaXMkMS5yb3V0ZXIucmVzb2x2ZUhvb2tzKTtcbiAgICBydW5RdWV1ZShxdWV1ZSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzJDEucGVuZGluZyAhPT0gcm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGFib3J0KClcbiAgICAgIH1cbiAgICAgIHRoaXMkMS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIG9uQ29tcGxldGUocm91dGUpO1xuICAgICAgaWYgKHRoaXMkMS5yb3V0ZXIuYXBwKSB7XG4gICAgICAgIHRoaXMkMS5yb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcG9zdEVudGVyQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS51cGRhdGVSb3V0ZSA9IGZ1bmN0aW9uIHVwZGF0ZVJvdXRlIChyb3V0ZSkge1xuICB2YXIgcHJldiA9IHRoaXMuY3VycmVudDtcbiAgdGhpcy5jdXJyZW50ID0gcm91dGU7XG4gIHRoaXMuY2IgJiYgdGhpcy5jYihyb3V0ZSk7XG4gIHRoaXMucm91dGVyLmFmdGVySG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgIGhvb2sgJiYgaG9vayhyb3V0ZSwgcHJldik7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplQmFzZSAoYmFzZSkge1xuICBpZiAoIWJhc2UpIHtcbiAgICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgICAvLyByZXNwZWN0IDxiYXNlPiB0YWdcbiAgICAgIHZhciBiYXNlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgICBiYXNlID0gKGJhc2VFbCAmJiBiYXNlRWwuZ2V0QXR0cmlidXRlKCdocmVmJykpIHx8ICcvJztcbiAgICAgIC8vIHN0cmlwIGZ1bGwgVVJMIG9yaWdpblxuICAgICAgYmFzZSA9IGJhc2UucmVwbGFjZSgvXmh0dHBzPzpcXC9cXC9bXlxcL10rLywgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gJy8nO1xuICAgIH1cbiAgfVxuICAvLyBtYWtlIHN1cmUgdGhlcmUncyB0aGUgc3RhcnRpbmcgc2xhc2hcbiAgaWYgKGJhc2UuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBiYXNlID0gJy8nICsgYmFzZTtcbiAgfVxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2hcbiAgcmV0dXJuIGJhc2UucmVwbGFjZSgvXFwvJC8sICcnKVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUXVldWUgKFxuICBjdXJyZW50LFxuICBuZXh0XG4pIHtcbiAgdmFyIGk7XG4gIHZhciBtYXggPSBNYXRoLm1heChjdXJyZW50Lmxlbmd0aCwgbmV4dC5sZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBpZiAoY3VycmVudFtpXSAhPT0gbmV4dFtpXSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB1cGRhdGVkOiBuZXh0LnNsaWNlKDAsIGkpLFxuICAgIGFjdGl2YXRlZDogbmV4dC5zbGljZShpKSxcbiAgICBkZWFjdGl2YXRlZDogY3VycmVudC5zbGljZShpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RHdWFyZHMgKFxuICByZWNvcmRzLFxuICBuYW1lLFxuICBiaW5kLFxuICByZXZlcnNlXG4pIHtcbiAgdmFyIGd1YXJkcyA9IGZsYXRNYXBDb21wb25lbnRzKHJlY29yZHMsIGZ1bmN0aW9uIChkZWYsIGluc3RhbmNlLCBtYXRjaCwga2V5KSB7XG4gICAgdmFyIGd1YXJkID0gZXh0cmFjdEd1YXJkKGRlZiwgbmFtZSk7XG4gICAgaWYgKGd1YXJkKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShndWFyZClcbiAgICAgICAgPyBndWFyZC5tYXAoZnVuY3Rpb24gKGd1YXJkKSB7IHJldHVybiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSk7IH0pXG4gICAgICAgIDogYmluZChndWFyZCwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZsYXR0ZW4ocmV2ZXJzZSA/IGd1YXJkcy5yZXZlcnNlKCkgOiBndWFyZHMpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RHdWFyZCAoXG4gIGRlZixcbiAga2V5XG4pIHtcbiAgaWYgKHR5cGVvZiBkZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBleHRlbmQgbm93IHNvIHRoYXQgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZC5cbiAgICBkZWYgPSBfVnVlLmV4dGVuZChkZWYpO1xuICB9XG4gIHJldHVybiBkZWYub3B0aW9uc1trZXldXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RMZWF2ZUd1YXJkcyAoZGVhY3RpdmF0ZWQpIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHMoZGVhY3RpdmF0ZWQsICdiZWZvcmVSb3V0ZUxlYXZlJywgYmluZEd1YXJkLCB0cnVlKVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VXBkYXRlSG9va3MgKHVwZGF0ZWQpIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHModXBkYXRlZCwgJ2JlZm9yZVJvdXRlVXBkYXRlJywgYmluZEd1YXJkKVxufVxuXG5mdW5jdGlvbiBiaW5kR3VhcmQgKGd1YXJkLCBpbnN0YW5jZSkge1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRSb3V0ZUd1YXJkICgpIHtcbiAgICAgIHJldHVybiBndWFyZC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0RW50ZXJHdWFyZHMgKFxuICBhY3RpdmF0ZWQsXG4gIGNicyxcbiAgaXNWYWxpZFxuKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKGFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlRW50ZXInLCBmdW5jdGlvbiAoZ3VhcmQsIF8sIG1hdGNoLCBrZXkpIHtcbiAgICByZXR1cm4gYmluZEVudGVyR3VhcmQoZ3VhcmQsIG1hdGNoLCBrZXksIGNicywgaXNWYWxpZClcbiAgfSlcbn1cblxuZnVuY3Rpb24gYmluZEVudGVyR3VhcmQgKFxuICBndWFyZCxcbiAgbWF0Y2gsXG4gIGtleSxcbiAgY2JzLFxuICBpc1ZhbGlkXG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJvdXRlRW50ZXJHdWFyZCAodG8sIGZyb20sIG5leHQpIHtcbiAgICByZXR1cm4gZ3VhcmQodG8sIGZyb20sIGZ1bmN0aW9uIChjYikge1xuICAgICAgbmV4dChjYik7XG4gICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNicy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAjNzUwXG4gICAgICAgICAgLy8gaWYgYSByb3V0ZXItdmlldyBpcyB3cmFwcGVkIHdpdGggYW4gb3V0LWluIHRyYW5zaXRpb24sXG4gICAgICAgICAgLy8gdGhlIGluc3RhbmNlIG1heSBub3QgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgYXQgdGhpcyB0aW1lLlxuICAgICAgICAgIC8vIHdlIHdpbGwgbmVlZCB0byBwb2xsIGZvciByZWdpc3RyYXRpb24gdW50aWwgY3VycmVudCByb3V0ZVxuICAgICAgICAgIC8vIGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgICAgICBwb2xsKGNiLCBtYXRjaC5pbnN0YW5jZXMsIGtleSwgaXNWYWxpZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gcG9sbCAoXG4gIGNiLCAvLyBzb21laG93IGZsb3cgY2Fubm90IGluZmVyIHRoaXMgaXMgYSBmdW5jdGlvblxuICBpbnN0YW5jZXMsXG4gIGtleSxcbiAgaXNWYWxpZFxuKSB7XG4gIGlmIChcbiAgICBpbnN0YW5jZXNba2V5XSAmJlxuICAgICFpbnN0YW5jZXNba2V5XS5faXNCZWluZ0Rlc3Ryb3llZCAvLyBkbyBub3QgcmV1c2UgYmVpbmcgZGVzdHJveWVkIGluc3RhbmNlXG4gICkge1xuICAgIGNiKGluc3RhbmNlc1trZXldKTtcbiAgfSBlbHNlIGlmIChpc1ZhbGlkKCkpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHBvbGwoY2IsIGluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcbiAgICB9LCAxNik7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBIVE1MNUhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gSFRNTDVIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuXG4gICAgdmFyIGV4cGVjdFNjcm9sbCA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuICAgIHZhciBzdXBwb3J0c1Njcm9sbCA9IHN1cHBvcnRzUHVzaFN0YXRlICYmIGV4cGVjdFNjcm9sbDtcblxuICAgIGlmIChzdXBwb3J0c1Njcm9sbCkge1xuICAgICAgc2V0dXBTY3JvbGwoKTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdExvY2F0aW9uID0gZ2V0TG9jYXRpb24odGhpcy5iYXNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzJDEuY3VycmVudDtcblxuICAgICAgLy8gQXZvaWRpbmcgZmlyc3QgYHBvcHN0YXRlYCBldmVudCBkaXNwYXRjaGVkIGluIHNvbWUgYnJvd3NlcnMgYnV0IGZpcnN0XG4gICAgICAvLyBoaXN0b3J5IHJvdXRlIG5vdCB1cGRhdGVkIHNpbmNlIGFzeW5jIGd1YXJkIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICB2YXIgbG9jYXRpb24gPSBnZXRMb2NhdGlvbih0aGlzJDEuYmFzZSk7XG4gICAgICBpZiAodGhpcyQxLmN1cnJlbnQgPT09IFNUQVJUICYmIGxvY2F0aW9uID09PSBpbml0TG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICBpZiAoc3VwcG9ydHNTY3JvbGwpIHtcbiAgICAgICAgICBoYW5kbGVTY3JvbGwocm91dGVyLCByb3V0ZSwgY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSFRNTDVIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIVE1MNUhpc3Rvcnk7XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBwdXNoU3RhdGUoY2xlYW5QYXRoKHRoaXMkMS5iYXNlICsgcm91dGUuZnVsbFBhdGgpKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZVN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIGlmIChnZXRMb2NhdGlvbih0aGlzLmJhc2UpICE9PSB0aGlzLmN1cnJlbnQuZnVsbFBhdGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gY2xlYW5QYXRoKHRoaXMuYmFzZSArIHRoaXMuY3VycmVudC5mdWxsUGF0aCk7XG4gICAgICBwdXNoID8gcHVzaFN0YXRlKGN1cnJlbnQpIDogcmVwbGFjZVN0YXRlKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldExvY2F0aW9uKHRoaXMuYmFzZSlcbiAgfTtcblxuICByZXR1cm4gSFRNTDVIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGdldExvY2F0aW9uIChiYXNlKSB7XG4gIHZhciBwYXRoID0gZGVjb2RlVVJJKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gIGlmIChiYXNlICYmIHBhdGguaW5kZXhPZihiYXNlKSA9PT0gMCkge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKGJhc2UubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyB3aW5kb3cubG9jYXRpb24uaGFzaFxufVxuXG4vKiAgKi9cblxudmFyIEhhc2hIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEhhc2hIaXN0b3J5IChyb3V0ZXIsIGJhc2UsIGZhbGxiYWNrKSB7XG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG4gICAgLy8gY2hlY2sgaGlzdG9yeSBmYWxsYmFjayBkZWVwbGlua2luZ1xuICAgIGlmIChmYWxsYmFjayAmJiBjaGVja0ZhbGxiYWNrKHRoaXMuYmFzZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbnN1cmVTbGFzaCgpO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSGFzaEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIYXNoSGlzdG9yeTtcblxuICAvLyB0aGlzIGlzIGRlbGF5ZWQgdW50aWwgdGhlIGFwcCBtb3VudHNcbiAgLy8gdG8gYXZvaWQgdGhlIGhhc2hjaGFuZ2UgbGlzdGVuZXIgYmVpbmcgZmlyZWQgdG9vIGVhcmx5XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5zZXR1cExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldHVwTGlzdGVuZXJzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByb3V0ZXIgPSB0aGlzLnJvdXRlcjtcbiAgICB2YXIgZXhwZWN0U2Nyb2xsID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG4gICAgdmFyIHN1cHBvcnRzU2Nyb2xsID0gc3VwcG9ydHNQdXNoU3RhdGUgJiYgZXhwZWN0U2Nyb2xsO1xuXG4gICAgaWYgKHN1cHBvcnRzU2Nyb2xsKSB7XG4gICAgICBzZXR1cFNjcm9sbCgpO1xuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKHN1cHBvcnRzUHVzaFN0YXRlID8gJ3BvcHN0YXRlJyA6ICdoYXNoY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzJDEuY3VycmVudDtcbiAgICAgIGlmICghZW5zdXJlU2xhc2goKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8oZ2V0SGFzaCgpLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzU2Nyb2xsKSB7XG4gICAgICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBjdXJyZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1cHBvcnRzUHVzaFN0YXRlKSB7XG4gICAgICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcHVzaEhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHJlcGxhY2VIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50LmZ1bGxQYXRoO1xuICAgIGlmIChnZXRIYXNoKCkgIT09IGN1cnJlbnQpIHtcbiAgICAgIHB1c2ggPyBwdXNoSGFzaChjdXJyZW50KSA6IHJlcGxhY2VIYXNoKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0SGFzaCgpXG4gIH07XG5cbiAgcmV0dXJuIEhhc2hIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGNoZWNrRmFsbGJhY2sgKGJhc2UpIHtcbiAgdmFyIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oYmFzZSk7XG4gIGlmICghL15cXC8jLy50ZXN0KGxvY2F0aW9uKSkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKFxuICAgICAgY2xlYW5QYXRoKGJhc2UgKyAnLyMnICsgbG9jYXRpb24pXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVNsYXNoICgpIHtcbiAgdmFyIHBhdGggPSBnZXRIYXNoKCk7XG4gIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXBsYWNlSGFzaCgnLycgKyBwYXRoKTtcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGdldEhhc2ggKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBpbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICByZXR1cm4gaW5kZXggPT09IC0xID8gJycgOiBkZWNvZGVVUkkoaHJlZi5zbGljZShpbmRleCArIDEpKVxufVxuXG5mdW5jdGlvbiBnZXRVcmwgKHBhdGgpIHtcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGkgPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgdmFyIGJhc2UgPSBpID49IDAgPyBocmVmLnNsaWNlKDAsIGkpIDogaHJlZjtcbiAgcmV0dXJuIChiYXNlICsgXCIjXCIgKyBwYXRoKVxufVxuXG5mdW5jdGlvbiBwdXNoSGFzaCAocGF0aCkge1xuICBpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcbiAgICBwdXNoU3RhdGUoZ2V0VXJsKHBhdGgpKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZUhhc2ggKHBhdGgpIHtcbiAgaWYgKHN1cHBvcnRzUHVzaFN0YXRlKSB7XG4gICAgcmVwbGFjZVN0YXRlKGdldFVybChwYXRoKSk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoZ2V0VXJsKHBhdGgpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIEFic3RyYWN0SGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBBYnN0cmFjdEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLmluZGV4ID0gLTE7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBBYnN0cmFjdEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFic3RyYWN0SGlzdG9yeTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCArIDEpLmNvbmNhdChyb3V0ZSk7XG4gICAgICB0aGlzJDEuaW5kZXgrKztcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXgpLmNvbmNhdChyb3V0ZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHRhcmdldEluZGV4ID0gdGhpcy5pbmRleCArIG47XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciByb3V0ZSA9IHRoaXMuc3RhY2tbdGFyZ2V0SW5kZXhdO1xuICAgIHRoaXMuY29uZmlybVRyYW5zaXRpb24ocm91dGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5pbmRleCA9IHRhcmdldEluZGV4O1xuICAgICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICB9KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGN1cnJlbnQgPyBjdXJyZW50LmZ1bGxQYXRoIDogJy8nXG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKCkge1xuICAgIC8vIG5vb3BcbiAgfTtcblxuICByZXR1cm4gQWJzdHJhY3RIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbi8qICAqL1xuXG5cblxudmFyIFZ1ZVJvdXRlciA9IGZ1bmN0aW9uIFZ1ZVJvdXRlciAob3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICB0aGlzLmFwcCA9IG51bGw7XG4gIHRoaXMuYXBwcyA9IFtdO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmJlZm9yZUhvb2tzID0gW107XG4gIHRoaXMucmVzb2x2ZUhvb2tzID0gW107XG4gIHRoaXMuYWZ0ZXJIb29rcyA9IFtdO1xuICB0aGlzLm1hdGNoZXIgPSBjcmVhdGVNYXRjaGVyKG9wdGlvbnMucm91dGVzIHx8IFtdLCB0aGlzKTtcblxuICB2YXIgbW9kZSA9IG9wdGlvbnMubW9kZSB8fCAnaGFzaCc7XG4gIHRoaXMuZmFsbGJhY2sgPSBtb2RlID09PSAnaGlzdG9yeScgJiYgIXN1cHBvcnRzUHVzaFN0YXRlICYmIG9wdGlvbnMuZmFsbGJhY2sgIT09IGZhbHNlO1xuICBpZiAodGhpcy5mYWxsYmFjaykge1xuICAgIG1vZGUgPSAnaGFzaCc7XG4gIH1cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICBtb2RlID0gJ2Fic3RyYWN0JztcbiAgfVxuICB0aGlzLm1vZGUgPSBtb2RlO1xuXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgJ2hpc3RvcnknOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhUTUw1SGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIYXNoSGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UsIHRoaXMuZmFsbGJhY2spO1xuICAgICAgYnJlYWtcbiAgICBjYXNlICdhYnN0cmFjdCc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgQWJzdHJhY3RIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIChcImludmFsaWQgbW9kZTogXCIgKyBtb2RlKSk7XG4gICAgICB9XG4gIH1cbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGN1cnJlbnRSb3V0ZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2ggKFxuICByYXcsXG4gIGN1cnJlbnQsXG4gIHJlZGlyZWN0ZWRGcm9tXG4pIHtcbiAgcmV0dXJuIHRoaXMubWF0Y2hlci5tYXRjaChyYXcsIGN1cnJlbnQsIHJlZGlyZWN0ZWRGcm9tKVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmN1cnJlbnRSb3V0ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhpc3RvcnkgJiYgdGhpcy5oaXN0b3J5LmN1cnJlbnRcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKGFwcCAvKiBWdWUgY29tcG9uZW50IGluc3RhbmNlICovKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhc3NlcnQoXG4gICAgaW5zdGFsbC5pbnN0YWxsZWQsXG4gICAgXCJub3QgaW5zdGFsbGVkLiBNYWtlIHN1cmUgdG8gY2FsbCBgVnVlLnVzZShWdWVSb3V0ZXIpYCBcIiArXG4gICAgXCJiZWZvcmUgY3JlYXRpbmcgcm9vdCBpbnN0YW5jZS5cIlxuICApO1xuXG4gIHRoaXMuYXBwcy5wdXNoKGFwcCk7XG5cbiAgLy8gbWFpbiBhcHAgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgaWYgKHRoaXMuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLmFwcCA9IGFwcDtcblxuICB2YXIgaGlzdG9yeSA9IHRoaXMuaGlzdG9yeTtcblxuICBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhUTUw1SGlzdG9yeSkge1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICB9IGVsc2UgaWYgKGhpc3RvcnkgaW5zdGFuY2VvZiBIYXNoSGlzdG9yeSkge1xuICAgIHZhciBzZXR1cEhhc2hMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGhpc3Rvcnkuc2V0dXBMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKFxuICAgICAgaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSxcbiAgICAgIHNldHVwSGFzaExpc3RlbmVyLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXJcbiAgICApO1xuICB9XG5cbiAgaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgdGhpcyQxLmFwcHMuZm9yRWFjaChmdW5jdGlvbiAoYXBwKSB7XG4gICAgICBhcHAuX3JvdXRlID0gcm91dGU7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24gYmVmb3JlRWFjaCAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLmJlZm9yZUhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmVmb3JlUmVzb2x2ZSA9IGZ1bmN0aW9uIGJlZm9yZVJlc29sdmUgKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5yZXNvbHZlSG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbiBhZnRlckVhY2ggKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5hZnRlckhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XG4gIHRoaXMuaGlzdG9yeS5vblJlYWR5KGNiLCBlcnJvckNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcbiAgdGhpcy5oaXN0b3J5Lm9uRXJyb3IoZXJyb3JDYik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucHVzaChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgdGhpcy5oaXN0b3J5LmdvKG4pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gYmFjayAoKSB7XG4gIHRoaXMuZ28oLTEpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gZm9yd2FyZCAoKSB7XG4gIHRoaXMuZ28oMSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdldE1hdGNoZWRDb21wb25lbnRzID0gZnVuY3Rpb24gZ2V0TWF0Y2hlZENvbXBvbmVudHMgKHRvKSB7XG4gIHZhciByb3V0ZSA9IHRvXG4gICAgPyB0by5tYXRjaGVkXG4gICAgICA/IHRvXG4gICAgICA6IHRoaXMucmVzb2x2ZSh0bykucm91dGVcbiAgICA6IHRoaXMuY3VycmVudFJvdXRlO1xuICBpZiAoIXJvdXRlKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgcm91dGUubWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG0uY29tcG9uZW50c1trZXldXG4gICAgfSlcbiAgfSkpXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChcbiAgdG8sXG4gIGN1cnJlbnQsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKFxuICAgIHRvLFxuICAgIGN1cnJlbnQgfHwgdGhpcy5oaXN0b3J5LmN1cnJlbnQsXG4gICAgYXBwZW5kLFxuICAgIHRoaXNcbiAgKTtcbiAgdmFyIHJvdXRlID0gdGhpcy5tYXRjaChsb2NhdGlvbiwgY3VycmVudCk7XG4gIHZhciBmdWxsUGF0aCA9IHJvdXRlLnJlZGlyZWN0ZWRGcm9tIHx8IHJvdXRlLmZ1bGxQYXRoO1xuICB2YXIgYmFzZSA9IHRoaXMuaGlzdG9yeS5iYXNlO1xuICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYoYmFzZSwgZnVsbFBhdGgsIHRoaXMubW9kZSk7XG4gIHJldHVybiB7XG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIHJvdXRlOiByb3V0ZSxcbiAgICBocmVmOiBocmVmLFxuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgbm9ybWFsaXplZFRvOiBsb2NhdGlvbixcbiAgICByZXNvbHZlZDogcm91dGVcbiAgfVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZGRSb3V0ZXMgPSBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICB0aGlzLm1hdGNoZXIuYWRkUm91dGVzKHJvdXRlcyk7XG4gIGlmICh0aGlzLmhpc3RvcnkuY3VycmVudCAhPT0gU1RBUlQpIHtcbiAgICB0aGlzLmhpc3RvcnkudHJhbnNpdGlvblRvKHRoaXMuaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWdWVSb3V0ZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJIb29rIChsaXN0LCBmbikge1xuICBsaXN0LnB1c2goZm4pO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gbGlzdC5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7IGxpc3Quc3BsaWNlKGksIDEpOyB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSHJlZiAoYmFzZSwgZnVsbFBhdGgsIG1vZGUpIHtcbiAgdmFyIHBhdGggPSBtb2RlID09PSAnaGFzaCcgPyAnIycgKyBmdWxsUGF0aCA6IGZ1bGxQYXRoO1xuICByZXR1cm4gYmFzZSA/IGNsZWFuUGF0aChiYXNlICsgJy8nICsgcGF0aCkgOiBwYXRoXG59XG5cblZ1ZVJvdXRlci5pbnN0YWxsID0gaW5zdGFsbDtcblZ1ZVJvdXRlci52ZXJzaW9uID0gJzMuMC4yJztcblxuaWYgKGluQnJvd3NlciAmJiB3aW5kb3cuVnVlKSB7XG4gIHdpbmRvdy5WdWUudXNlKFZ1ZVJvdXRlcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZVJvdXRlcjtcbiIsImRlZmluZSggW1xuXHRcIi4vY2xhc3MydHlwZVwiXG5dLCBmdW5jdGlvbiggY2xhc3MydHlwZSApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0cmV0dXJuIGNsYXNzMnR5cGUudG9TdHJpbmc7XG59ICk7XG4iLCJkZWZpbmUoIFtdLCBmdW5jdGlvbigpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBhbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG5cbnJldHVybiBjYW1lbENhc2U7XG5cbn0gKTtcbiIsImRlZmluZSggZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi9jb3JlXCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnkgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5yZXR1cm4galF1ZXJ5LnBhcnNlWE1MO1xuXG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi9jb3JlXCIsXG5cdFwiLi4vdmFyL2RvY3VtZW50XCIsXG5cdFwiLi4vZGF0YS92YXIvZGF0YVByaXZcIixcblx0XCIuLi9kYXRhL3Zhci9hY2NlcHREYXRhXCIsXG5cdFwiLi4vdmFyL2hhc093blwiLFxuXHRcIi4uL3Zhci9pc0Z1bmN0aW9uXCIsXG5cdFwiLi4vdmFyL2lzV2luZG93XCIsXG5cdFwiLi4vZXZlbnRcIlxuXSwgZnVuY3Rpb24oIGpRdWVyeSwgZG9jdW1lbnQsIGRhdGFQcml2LCBhY2NlcHREYXRhLCBoYXNPd24sIGlzRnVuY3Rpb24sIGlzV2luZG93ICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi9jb3JlXCIsXG5cdFwiLi9zZWxlY3RvclwiLFxuXHRcIi4vdHJhdmVyc2luZ1wiLFxuXHRcIi4vY2FsbGJhY2tzXCIsXG5cdFwiLi9kZWZlcnJlZFwiLFxuXHRcIi4vZGVmZXJyZWQvZXhjZXB0aW9uSG9va1wiLFxuXHRcIi4vY29yZS9yZWFkeVwiLFxuXHRcIi4vZGF0YVwiLFxuXHRcIi4vcXVldWVcIixcblx0XCIuL3F1ZXVlL2RlbGF5XCIsXG5cdFwiLi9hdHRyaWJ1dGVzXCIsXG5cdFwiLi9ldmVudFwiLFxuXHRcIi4vZXZlbnQvZm9jdXNpblwiLFxuXHRcIi4vbWFuaXB1bGF0aW9uXCIsXG5cdFwiLi9tYW5pcHVsYXRpb24vX2V2YWxVcmxcIixcblx0XCIuL3dyYXBcIixcblx0XCIuL2Nzc1wiLFxuXHRcIi4vY3NzL2hpZGRlblZpc2libGVTZWxlY3RvcnNcIixcblx0XCIuL3NlcmlhbGl6ZVwiLFxuXHRcIi4vYWpheFwiLFxuXHRcIi4vYWpheC94aHJcIixcblx0XCIuL2FqYXgvc2NyaXB0XCIsXG5cdFwiLi9hamF4L2pzb25wXCIsXG5cdFwiLi9hamF4L2xvYWRcIixcblx0XCIuL2V2ZW50L2FqYXhcIixcblx0XCIuL2VmZmVjdHNcIixcblx0XCIuL2VmZmVjdHMvYW5pbWF0ZWRTZWxlY3RvclwiLFxuXHRcIi4vb2Zmc2V0XCIsXG5cdFwiLi9kaW1lbnNpb25zXCIsXG5cdFwiLi9kZXByZWNhdGVkXCIsXG5cdFwiLi9leHBvcnRzL2FtZFwiLFxuXHRcIi4vZXhwb3J0cy9nbG9iYWxcIlxuXSwgZnVuY3Rpb24oIGpRdWVyeSApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnJldHVybiBqUXVlcnk7XG5cbn0gKTtcbiIsImRlZmluZSggW1xuXHRcIi4vY29yZVwiLFxuXHRcIi4vY29yZS9hY2Nlc3NcIixcblx0XCIuL3Zhci9pc1dpbmRvd1wiLFxuXHRcIi4vY3NzXCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnksIGFjY2VzcywgaXNXaW5kb3cgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iLCIvKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuIiwiLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cbmRlZmluZSggW1xuXHRcIi4vdmFyL2FyclwiLFxuXHRcIi4vdmFyL2RvY3VtZW50XCIsXG5cdFwiLi92YXIvZ2V0UHJvdG9cIixcblx0XCIuL3Zhci9zbGljZVwiLFxuXHRcIi4vdmFyL2NvbmNhdFwiLFxuXHRcIi4vdmFyL3B1c2hcIixcblx0XCIuL3Zhci9pbmRleE9mXCIsXG5cdFwiLi92YXIvY2xhc3MydHlwZVwiLFxuXHRcIi4vdmFyL3RvU3RyaW5nXCIsXG5cdFwiLi92YXIvaGFzT3duXCIsXG5cdFwiLi92YXIvZm5Ub1N0cmluZ1wiLFxuXHRcIi4vdmFyL09iamVjdEZ1bmN0aW9uU3RyaW5nXCIsXG5cdFwiLi92YXIvc3VwcG9ydFwiLFxuXHRcIi4vdmFyL2lzRnVuY3Rpb25cIixcblx0XCIuL3Zhci9pc1dpbmRvd1wiLFxuXHRcIi4vY29yZS9ET01FdmFsXCIsXG5cdFwiLi9jb3JlL3RvVHlwZVwiXG5dLCBmdW5jdGlvbiggYXJyLCBkb2N1bWVudCwgZ2V0UHJvdG8sIHNsaWNlLCBjb25jYXQsIHB1c2gsIGluZGV4T2YsXG5cdGNsYXNzMnR5cGUsIHRvU3RyaW5nLCBoYXNPd24sIGZuVG9TdHJpbmcsIE9iamVjdEZ1bmN0aW9uU3RyaW5nLFxuXHRzdXBwb3J0LCBpc0Z1bmN0aW9uLCBpc1dpbmRvdywgRE9NRXZhbCwgdG9UeXBlICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyXG5cdHZlcnNpb24gPSBcIjMuMy4xXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzYxMjVcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHRET01FdmFsKCBjb2RlICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiIsImRlZmluZSggW1xuXHRcIi4vY29yZVwiLFxuXHRcIi4vYXR0cmlidXRlcy9hdHRyXCIsXG5cdFwiLi9hdHRyaWJ1dGVzL3Byb3BcIixcblx0XCIuL2F0dHJpYnV0ZXMvY2xhc3Nlc1wiLFxuXHRcIi4vYXR0cmlidXRlcy92YWxcIlxuXSwgZnVuY3Rpb24oIGpRdWVyeSApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi9jb3JlXCIsXG5cdFwiLi4vZGVmZXJyZWRcIlxuXSwgZnVuY3Rpb24oIGpRdWVyeSApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cbn0gKTtcbiIsIi8qIVxuICogVnVlLmpzIHYyLjYuMTBcbiAqIChjKSAyMDE0LTIwMTkgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vLyBUaGVzZSBoZWxwZXJzIHByb2R1Y2UgYmV0dGVyIFZNIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmcuXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlLlxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUsIGUuZy4sIFtvYmplY3QgT2JqZWN0XS5cbiAqL1xudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICByZXR1cm4gKFxuICAgIGlzRGVmKHZhbCkgJiZcbiAgICB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsLmNhdGNoID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiBBcnJheS5pc0FycmF5KHZhbCkgfHwgKGlzUGxhaW5PYmplY3QodmFsKSAmJiB2YWwudG9TdHJpbmcgPT09IF90b1N0cmluZylcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCxcbiAqIGUuZy4sIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICogc2luY2UgbmF0aXZlIGJpbmQgaXMgbm93IHBlcmZvcm1hbnQgZW5vdWdoIGluIG1vc3QgYnJvd3NlcnMuXG4gKiBCdXQgcmVtb3ZpbmcgaXQgd291bGQgbWVhbiBicmVha2luZyBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluXG4gKiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cblxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbmZ1bmN0aW9uIG5hdGl2ZUJpbmQgKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZuLmJpbmQoY3R4KVxufVxuXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gID8gbmF0aXZlQmluZFxuICA6IHBvbHlmaWxsQmluZDtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LykuXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogUmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0cmluZyBjb250YWluaW5nIHN0YXRpYyBrZXlzIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICB9LCBbXSkuam9pbignLCcpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgbG9vc2VseSBlcXVhbCB2YWx1ZSBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBhcnJheSAoaWYgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QsIHRoZSBhcnJheSBtdXN0XG4gKiBjb250YWluIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBzaGFwZSksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICovXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCcsXG4gICdlcnJvckNhcHR1cmVkJyxcbiAgJ3NlcnZlclByZWZldGNoJ1xuXTtcblxuLyogICovXG5cblxuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHVwZGF0ZXMgYXN5bmNocm9ub3VzbHkuIEludGVuZGVkIHRvIGJlIHVzZWQgYnkgVnVlIFRlc3QgVXRpbHNcbiAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cbiAgICovXG4gIGFzeW5jOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pO1xuXG4vKiAgKi9cblxuLyoqXG4gKiB1bmljb2RlIGxldHRlcnMgdXNlZCBmb3IgcGFyc2luZyBodG1sIHRhZ3MsIGNvbXBvbmVudCBuYW1lcyBhbmQgcHJvcGVydHkgcGF0aHMuXG4gKiB1c2luZyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUzL3NlbWFudGljcy1zY3JpcHRpbmcuaHRtbCNwb3RlbnRpYWxjdXN0b21lbGVtZW50bmFtZVxuICogc2tpcHBpbmcgXFx1MTAwMDAtXFx1RUZGRkYgZHVlIHRvIGl0IGZyZWV6aW5nIHVwIFBoYW50b21KU1xuICovXG52YXIgdW5pY29kZVJlZ0V4cCA9IC9hLXpBLVpcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZELztcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSBuZXcgUmVnRXhwKChcIlteXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCIuJF9cXFxcZF1cIikpO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbnZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG52YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG52YXIgaXNQaGFudG9tSlMgPSBVQSAmJiAvcGhhbnRvbWpzLy50ZXN0KFVBKTtcbnZhciBpc0ZGID0gVUEgJiYgVUEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKTtcblxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxudmFyIG5hdGl2ZVdhdGNoID0gKHt9KS53YXRjaDtcblxudmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuaWYgKGluQnJvd3Nlcikge1xuICB0cnkge1xuICAgIHZhciBvcHRzID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmICFpbldlZXggJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10gJiYgZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG4vKiAgKi9cblxudmFyIHdhcm4gPSBub29wO1xudmFyIHRpcCA9IG5vb3A7XG52YXIgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IChub29wKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobm9vcCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgPyB2bS5vcHRpb25zXG4gICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICA/IHZtLiRvcHRpb25zIHx8IHZtLmNvbnN0cnVjdG9yLm9wdGlvbnNcbiAgICAgICAgOiB2bTtcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbmZpZy5hc3luYykge1xuICAgIC8vIHN1YnMgYXJlbid0IHNvcnRlZCBpbiBzY2hlZHVsZXIgaWYgbm90IHJ1bm5pbmcgYXN5bmNcbiAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlbSBub3cgdG8gbWFrZSBzdXJlIHRoZXkgZmlyZSBpbiBjb3JyZWN0XG4gICAgLy8gb3JkZXJcbiAgICBzdWJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gVGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gVGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSBvbmx5IG9uZSB3YXRjaGVyXG4vLyBjYW4gYmUgZXZhbHVhdGVkIGF0IGEgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKHRhcmdldCkge1xuICB0YXJnZXRTdGFjay5wdXNoKHRhcmdldCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIHRhcmdldFN0YWNrLnBvcCgpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2tbdGFyZ2V0U3RhY2subGVuZ3RoIC0gMV07XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgLy8gIzc5NzVcbiAgICAvLyBjbG9uZSBjaGlsZHJlbiBhcnJheSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBpbiBjYXNlIG9mIGNsb25pbmdcbiAgICAvLyBhIGNoaWxkLlxuICAgIHZub2RlLmNoaWxkcmVuICYmIHZub2RlLmNoaWxkcmVuLnNsaWNlKCksXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5hc3luY01ldGEgPSB2bm9kZS5hc3luY01ldGE7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcblxudmFyIG1ldGhvZHNUb1BhdGNoID0gW1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXTtcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXG4gKiB1cGRhdGUgY29tcHV0YXRpb24uXG4gKi9cbnZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcblxuZnVuY3Rpb24gdG9nZ2xlT2JzZXJ2aW5nICh2YWx1ZSkge1xuICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XG59XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBpcyBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgaWYgKGhhc1Byb3RvKSB7XG4gICAgICBwcm90b0F1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcHlBdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBzaG91bGRPYnNlcnZlICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuICBpZiAoKCFnZXR0ZXIgfHwgc2V0dGVyKSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFsID0gb2JqW2tleV07XG4gIH1cblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIC8vICM3OTgxOiBmb3IgYWNjZXNzb3IgcHJvcGVydGllcyB3aXRob3V0IHNldHRlclxuICAgICAgaWYgKGdldHRlciAmJiAhc2V0dGVyKSB7IHJldHVybiB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGtleSBpbiB0YXJnZXQgJiYgIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcblxuICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgID8gUmVmbGVjdC5vd25LZXlzKGZyb20pXG4gICAgOiBPYmplY3Qua2V5cyhmcm9tKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIC8vIGluIGNhc2UgdGhlIG9iamVjdCBpcyBhbHJlYWR5IG9ic2VydmVkLi4uXG4gICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIHsgY29udGludWUgfVxuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRvVmFsICE9PSBmcm9tVmFsICYmXG4gICAgICBpc1BsYWluT2JqZWN0KHRvVmFsKSAmJlxuICAgICAgaXNQbGFpbk9iamVjdChmcm9tVmFsKVxuICAgICkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgdmFyIHJlcyA9IGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbDtcbiAgcmV0dXJuIHJlc1xuICAgID8gZGVkdXBlSG9va3MocmVzKVxuICAgIDogcmVzXG59XG5cbmZ1bmN0aW9uIGRlZHVwZUhvb2tzIChob29rcykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmVzLmluZGV4T2YoaG9va3NbaV0pID09PSAtMSkge1xuICAgICAgcmVzLnB1c2goaG9va3NbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcbiAgaWYgKCFuZXcgUmVnRXhwKChcIl5bYS16QS1aXVtcXFxcLVxcXFwuMC05X1wiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiXSokXCIpKS50ZXN0KG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAnc2hvdWxkIGNvbmZvcm0gdG8gdmFsaWQgY3VzdG9tIGVsZW1lbnQgbmFtZSBpbiBodG1sNSBzcGVjaWZpY2F0aW9uLidcbiAgICApO1xuICB9XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAnaWQ6ICcgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShwcm9wcykpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucywgdm0pIHtcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxuICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGluamVjdCkge1xuICAgICAgdmFyIHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJpbmplY3RcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYkJDEgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiQkMSwgdXBkYXRlOiBkZWYkJDEgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcblxuICAvLyBBcHBseSBleHRlbmRzIGFuZCBtaXhpbnMgb24gdGhlIGNoaWxkIG9wdGlvbnMsXG4gIC8vIGJ1dCBvbmx5IGlmIGl0IGlzIGEgcmF3IG9wdGlvbnMgb2JqZWN0IHRoYXQgaXNuJ3RcbiAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxuICAvLyBPbmx5IG1lcmdlZCBvcHRpb25zIGhhcyB0aGUgX2Jhc2UgcHJvcGVydHkuXG4gIGlmICghY2hpbGQuX2Jhc2UpIHtcbiAgICBpZiAoY2hpbGQuZXh0ZW5kcykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQuZXh0ZW5kcywgdm0pO1xuICAgIH1cbiAgICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGJvb2xlYW4gY2FzdGluZ1xuICB2YXIgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XG4gIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgIHZhciBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICBpZiAoc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4KSB7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRPYnNlcnZlID0gc2hvdWxkT2JzZXJ2ZTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHByZXZTaG91bGRPYnNlcnZlKTtcbiAgfVxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIC8vIHNraXAgdmFsaWRhdGlvbiBmb3Igd2VleCByZWN5Y2xlLWxpc3QgY2hpbGQgY29tcG9uZW50IHByb3BzXG4gICAgIShmYWxzZSlcbiAgKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1NhbWVUeXBlIChhLCBiKSB7XG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UgKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gIHZhciBtZXNzYWdlID0gXCJJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuXCIgK1xuICAgIFwiIEV4cGVjdGVkIFwiICsgKGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgdmFyIHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XG4gIHZhciBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxuICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IFwiIHdpdGggdmFsdWUgXCIgKyBleHBlY3RlZFZhbHVlO1xuICB9XG4gIG1lc3NhZ2UgKz0gXCIsIGdvdCBcIiArIHJlY2VpdmVkVHlwZSArIFwiIFwiO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcbiAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBcIndpdGggdmFsdWUgXCIgKyByZWNlaXZlZFZhbHVlICsgXCIuXCI7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2Vcbn1cblxuZnVuY3Rpb24gc3R5bGVWYWx1ZSAodmFsdWUsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgcmV0dXJuIChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoTnVtYmVyKHZhbHVlKSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlICh2YWx1ZSkge1xuICB2YXIgZXhwbGljaXRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XG4gIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW07IH0pXG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbiAoKSB7XG4gIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgcmV0dXJuIGFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbic7IH0pXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICAvLyBEZWFjdGl2YXRlIGRlcHMgdHJhY2tpbmcgd2hpbGUgcHJvY2Vzc2luZyBlcnJvciBoYW5kbGVyIHRvIGF2b2lkIHBvc3NpYmxlIGluZmluaXRlIHJlbmRlcmluZy5cbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVleC9pc3N1ZXMvMTUwNVxuICBwdXNoVGFyZ2V0KCk7XG4gIHRyeSB7XG4gICAgaWYgKHZtKSB7XG4gICAgICB2YXIgY3VyID0gdm07XG4gICAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG4gIH0gZmluYWxseSB7XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcgKFxuICBoYW5kbGVyLFxuICBjb250ZXh0LFxuICBhcmdzLFxuICB2bSxcbiAgaW5mb1xuKSB7XG4gIHZhciByZXM7XG4gIHRyeSB7XG4gICAgcmVzID0gYXJncyA/IGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncykgOiBoYW5kbGVyLmNhbGwoY29udGV4dCk7XG4gICAgaWYgKHJlcyAmJiAhcmVzLl9pc1Z1ZSAmJiBpc1Byb21pc2UocmVzKSAmJiAhcmVzLl9oYW5kbGVkKSB7XG4gICAgICByZXMuY2F0Y2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvICsgXCIgKFByb21pc2UvYXN5bmMpXCIpOyB9KTtcbiAgICAgIC8vIGlzc3VlICM5NTExXG4gICAgICAvLyBhdm9pZCBjYXRjaCB0cmlnZ2VyaW5nIG11bHRpcGxlIHRpbWVzIHdoZW4gbmVzdGVkIGNhbGxzXG4gICAgICByZXMuX2hhbmRsZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZiB0aGUgdXNlciBpbnRlbnRpb25hbGx5IHRocm93cyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gdGhlIGhhbmRsZXIsXG4gICAgICAvLyBkbyBub3QgbG9nIGl0IHR3aWNlXG4gICAgICBpZiAoZSAhPT0gZXJyKSB7XG4gICAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzVXNpbmdNaWNyb1Rhc2sgPSBmYWxzZTtcblxudmFyIGNhbGxiYWNrcyA9IFtdO1xudmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvcGllc1tpXSgpO1xuICB9XG59XG5cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgbWljcm90YXNrcy5cbi8vIEluIDIuNSB3ZSB1c2VkIChtYWNybykgdGFza3MgKGluIGNvbWJpbmF0aW9uIHdpdGggbWljcm90YXNrcykuXG4vLyBIb3dldmVyLCBpdCBoYXMgc3VidGxlIHByb2JsZW1zIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludFxuLy8gKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBBbHNvLCB1c2luZyAobWFjcm8pIHRhc2tzIGluIGV2ZW50IGhhbmRsZXIgd291bGQgY2F1c2Ugc29tZSB3ZWlyZCBiZWhhdmlvcnNcbi8vIHRoYXQgY2Fubm90IGJlIGNpcmN1bXZlbnRlZCAoZS5nLiAjNzEwOSwgIzcxNTMsICM3NTQ2LCAjNzgzNCwgIzgxMDkpLlxuLy8gU28gd2Ugbm93IHVzZSBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGFnYWluLlxuLy8gQSBtYWpvciBkcmF3YmFjayBvZiB0aGlzIHRyYWRlb2ZmIGlzIHRoYXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zXG4vLyB3aGVyZSBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCwgd2hpY2ggaGF2ZSB3b3JrYXJvdW5kcylcbi8vIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZSBldmVudCAoIzY1NjYpLlxudmFyIHRpbWVyRnVuYztcblxuLy8gVGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbi8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4vLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcC50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICAvLyBJbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICghaXNJRSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuKSkge1xuICAvLyBVc2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcbiAgLy8gKCM2NDY2IE11dGF0aW9uT2JzZXJ2ZXIgaXMgdW5yZWxpYWJsZSBpbiBJRTExKVxuICB2YXIgY291bnRlciA9IDE7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoQ2FsbGJhY2tzKTtcbiAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgfSk7XG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgLy8gRmFsbGJhY2sgdG8gc2V0SW1tZWRpYXRlLlxuICAvLyBUZWNoaW5pY2FsbHkgaXQgbGV2ZXJhZ2VzIHRoZSAobWFjcm8pIHRhc2sgcXVldWUsXG4gIC8vIGJ1dCBpdCBpcyBzdGlsbCBhIGJldHRlciBjaG9pY2UgdGhhbiBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIEZhbGxiYWNrIHRvIHNldFRpbWVvdXQuXG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgdmFyIF9yZXNvbHZlO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBlbmRpbmcpIHtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICB0aW1lckZ1bmMoKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICAvLyBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSlcbiAgICB9O1xuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgd2FyblJlc2VydmVkUHJlZml4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIG11c3QgYmUgYWNjZXNzZWQgd2l0aCBcXFwiJGRhdGEuXCIgKyBrZXkgKyBcIlxcXCIgYmVjYXVzZSBcIiArXG4gICAgICAncHJvcGVydGllcyBzdGFydGluZyB3aXRoIFwiJFwiIG9yIFwiX1wiIGFyZSBub3QgcHJveGllZCBpbiB0aGUgVnVlIGluc3RhbmNlIHRvICcgK1xuICAgICAgJ3ByZXZlbnQgY29uZmxpY3RzIHdpdGggVnVlIGludGVybmFscycgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvYXBpLyNkYXRhJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb3h5KTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fFxuICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5LmNoYXJBdCgwKSA9PT0gJ18nICYmICEoa2V5IGluIHRhcmdldC4kZGF0YSkpO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKSB7IHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8IE9iamVjdC5pc0Zyb3plbih2YWwpIHx8IHZhbCBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucywgdm0pIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNsb25lZFtpXSwgbnVsbCwgYXJndW1lbnRzJDEsIHZtLCBcInYtb24gaGFuZGxlclwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhmbnMsIG51bGwsIGFyZ3VtZW50cywgdm0sIFwidi1vbiBoYW5kbGVyXCIpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICBjcmVhdGVPbmNlSGFuZGxlcixcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgZGVmJCQxLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGRlZiQkMSA9IGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgaGFzT3duKHNvdXJjZS5fcHJvdmlkZWQsIHByb3ZpZGVLZXkpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuICB2YXIgc2xvdHMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgIH1cbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXG4gIGZvciAodmFyIG5hbWUkMSBpbiBzbG90cykge1xuICAgIGlmIChzbG90c1tuYW1lJDFdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgIGRlbGV0ZSBzbG90c1tuYW1lJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgbm9ybWFsU2xvdHMsXG4gIHByZXZTbG90c1xuKSB7XG4gIHZhciByZXM7XG4gIHZhciBoYXNOb3JtYWxTbG90cyA9IE9iamVjdC5rZXlzKG5vcm1hbFNsb3RzKS5sZW5ndGggPiAwO1xuICB2YXIgaXNTdGFibGUgPSBzbG90cyA/ICEhc2xvdHMuJHN0YWJsZSA6ICFoYXNOb3JtYWxTbG90cztcbiAgdmFyIGtleSA9IHNsb3RzICYmIHNsb3RzLiRrZXk7XG4gIGlmICghc2xvdHMpIHtcbiAgICByZXMgPSB7fTtcbiAgfSBlbHNlIGlmIChzbG90cy5fbm9ybWFsaXplZCkge1xuICAgIC8vIGZhc3QgcGF0aCAxOiBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVyIG9ubHksIHBhcmVudCBkaWQgbm90IGNoYW5nZVxuICAgIHJldHVybiBzbG90cy5fbm9ybWFsaXplZFxuICB9IGVsc2UgaWYgKFxuICAgIGlzU3RhYmxlICYmXG4gICAgcHJldlNsb3RzICYmXG4gICAgcHJldlNsb3RzICE9PSBlbXB0eU9iamVjdCAmJlxuICAgIGtleSA9PT0gcHJldlNsb3RzLiRrZXkgJiZcbiAgICAhaGFzTm9ybWFsU2xvdHMgJiZcbiAgICAhcHJldlNsb3RzLiRoYXNOb3JtYWxcbiAgKSB7XG4gICAgLy8gZmFzdCBwYXRoIDI6IHN0YWJsZSBzY29wZWQgc2xvdHMgdy8gbm8gbm9ybWFsIHNsb3RzIHRvIHByb3h5LFxuICAgIC8vIG9ubHkgbmVlZCB0byBub3JtYWxpemUgb25jZVxuICAgIHJldHVybiBwcmV2U2xvdHNcbiAgfSBlbHNlIHtcbiAgICByZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkkMSBpbiBzbG90cykge1xuICAgICAgaWYgKHNsb3RzW2tleSQxXSAmJiBrZXkkMVswXSAhPT0gJyQnKSB7XG4gICAgICAgIHJlc1trZXkkMV0gPSBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXkkMSwgc2xvdHNba2V5JDFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZXhwb3NlIG5vcm1hbCBzbG90cyBvbiBzY29wZWRTbG90c1xuICBmb3IgKHZhciBrZXkkMiBpbiBub3JtYWxTbG90cykge1xuICAgIGlmICghKGtleSQyIGluIHJlcykpIHtcbiAgICAgIHJlc1trZXkkMl0gPSBwcm94eU5vcm1hbFNsb3Qobm9ybWFsU2xvdHMsIGtleSQyKTtcbiAgICB9XG4gIH1cbiAgLy8gYXZvcmlheiBzZWVtcyB0byBtb2NrIGEgbm9uLWV4dGVuc2libGUgJHNjb3BlZFNsb3RzIG9iamVjdFxuICAvLyBhbmQgd2hlbiB0aGF0IGlzIHBhc3NlZCBkb3duIHRoaXMgd291bGQgY2F1c2UgYW4gZXJyb3JcbiAgaWYgKHNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2xvdHMpKSB7XG4gICAgKHNsb3RzKS5fbm9ybWFsaXplZCA9IHJlcztcbiAgfVxuICBkZWYocmVzLCAnJHN0YWJsZScsIGlzU3RhYmxlKTtcbiAgZGVmKHJlcywgJyRrZXknLCBrZXkpO1xuICBkZWYocmVzLCAnJGhhc05vcm1hbCcsIGhhc05vcm1hbFNsb3RzKTtcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXksIGZuKSB7XG4gIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID8gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSA6IGZuKHt9KTtcbiAgICByZXMgPSByZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVzKVxuICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcbiAgICAgIDogbm9ybWFsaXplQ2hpbGRyZW4ocmVzKTtcbiAgICByZXR1cm4gcmVzICYmIChcbiAgICAgIHJlcy5sZW5ndGggPT09IDAgfHxcbiAgICAgIChyZXMubGVuZ3RoID09PSAxICYmIHJlc1swXS5pc0NvbW1lbnQpIC8vICM5NjU4XG4gICAgKSA/IHVuZGVmaW5lZFxuICAgICAgOiByZXNcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgaWYgKGZuLnByb3h5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFxufVxuXG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2xvdHNba2V5XTsgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzRGVmKHJldCkpIHtcbiAgICByZXQgPSBbXTtcbiAgfVxuICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIG5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV0gfHwgZmFsbGJhY2s7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIGlmICghKGNhbWVsaXplZEtleSBpbiBoYXNoKSAmJiAhKGh5cGhlbmF0ZWRLZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uWyhcInVwZGF0ZTpcIiArIGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiB0cmVlXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxuICAgIG51bGwsXG4gICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICApO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlcyxcbiAgLy8gdGhlIGZvbGxvd2luZyBhcmUgYWRkZWQgaW4gMi42XG4gIGhhc0R5bmFtaWNLZXlzLFxuICBjb250ZW50SGFzaEtleVxuKSB7XG4gIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzbG90ID0gZm5zW2ldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNsb3QpKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoc2xvdCwgcmVzLCBoYXNEeW5hbWljS2V5cyk7XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICAvLyBtYXJrZXIgZm9yIHJldmVyc2UgcHJveHlpbmcgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICAgIGlmIChzbG90LnByb3h5KSB7XG4gICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmVzW3Nsb3Qua2V5XSA9IHNsb3QuZm47XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50SGFzaEtleSkge1xuICAgIChyZXMpLiRrZXkgPSBjb250ZW50SGFzaEtleTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMgKGJhc2VPYmosIHZhbHVlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBrZXkgPSB2YWx1ZXNbaV07XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleSkge1xuICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYga2V5ICE9PSAnJyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIC8vIG51bGwgaXMgYSBzcGVpY2FsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xuICAgICAgd2FybihcbiAgICAgICAgKFwiSW52YWxpZCB2YWx1ZSBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgKGV4cGVjdGVkIHN0cmluZyBvciBudWxsKTogXCIgKyBrZXkpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmFzZU9ialxufVxuXG4vLyBoZWxwZXIgdG8gZHluYW1pY2FsbHkgYXBwZW5kIG1vZGlmaWVyIHJ1bnRpbWUgbWFya2VycyB0byBldmVudCBuYW1lcy5cbi8vIGVuc3VyZSBvbmx5IGFwcGVuZCB3aGVuIHZhbHVlIGlzIGFscmVhZHkgc3RyaW5nLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjYXN0XG4vLyB0byBzdHJpbmcgYW5kIGNhdXNlIHRoZSB0eXBlIGNoZWNrIHRvIG1pc3MuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXIgKHZhbHVlLCBzeW1ib2wpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBzeW1ib2wgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XG4gIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICB0YXJnZXQuX24gPSB0b051bWJlcjtcbiAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XG4gIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XG4gIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XG4gIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xuICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xuICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xuICB0YXJnZXQuX2QgPSBiaW5kRHluYW1pY0tleXM7XG4gIHRhcmdldC5fcCA9IHByZXBlbmRNb2RpZmllcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgZGF0YSxcbiAgcHJvcHMsXG4gIGNoaWxkcmVuLFxuICBwYXJlbnQsXG4gIEN0b3Jcbikge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBjb250ZXh0Vm07XG4gIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XG4gICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgLy8gcmVhbCBjb250ZXh0IGluc3RhbmNlLlxuICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xuICB9XG4gIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzJDEuJHNsb3RzKSB7XG4gICAgICBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdGhpcyQxLiRzbG90cyA9IHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMkMS4kc2xvdHNcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Njb3BlZFNsb3RzJywgKHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLnNsb3RzKCkpXG4gICAgfVxuICB9KSk7XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuJHNsb3RzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICAgICAgaWYgKHZub2RlICYmICFBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG5cbiAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zLCByZW5kZXJDb250ZXh0KSB7XG4gIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAoY2xvbmUuZGV2dG9vbHNNZXRhID0gY2xvbmUuZGV2dG9vbHNNZXRhIHx8IHt9KS5yZW5kZXJDb250ZXh0ID0gcmVuZGVyQ29udGV4dDtcbiAgfVxuICBpZiAoZGF0YS5zbG90KSB7XG4gICAgKGNsb25lLmRhdGEgfHwgKGNsb25lLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIGlmIChcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgdmFyIGFzeW5jRmFjdG9yeTtcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IpO1xuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgZGF0YSA9IHt9O1xuICAgIGlmIChzbG90KSB7XG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50IC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIHBhcmVudDogcGFyZW50XG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZXhpc3RpbmcgPSBob29rc1trZXldO1xuICAgIHZhciB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGlmIChleGlzdGluZyAhPT0gdG9NZXJnZSAmJiAhKGV4aXN0aW5nICYmIGV4aXN0aW5nLl9tZXJnZWQpKSB7XG4gICAgICBob29rc1trZXldID0gZXhpc3RpbmcgPyBtZXJnZUhvb2skMSh0b01lcmdlLCBleGlzdGluZykgOiB0b01lcmdlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAoZjEsIGYyKSB7XG4gIHZhciBtZXJnZWQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIGZsb3cgY29tcGxhaW5zIGFib3V0IGV4dHJhIGFyZ3Mgd2hpY2ggaXMgd2h5IHdlIHVzZSBhbnlcbiAgICBmMShhLCBiKTtcbiAgICBmMihhLCBiKTtcbiAgfTtcbiAgbWVyZ2VkLl9tZXJnZWQgPSB0cnVlO1xuICByZXR1cm4gbWVyZ2VkXG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCdcbiAgOyhkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIHZhciBleGlzdGluZyA9IG9uW2V2ZW50XTtcbiAgdmFyIGNhbGxiYWNrID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xuICAgIGlmIChcbiAgICAgIEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpXG4gICAgICAgID8gZXhpc3RpbmcuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xXG4gICAgICAgIDogZXhpc3RpbmcgIT09IGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoKCFkYXRhIHx8ICFkYXRhLnByZSkgJiYgaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgIGlmIChpc0RlZihucykpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7IHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXG4gICAgICAgIGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyByZWYgIzUzMThcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4vLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MgKGRhdGEpIHtcbiAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5zdHlsZSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG52YXIgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xuICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcblxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICBpZiAoX3BhcmVudFZub2RlKSB7XG4gICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHZtLiRzbG90cyxcbiAgICAgICAgdm0uJHNjb3BlZFNsb3RzXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBtYWludGFpbiBhIHN0YWNrIGJlY2F1ZXMgYWxsIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIG9uZSBhbm90aGVyLiBOZXN0ZWQgY29tcG9uZW50J3MgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyB3aGVuIHBhcmVudCBjb21wb25lbnQgaXMgcGF0Y2hlZC5cbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHZtO1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpICYmIHZub2RlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICBpZiAoXG4gICAgY29tcC5fX2VzTW9kdWxlIHx8XG4gICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICApIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvclxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgdmFyIG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAob3duZXIgJiYgaXNEZWYoZmFjdG9yeS5vd25lcnMpICYmIGZhY3Rvcnkub3duZXJzLmluZGV4T2Yob3duZXIpID09PSAtMSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3Rvcnkub3duZXJzLnB1c2gob3duZXIpO1xuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChvd25lciAmJiAhaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgdmFyIG93bmVycyA9IGZhY3Rvcnkub3duZXJzID0gW293bmVyXTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG4gICAgdmFyIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgdmFyIHRpbWVyVGltZW91dCA9IG51bGxcblxuICAgIDsob3duZXIpLiRvbignaG9vazpkZXN0cm95ZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1vdmUob3duZXJzLCBvd25lcik7IH0pO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIChvd25lcnNbaV0pLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAodGltZXJMb2FkaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyTG9hZGluZyk7XG4gICAgICAgICAgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyVGltZW91dCk7XG4gICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICB0aW1lclRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChldmVudCwgZm4pIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQ7XG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgX3RhcmdldC4kb2ZmKGV2ZW50LCBvbmNlSGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIGNyZWF0ZU9uY2VIYW5kbGVyLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkkMSA8IGw7IGkkMSsrKSB7XG4gICAgICAgIHZtLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKCFmbikge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICB2YXIgaW5mbyA9IFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYnNbaV0sIHZtLCBhcmdzLCB2bSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gc2V0QWN0aXZlSW5zdGFuY2Uodm0pIHtcbiAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2Uodm0pO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCB7XG4gICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUgKCkge1xuICAgICAgaWYgKHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbi5cblxuICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgZHluYW1pYyBzY29wZWRTbG90cyAoaGFuZC13cml0dGVuIG9yIGNvbXBpbGVkIGJ1dCB3aXRoXG4gIC8vIGR5bmFtaWMgc2xvdCBuYW1lcykuIFN0YXRpYyBzY29wZWQgc2xvdHMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBoYXMgdGhlXG4gIC8vIFwiJHN0YWJsZVwiIG1hcmtlci5cbiAgdmFyIG5ld1Njb3BlZFNsb3RzID0gcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cztcbiAgdmFyIG9sZFNjb3BlZFNsb3RzID0gdm0uJHNjb3BlZFNsb3RzO1xuICB2YXIgaGFzRHluYW1pY1Njb3BlZFNsb3QgPSAhIShcbiAgICAobmV3U2NvcGVkU2xvdHMgJiYgIW5ld1Njb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgKG9sZFNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJiAhb2xkU2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAobmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkgIT09IG5ld1Njb3BlZFNsb3RzLiRrZXkpXG4gICk7XG5cbiAgLy8gQW55IHN0YXRpYyBzbG90IGNoaWxkcmVuIGZyb20gdGhlIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyBwYXJlbnQnc1xuICAvLyB1cGRhdGUuIER5bmFtaWMgc2NvcGVkIHNsb3RzIG1heSBhbHNvIGhhdmUgY2hhbmdlZC4gSW4gc3VjaCBjYXNlcywgYSBmb3JjZWRcbiAgLy8gdXBkYXRlIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdG5lc3MuXG4gIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBoYXNEeW5hbWljU2NvcGVkU2xvdFxuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICB2YXIgaW5mbyA9IGhvb2sgKyBcIiBob29rXCI7XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIG51bGwsIHZtLCBpbmZvKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG59XG5cbi8qICAqL1xuXG52YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxudmFyIHF1ZXVlID0gW107XG52YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbi8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG52YXIgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cbnZhciBnZXROb3cgPSBEYXRlLm5vdztcblxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcbi8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXG4vLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cbi8vIEFsbCBJRSB2ZXJzaW9ucyB1c2UgbG93LXJlcyBldmVudCB0aW1lc3RhbXBzLCBhbmQgaGF2ZSBwcm9ibGVtYXRpYyBjbG9ja1xuLy8gaW1wbGVtZW50YXRpb25zICgjOTYzMilcbmlmIChpbkJyb3dzZXIgJiYgIWlzSUUpIHtcbiAgdmFyIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlO1xuICBpZiAoXG4gICAgcGVyZm9ybWFuY2UgJiZcbiAgICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nICYmXG4gICAgZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXBcbiAgKSB7XG4gICAgLy8gaWYgdGhlIGV2ZW50IHRpbWVzdGFtcCwgYWx0aG91Z2ggZXZhbHVhdGVkIEFGVEVSIHRoZSBEYXRlLm5vdygpLCBpc1xuICAgIC8vIHNtYWxsZXIgdGhhbiBpdCwgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lciB0aW1lc3RhbXBzIGFzXG4gICAgLy8gd2VsbC5cbiAgICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcbiAgfVxufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgIH1cbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25maWcuYXN5bmMpIHtcbiAgICAgICAgZmx1c2hTY2hlZHVsZXJRdWV1ZSgpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9ucyxcbiAgaXNSZW5kZXJXYXRjaGVyXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICB9XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gICAgdGhpcy5iZWZvcmUgPSBvcHRpb25zLmJlZm9yZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IG5vb3A7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBpZiAoIWlzUm9vdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gIH1cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxuICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGh5cGhlbmF0ZWRLZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jvb3QgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9IGZpbmFsbHkge1xuICAgIHBvcFRhcmdldCgpO1xuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gIHZhciBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNTU1IpIHtcbiAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIoXG4gICAgICAgIHZtLFxuICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgbm9vcCxcbiAgICAgICAgY29tcHV0ZWRXYXRjaGVyT3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXG4gIHRhcmdldCxcbiAga2V5LFxuICB1c2VyRGVmXG4pIHtcbiAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZik7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZi5nZXQpXG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0IHx8IG5vb3A7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHRoaXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgdHlwZSBcXFwiXCIgKyAodHlwZW9mIG1ldGhvZHNba2V5XSkgKyBcIlxcXCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgXCJBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtW2tleV0gPSB0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBoYW5kbGVyLFxuICBvcHRpb25zXG4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnJvciwgdm0sIChcImNhbGxiYWNrIGZvciBpbW1lZGlhdGUgd2F0Y2hlciBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciB1aWQkMyA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDMrKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcblxuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcblxuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBsYXRlc3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUpO1xuc3RhdGVNaXhpbihWdWUpO1xuZXZlbnRzTWl4aW4oVnVlKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG5yZW5kZXJNaXhpbihWdWUpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzLmNhY2hlLCBrZXksIHRoaXMua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIC8vIDIuNiBleHBsaWNpdCBvYnNlcnZhYmxlIEFQSVxuICBWdWUub2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBvYnNlcnZlKG9iaik7XG4gICAgcmV0dXJuIG9ialxuICB9O1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnRnVuY3Rpb25hbFJlbmRlckNvbnRleHQnLCB7XG4gIHZhbHVlOiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFxufSk7XG5cblZ1ZS52ZXJzaW9uID0gJzIuNi4xMCc7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUgPSBtYWtlTWFwKCdldmVudHMsY2FyZXQsdHlwaW5nLHBsYWludGV4dC1vbmx5Jyk7XG5cbnZhciBjb252ZXJ0RW51bWVyYXRlZFZhbHVlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnXG4gICAgPyAnZmFsc2UnXG4gICAgLy8gYWxsb3cgYXJiaXRyYXJ5IHN0cmluZyB2YWx1ZSBmb3IgY29udGVudGVkaXRhYmxlXG4gICAgOiBrZXkgPT09ICdjb250ZW50ZWRpdGFibGUnICYmIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSh2YWx1ZSlcbiAgICAgID8gdmFsdWVcbiAgICAgIDogJ3RydWUnXG59O1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlU2NvcGUgKG5vZGUsIHNjb3BlSWQpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoc2NvcGVJZCwgJycpO1xufVxuXG52YXIgbm9kZU9wcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICBjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG4gIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgdGFnTmFtZTogdGFnTmFtZSxcbiAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuICBzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICghaXNEZWYoa2V5KSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWluVlByZSAmJlxuICAgICAgIXZub2RlLm5zICYmXG4gICAgICAhKFxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYkJDEpID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKG5ld0NoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgIHZhciBzZWVuS2V5cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleTtcbiAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIChcIkR1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnXCIgKyBrZXkgKyBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGMgPSBvbGRDaFtpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKFxuICAgIG9sZFZub2RlLFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4LFxuICAgIHJlbW92ZU9ubHlcbiAgKSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIGNsb25lIHJldXNlZCB2bm9kZVxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGRpci5vbGRBcmcgPSBvbGREaXIuYXJnO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgY29udmVydEVudW1lcmF0ZWRWYWx1ZShrZXksIHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgLy8gPHRleHRhcmVhPi4uLiBibG9jayB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYW5kIHJlbW92ZSB0aGUgYmxvY2tlclxuICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICBrZXkgPT09ICdwbGFjZWhvbGRlcicgJiYgdmFsdWUgIT09ICcnICYmICFlbC5fX2llcGhcbiAgICApIHtcbiAgICAgIHZhciBibG9ja2VyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIH07XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuLyogICovXG5cbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMgKGV4cCkge1xuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgdmFyIGluRG91YmxlID0gZmFsc2U7XG4gIHZhciBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gIHZhciBjdXJseSA9IDA7XG4gIHZhciBzcXVhcmUgPSAwO1xuICB2YXIgcGFyZW4gPSAwO1xuICB2YXIgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgdmFyIGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIHsgaW5TaW5nbGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NUMpIHsgaW5SZWdleCA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgKGFyZ3MgIT09ICcpJyA/ICcsJyArIGFyZ3MgOiBhcmdzKSlcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5mdW5jdGlvbiBiYXNlV2FybiAobXNnLCByYW5nZSkge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xufVxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xuICB2YXIgYXR0cnMgPSBkeW5hbWljXG4gICAgPyAoZWwuZHluYW1pY0F0dHJzIHx8IChlbC5keW5hbWljQXR0cnMgPSBbXSkpXG4gICAgOiAoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKTtcbiAgYXR0cnMucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXG5mdW5jdGlvbiBhZGRSYXdBdHRyIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlKSB7XG4gIGVsLmF0dHJzTWFwW25hbWVdID0gdmFsdWU7XG4gIGVsLmF0dHJzTGlzdC5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9LCByYW5nZSkpO1xufVxuXG5mdW5jdGlvbiBhZGREaXJlY3RpdmUgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmF3TmFtZSxcbiAgdmFsdWUsXG4gIGFyZyxcbiAgaXNEeW5hbWljQXJnLFxuICBtb2RpZmllcnMsXG4gIHJhbmdlXG4pIHtcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHJhd05hbWU6IHJhd05hbWUsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGFyZzogYXJnLFxuICAgIGlzRHluYW1pY0FyZzogaXNEeW5hbWljQXJnLFxuICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXG4gIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllck1hcmtlciAoc3ltYm9sLCBuYW1lLCBkeW5hbWljKSB7XG4gIHJldHVybiBkeW5hbWljXG4gICAgPyAoXCJfcChcIiArIG5hbWUgKyBcIixcXFwiXCIgKyBzeW1ib2wgKyBcIlxcXCIpXCIpXG4gICAgOiBzeW1ib2wgKyBuYW1lIC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50LFxuICB3YXJuLFxuICByYW5nZSxcbiAgZHluYW1pY1xuKSB7XG4gIG1vZGlmaWVycyA9IG1vZGlmaWVycyB8fCBlbXB0eU9iamVjdDtcbiAgLy8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuICYmXG4gICAgbW9kaWZpZXJzLnByZXZlbnQgJiYgbW9kaWZpZXJzLnBhc3NpdmVcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdwYXNzaXZlIGFuZCBwcmV2ZW50IGNhblxcJ3QgYmUgdXNlZCB0b2dldGhlci4gJyArXG4gICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LicsXG4gICAgICByYW5nZVxuICAgICk7XG4gIH1cblxuICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcbiAgLy8gdGhpcyBpcyB0ZWNobmljYWxseSBicm93c2VyLXNwZWNpZmljLCBidXQgYXQgbGVhc3QgZm9yIG5vdyBicm93c2VycyBhcmVcbiAgLy8gdGhlIG9ubHkgdGFyZ2V0IGVudnMgdGhhdCBoYXZlIHJpZ2h0L21pZGRsZSBjbGlja3MuXG4gIGlmIChtb2RpZmllcnMucmlnaHQpIHtcbiAgICBpZiAoZHluYW1pYykge1xuICAgICAgbmFtZSA9IFwiKFwiICsgbmFtZSArIFwiKT09PSdjbGljayc/J2NvbnRleHRtZW51JzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBuYW1lID0gJ2NvbnRleHRtZW51JztcbiAgICAgIGRlbGV0ZSBtb2RpZmllcnMucmlnaHQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKG1vZGlmaWVycy5taWRkbGUpIHtcbiAgICBpZiAoZHluYW1pYykge1xuICAgICAgbmFtZSA9IFwiKFwiICsgbmFtZSArIFwiKT09PSdjbGljayc/J21vdXNldXAnOihcIiArIG5hbWUgKyBcIilcIjtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignIScsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG4gIGlmIChtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCd+JywgbmFtZSwgZHluYW1pYyk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCcmJywgbmFtZSwgZHluYW1pYyk7XG4gIH1cblxuICB2YXIgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG5cbiAgdmFyIG5ld0hhbmRsZXIgPSByYW5nZVNldEl0ZW0oeyB2YWx1ZTogdmFsdWUudHJpbSgpLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKTtcbiAgaWYgKG1vZGlmaWVycyAhPT0gZW1wdHlPYmplY3QpIHtcbiAgICBuZXdIYW5kbGVyLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgfVxuXG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxuXG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFJhd0JpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWVcbikge1xuICByZXR1cm4gZWwucmF3QXR0cnNNYXBbJzonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFsndi1iaW5kOicgKyBuYW1lXSB8fFxuICAgIGVsLnJhd0F0dHJzTWFwW25hbWVdXG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG4vLyBub3RlOiB0aGlzIG9ubHkgcmVtb3ZlcyB0aGUgYXR0ciBmcm9tIHRoZSBBcnJheSAoYXR0cnNMaXN0KSBzbyB0aGF0IGl0XG4vLyBkb2Vzbid0IGdldCBwcm9jZXNzZWQgYnkgcHJvY2Vzc0F0dHJzLlxuLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXG4vLyBuZWVkZWQgZHVyaW5nIGNvZGVnZW4uXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJlbW92ZUZyb21NYXBcbikge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92ZUZyb21NYXApIHtcbiAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleCAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGxpc3RbaV07XG4gICAgaWYgKG5hbWUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgIHJldHVybiBhdHRyXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJhbmdlU2V0SXRlbSAoXG4gIGl0ZW0sXG4gIHJhbmdlXG4pIHtcbiAgaWYgKHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgIGl0ZW0uc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICB9XG4gICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsKSB7XG4gICAgICBpdGVtLmVuZCA9IHJhbmdlLmVuZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGl0ZW1cbn1cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXG4gICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICBlbC5tb2RlbCA9IHtcbiAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG4gICAgZXhwcmVzc2lvbjogSlNPTi5zdHJpbmdpZnkodmFsdWUpLFxuICAgIGNhbGxiYWNrOiAoXCJmdW5jdGlvbiAoXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpIHtcIiArIGFzc2lnbm1lbnQgKyBcIn1cIilcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICB2YWx1ZSxcbiAgYXNzaWdubWVudFxuKSB7XG4gIHZhciByZXMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcbiAgaWYgKHJlcy5rZXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gKHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCIkc2V0KFwiICsgKHJlcy5leHApICsgXCIsIFwiICsgKHJlcy5rZXkpICsgXCIsIFwiICsgYXNzaWdubWVudCArIFwiKVwiKVxuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYSB2LW1vZGVsIGV4cHJlc3Npb24gaW50byBhIGJhc2UgcGF0aCBhbmQgYSBmaW5hbCBrZXkgc2VnbWVudC5cbiAqIEhhbmRsZXMgYm90aCBkb3QtcGF0aCBhbmQgcG9zc2libGUgc3F1YXJlIGJyYWNrZXRzLlxuICpcbiAqIFBvc3NpYmxlIGNhc2VzOlxuICpcbiAqIC0gdGVzdFxuICogLSB0ZXN0W2tleV1cbiAqIC0gdGVzdFt0ZXN0MVtrZXldXVxuICogLSB0ZXN0W1wiYVwiXVtrZXldXG4gKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFba2V5XV1cbiAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtrZXldXVxuICpcbiAqL1xuXG52YXIgbGVuLCBzdHIsIGNociwgaW5kZXgkMSwgZXhwcmVzc2lvblBvcywgZXhwcmVzc2lvbkVuZFBvcztcblxuXG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICAvLyBGaXggaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9wdWxsLzc3MzBcbiAgLy8gYWxsb3cgdi1tb2RlbD1cIm9iai52YWwgXCIgKHRyYWlsaW5nIHdoaXRlc3BhY2UpXG4gIHZhbCA9IHZhbC50cmltKCk7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuICAgIGluZGV4JDEgPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICBpZiAoaW5kZXgkMSA+IC0xKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBpbmRleCQxKSxcbiAgICAgICAga2V5OiAnXCInICsgdmFsLnNsaWNlKGluZGV4JDEgKyAxKSArICdcIidcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwsXG4gICAgICAgIGtleTogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0ciA9IHZhbDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc2xpY2UoMCwgZXhwcmVzc2lvblBvcyksXG4gICAga2V5OiB2YWwuc2xpY2UoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dCAoKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCQxID49IGxlblxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0IChjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcbn1cblxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcbiAgdmFyIGluQnJhY2tldCA9IDE7XG4gIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiQxO1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICB2YXIgdGFnID0gZWwudGFnO1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiIHR5cGU9XFxcImZpbGVcXFwiPjpcXG5cIiArXG4gICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMShcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LicsXG4gICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuY29uY2F0KFskJHZdKScpKSArIFwiKX1cIiArXG4gICAgICBcImVsc2V7JCRpPi0xJiYoXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKScpKSArIFwiKX1cIiArXG4gICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcbiAgLy8gZXhjZXB0IGZvciBpbnB1dHMgd2l0aCB2LWJpbmQ6dHlwZVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciB2YWx1ZSQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddIHx8IGVsLmF0dHJzTWFwWyc6dmFsdWUnXTtcbiAgICB2YXIgdHlwZUJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICBpZiAodmFsdWUkMSAmJiAhdHlwZUJpbmRpbmcpIHtcbiAgICAgIHZhciBiaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddID8gJ3YtYmluZDp2YWx1ZScgOiAnOnZhbHVlJztcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYmluZGluZyArIFwiPVxcXCJcIiArIHZhbHVlJDEgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggdi1tb2RlbCBvbiB0aGUgc2FtZSBlbGVtZW50IFwiICtcbiAgICAgICAgJ2JlY2F1c2UgdGhlIGxhdHRlciBhbHJlYWR5IGV4cGFuZHMgdG8gYSB2YWx1ZSBiaW5kaW5nIGludGVybmFsbHknLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFtiaW5kaW5nXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgdmFyIGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IFwiaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuO1wiICsgY29kZTtcbiAgfVxuXG4gIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgdmFyIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgLy8gVGhpcyB3YXMgb3JpZ2luYWxseSBpbnRlbmRlZCB0byBmaXggIzQ1MjEgYnV0IG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciQxIChldmVudCwgaGFuZGxlciwgY2FwdHVyZSkge1xuICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIHZhciByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gIzk0NDY6IEZpcmVmb3ggPD0gNTMgKGluIHBhcnRpY3VsYXIsIEVTUiA1MikgaGFzIGluY29ycmVjdCBFdmVudC50aW1lU3RhbXBcbi8vIGltcGxlbWVudGF0aW9uIGFuZCBkb2VzIG5vdCBmaXJlIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbiwgc29cbi8vIHNhZmUgdG8gZXhjbHVkZS5cbnZhciB1c2VNaWNyb3Rhc2tGaXggPSBpc1VzaW5nTWljcm9UYXNrICYmICEoaXNGRiAmJiBOdW1iZXIoaXNGRlsxXSkgPD0gNTMpO1xuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIG5hbWUsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICAvLyBhc3luYyBlZGdlIGNhc2UgIzY1NjY6IGlubmVyIGNsaWNrIGV2ZW50IHRyaWdnZXJzIHBhdGNoLCBldmVudCBoYW5kbGVyXG4gIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXG4gIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAvLyB0aGUgc29sdXRpb24gaXMgc2ltcGxlOiB3ZSBzYXZlIHRoZSB0aW1lc3RhbXAgd2hlbiBhIGhhbmRsZXIgaXMgYXR0YWNoZWQsXG4gIC8vIGFuZCB0aGUgaGFuZGxlciB3b3VsZCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHBhc3NlZCB0byBpdCB3YXMgZmlyZWRcbiAgLy8gQUZURVIgaXQgd2FzIGF0dGFjaGVkLlxuICBpZiAodXNlTWljcm90YXNrRml4KSB7XG4gICAgdmFyIGF0dGFjaGVkVGltZXN0YW1wID0gY3VycmVudEZsdXNoVGltZXN0YW1wO1xuICAgIHZhciBvcmlnaW5hbCA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IG9yaWdpbmFsLl93cmFwcGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm8gYnViYmxpbmcsIHNob3VsZCBhbHdheXMgZmlyZS5cbiAgICAgICAgLy8gdGhpcyBpcyBqdXN0IGEgc2FmZXR5IG5ldCBpbiBjYXNlIGV2ZW50LnRpbWVTdGFtcCBpcyB1bnJlbGlhYmxlIGluXG4gICAgICAgIC8vIGNlcnRhaW4gd2VpcmQgZW52aXJvbm1lbnRzLi4uXG4gICAgICAgIGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgfHxcbiAgICAgICAgLy8gZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgaGFuZGxlciBhdHRhY2htZW50XG4gICAgICAgIGUudGltZVN0YW1wID49IGF0dGFjaGVkVGltZXN0YW1wIHx8XG4gICAgICAgIC8vIGJhaWwgZm9yIGVudmlyb25tZW50cyB0aGF0IGhhdmUgYnVnZ3kgZXZlbnQudGltZVN0YW1wIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAvLyAjOTQ2MiBpT1MgOSBidWc6IGV2ZW50LnRpbWVTdGFtcCBpcyAwIGFmdGVyIGhpc3RvcnkucHVzaFN0YXRlXG4gICAgICAgIC8vICM5NjgxIFF0V2ViRW5naW5lIGV2ZW50LnRpbWVTdGFtcCBpcyBuZWdhdGl2ZSB2YWx1ZVxuICAgICAgICBlLnRpbWVTdGFtcCA8PSAwIHx8XG4gICAgICAgIC8vICM5NDQ4IGJhaWwgaWYgZXZlbnQgaXMgZmlyZWQgaW4gYW5vdGhlciBkb2N1bWVudCBpbiBhIG11bHRpLXBhZ2VcbiAgICAgICAgLy8gZWxlY3Ryb24vbncuanMgYXBwLCBzaW5jZSBldmVudC50aW1lU3RhbXAgd2lsbCBiZSB1c2luZyBhIGRpZmZlcmVudFxuICAgICAgICAvLyBzdGFydGluZyByZWZlcmVuY2VcbiAgICAgICAgZS50YXJnZXQub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnRcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBuYW1lLFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBuYW1lLFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLl93cmFwcGVyIHx8IGhhbmRsZXIsXG4gICAgY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgY3JlYXRlT25jZUhhbmRsZXIkMSwgdm5vZGUuY29udGV4dCk7XG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG52YXIgc3ZnQ29udGFpbmVyO1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gcHJvcHMpKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgICAvLyAjNjYwMSB3b3JrIGFyb3VuZCBDaHJvbWUgdmVyc2lvbiA8PSA1NSBidWcgd2hlcmUgc2luZ2xlIHRleHROb2RlXG4gICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxuICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiYgZWxtLnRhZ05hbWUgIT09ICdQUk9HUkVTUycpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJyAmJiBpc1NWRyhlbG0udGFnTmFtZSkgJiYgaXNVbmRlZihlbG0uaW5uZXJIVE1MKSkge1xuICAgICAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IGlubmVySFRNTCBmb3IgU1ZHIGVsZW1lbnRzXG4gICAgICBzdmdDb250YWluZXIgPSBzdmdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzdmdDb250YWluZXIuaW5uZXJIVE1MID0gXCI8c3ZnPlwiICsgY3VyICsgXCI8L3N2Zz5cIjtcbiAgICAgIHZhciBzdmcgPSBzdmdDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgIHdoaWxlIChlbG0uZmlyc3RDaGlsZCkge1xuICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHN2Zy5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsbS5hcHBlbmRDaGlsZChzdmcuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIHNraXAgdGhlIHVwZGF0ZSBpZiBvbGQgYW5kIG5ldyBWRE9NIHN0YXRlIGlzIHRoZSBzYW1lLlxuICAgICAgLy8gYHZhbHVlYCBpcyBoYW5kbGVkIHNlcGFyYXRlbHkgYmVjYXVzZSB0aGUgRE9NIHZhbHVlIG1heSBiZSB0ZW1wb3JhcmlseVxuICAgICAgLy8gb3V0IG9mIHN5bmMgd2l0aCBWRE9NIHN0YXRlIGR1ZSB0byBmb2N1cywgY29tcG9zaXRpb24gYW5kIG1vZGlmaWVycy5cbiAgICAgIC8vIFRoaXMgICM0NTIxIGJ5IHNraXBwaW5nIHRoZSB1bm5lY2VzYXJyeSBgY2hlY2tlZGAgdXBkYXRlLlxuICAgICAgY3VyICE9PSBvbGRQcm9wc1trZXldXG4gICAgKSB7XG4gICAgICAvLyBzb21lIHByb3BlcnR5IHVwZGF0ZXMgY2FuIHRocm93XG4gICAgICAvLyBlLmcuIGB2YWx1ZWAgb24gPHByb2dyZXNzPiB3LyBub24tZmluaXRlIHZhbHVlXG4gICAgICB0cnkge1xuICAgICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykpIHtcbiAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSlcbiAgICAgICkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKG5hbWUpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciBlbXB0eVN0eWxlO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbnZhciB3aGl0ZXNwYWNlUkUgPSAvXFxzKy87XG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlclxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgOiBzZXRUaW1lb3V0XG4gIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuLy8gT2xkIHZlcnNpb25zIG9mIENocm9taXVtIChiZWxvdyA2MS4wLjMxNjMuMTAwKSBmb3JtYXRzIGZsb2F0aW5nIHBvaW50ZXIgbnVtYmVyc1xuLy8gaW4gYSBsb2NhbGUtZGVwZW5kZW50IHdheSwgdXNpbmcgYSBjb21tYSBpbnN0ZWFkIG9mIGEgZG90LlxuLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93biAoaS5lLiBhY3Rpbmdcbi8vIGFzIGEgZmxvb3IgZnVuY3Rpb24pIGNhdXNpbmcgdW5leHBlY3RlZCBiZWhhdmlvcnNcbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKCcsJywgJy4nKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cgJiYgZWwucGFyZW50Tm9kZSkge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgZGlyZWN0aXZlID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gIzY5MDNcbiAgICAgIGlmIChvbGRWbm9kZS5lbG0gJiYgIW9sZFZub2RlLmVsbS5fdk9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICB2YXIgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKTsgfSkpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9ucyk7XG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogZGlyZWN0aXZlLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG52YXIgaXNOb3RUZXh0Tm9kZSA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH07XG5cbnZhciBpc1ZTaG93RGlyZWN0aXZlID0gZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9O1xuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGlzTm90VGV4dE5vZGUpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGlzVlNob3dEaXJlY3RpdmUpKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uIGJlZm9yZU1vdW50ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB1cGRhdGUgPSB0aGlzLl91cGRhdGU7XG4gICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh0aGlzJDEpO1xuICAgICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgICAgdGhpcyQxLl9fcGF0Y2hfXyhcbiAgICAgICAgdGhpcyQxLl92bm9kZSxcbiAgICAgICAgdGhpcyQxLmtlcHQsXG4gICAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgICApO1xuICAgICAgdGhpcyQxLl92bm9kZSA9IHRoaXMkMS5rZXB0O1xuICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICB1cGRhdGUuY2FsbCh0aGlzJDEsIHZub2RlLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdGhpcy5fcmVmbG93ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZS5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZS5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpbkJyb3dzZXIpIHtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICApIHtcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG4gICAgICApO1xuICAgIH1cbiAgfSwgMCk7XG59XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxccj9cXG4pKz8pXFx9XFx9L2c7XG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbnZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG4gIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbn0pO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciByYXdUb2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXgsIHRva2VuVmFsdWU7XG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSk7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgcmF3VG9rZW5zLnB1c2goeyAnQGJpbmRpbmcnOiBleHAgfSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4KSk7XG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcbiAgICB0b2tlbnM6IHJhd1Rva2Vuc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydjbGFzcyddXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGFcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJzdHlsZT1cXFwiXCIgKyBzdGF0aWNTdHlsZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzdHlsZSddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgfVxuXG4gIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKHN0eWxlQmluZGluZykge1xuICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNTdHlsZSkge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNTdHlsZTpcIiArIChlbC5zdGF0aWNTdHlsZSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcInN0eWxlOihcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXCIpLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBzdHlsZSQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQxXG59O1xuXG4vKiAgKi9cblxudmFyIGRlY29kZXI7XG5cbnZhciBoZSA9IHtcbiAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcbiAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcbiAgfVxufTtcblxuLyogICovXG5cbnZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInXG4pO1xuXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cbi8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbnZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXG4pO1xuXG4vLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbnZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSwnICtcbiAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xuICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAndGl0bGUsdHIsdHJhY2snXG4pO1xuXG4vKipcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxuICovXG5cbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xudmFyIGF0dHJpYnV0ZSA9IC9eXFxzKihbXlxcc1wiJzw+XFwvPV0rKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xudmFyIGR5bmFtaWNBcmdBdHRyaWJ1dGUgPSAvXlxccyooKD86di1bXFx3LV0rOnxAfDp8IylcXFtbXj1dK1xcXVteXFxzXCInPD5cXC89XSopKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG52YXIgbmNuYW1lID0gXCJbYS16QS1aX11bXFxcXC1cXFxcLjAtOV9hLXpBLVpcIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIl0qXCI7XG52YXIgcW5hbWVDYXB0dXJlID0gXCIoKD86XCIgKyBuY25hbWUgKyBcIlxcXFw6KT9cIiArIG5jbmFtZSArIFwiKVwiO1xudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoKFwiXjxcIiArIHFuYW1lQ2FwdHVyZSkpO1xudmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKChcIl48XFxcXC9cIiArIHFuYW1lQ2FwdHVyZSArIFwiW14+XSo+XCIpKTtcbnZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG4vLyAjNzI5ODogZXNjYXBlIC0gdG8gYXZvaWQgYmVpbmcgcGFzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXG52YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCcsXG4gICcmIzM5Oyc6IFwiJ1wiXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzkpOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzl8IzEwfCM5KTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSwgaW5kZXgsIGluZGV4ICsgY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhcnRUYWdNYXRjaC50YWdOYW1lLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBhZHZhbmNlKHRleHQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQsIGluZGV4IC0gdGV4dC5sZW5ndGgsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdCQxO1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSwgeyBzdGFydDogaW5kZXggKyBodG1sLmxlbmd0aCB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGR5bmFtaWNBcmdBdHRyaWJ1dGUpIHx8IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgYXR0ci5lbmQgPSBpbmRleDtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGFyZ3Muc3RhcnQgKyBhcmdzWzBdLm1hdGNoKC9eXFxzKi8pLmxlbmd0aDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gYXJncy5lbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMsIHN0YXJ0OiBtYXRjaC5zdGFydCwgZW5kOiBtYXRjaC5lbmQgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKSxcbiAgICAgICAgICAgIHsgc3RhcnQ6IHN0YWNrW2ldLnN0YXJ0LCBlbmQ6IHN0YWNrW2ldLmVuZCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOi87XG52YXIgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbnZhciBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xudmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG52YXIgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XlxcLnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nO1xuXG52YXIgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XG5cbnZhciBsaW5lQnJlYWtSRSA9IC9bXFxyXFxuXS87XG52YXIgd2hpdGVzcGFjZVJFJDEgPSAvXFxzKy9nO1xuXG52YXIgaW52YWxpZEF0dHJpYnV0ZVJFID0gL1tcXHNcIic8PlxcLz1dLztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxudmFyIGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBcIl9lbXB0eV9cIjtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcbnZhciBtYXliZUNvbXBvbmVudDtcblxuZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gIHRhZyxcbiAgYXR0cnMsXG4gIHBhcmVudFxuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMSxcbiAgICB0YWc6IHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBjaGlsZHJlbjogW11cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIG1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgd2hpdGVzcGFjZU9wdGlvbiA9IG9wdGlvbnMud2hpdGVzcGFjZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIixcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxuICAgICAgICAgIC8vIGZpbmQgaXQgYXMgdGhlIHByZXYgbm9kZS5cbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInXG4gICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluYWwgY2hpbGRyZW4gY2xlYW51cFxuICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhKGMpLnNsb3RTY29wZTsgfSk7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZSBhZ2FpblxuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuXG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmltRW5kaW5nV2hpdGVzcGFjZSAoZWwpIHtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlXG4gICAgaWYgKCFpblByZSkge1xuICAgICAgdmFyIGxhc3ROb2RlO1xuICAgICAgd2hpbGUgKFxuICAgICAgICAobGFzdE5vZGUgPSBlbC5jaGlsZHJlbltlbC5jaGlsZHJlbi5sZW5ndGggLSAxXSkgJiZcbiAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxuICAgICAgICBsYXN0Tm9kZS50ZXh0ID09PSAnICdcbiAgICAgICkge1xuICAgICAgICBlbC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nLFxuICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIG91dHB1dFNvdXJjZVJhbmdlOiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnksIHN0YXJ0JDEsIGVuZCkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBlbGVtZW50LnN0YXJ0ID0gc3RhcnQkMTtcbiAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZDtcbiAgICAgICAgICBlbGVtZW50LnJhd0F0dHJzTWFwID0gZWxlbWVudC5hdHRyc0xpc3QucmVkdWNlKGZ1bmN0aW9uIChjdW11bGF0ZWQsIGF0dHIpIHtcbiAgICAgICAgICAgIGN1bXVsYXRlZFthdHRyLm5hbWVdID0gYXR0cjtcbiAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWRcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBkeW5hbWljIGFyZ3VtZW50IGV4cHJlc3Npb246IGF0dHJpYnV0ZSBuYW1lcyBjYW5ub3QgY29udGFpbiBcIiArXG4gICAgICAgICAgICAgIFwic3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5cIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmluZGV4T2YoXCJbXCIpLFxuICAgICAgICAgICAgICAgIGVuZDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLicsXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAodGFnLCBzdGFydCwgZW5kJDEpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBlbGVtZW50LmVuZCA9IGVuZCQxO1xuICAgICAgfVxuICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nLFxuICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKSxcbiAgICAgICAgICAgICAgeyBzdGFydDogc3RhcnQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIGlmIChpblByZSB8fCB0ZXh0LnRyaW0oKSkge1xuICAgICAgICB0ZXh0ID0gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlLW9ubHkgbm9kZSByaWdodCBhZnRlciBhbiBvcGVuaW5nIHRhZ1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VPcHRpb24pIHtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAvLyBpbiBjb25kZW5zZSBtb2RlLCByZW1vdmUgdGhlIHdoaXRlc3BhY2Ugbm9kZSBpZiBpdCBjb250YWluc1xuICAgICAgICAgIC8vIGxpbmUgYnJlYWssIG90aGVyd2lzZSBjb25kZW5zZSB0byBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgIHRleHQgPSBsaW5lQnJlYWtSRS50ZXN0KHRleHQpID8gJycgOiAnICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9ICcgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IHByZXNlcnZlV2hpdGVzcGFjZSA/ICcgJyA6ICcnO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgaWYgKCFpblByZSAmJiB3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gY29uZGVuc2UgY29uc2VjdXRpdmUgd2hpdGVzcGFjZXMgaW50byBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgLy8gYWRkaW5nIGFueXRpbmcgYXMgYSBzaWJsaW5nIHRvIHRoZSByb290IG5vZGUgaXMgZm9yYmlkZGVuXG4gICAgICAvLyBjb21tZW50cyBzaG91bGQgc3RpbGwgYmUgYWxsb3dlZCwgYnV0IGlnbm9yZWRcbiAgICAgIGlmIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHtcbiAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgaXNDb21tZW50OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIGlmIChsZW4pIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBsaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShsaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICAgIGlmIChsaXN0W2ldLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBsaXN0W2ldLnN0YXJ0O1xuICAgICAgICBhdHRyc1tpXS5lbmQgPSBsaXN0W2ldLmVuZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKFxuICBlbGVtZW50LFxuICBvcHRpb25zXG4pIHtcbiAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgZWxlbWVudC5wbGFpbiA9IChcbiAgICAhZWxlbWVudC5rZXkgJiZcbiAgICAhZWxlbWVudC5zY29wZWRTbG90cyAmJlxuICAgICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGhcbiAgKTtcblxuICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdENvbnRlbnQoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90T3V0bGV0KGVsZW1lbnQpO1xuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICB9XG4gIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnRcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIsXG4gICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGVsLmZvcikge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBlbC5pdGVyYXRvcjIgfHwgZWwuaXRlcmF0b3IxO1xuICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgICBpZiAoaXRlcmF0b3IgJiYgaXRlcmF0b3IgPT09IGV4cCAmJiBwYXJlbnQgJiYgcGFyZW50LnRhZyA9PT0gJ3RyYW5zaXRpb24tZ3JvdXAnKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgXCJEbyBub3QgdXNlIHYtZm9yIGluZGV4IGFzIGtleSBvbiA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4sIFwiICtcbiAgICAgICAgICAgIFwidGhpcyBpcyB0aGUgc2FtZSBhcyBub3QgdXNpbmcga2V5cy5cIixcbiAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksXG4gICAgICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VGb3IoZXhwKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICBleHRlbmQoZWwsIHJlcyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbmZ1bmN0aW9uIHBhcnNlRm9yIChleHApIHtcbiAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHJlcy5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xuICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG4gIGlmIChleHApIHtcbiAgICBlbC5pZiA9IGV4cDtcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgZXhwOiBleHAsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQyKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIixcbiAgICAgIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiLFxuICAgICAgICAgIGNoaWxkcmVuW2ldXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBoYW5kbGUgY29udGVudCBiZWluZyBwYXNzZWQgdG8gYSBjb21wb25lbnQgYXMgc2xvdCxcbi8vIGUuZy4gPHRlbXBsYXRlIHNsb3Q9XCJ4eHhcIj4sIDxkaXYgc2xvdC1zY29wZT1cInh4eFwiPlxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RDb250ZW50IChlbCkge1xuICB2YXIgc2xvdFNjb3BlO1xuICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdFNjb3BlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwidGhlIFxcXCJzY29wZVxcXCIgYXR0cmlidXRlIGZvciBzY29wZWQgc2xvdHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYW5kIFwiICtcbiAgICAgICAgXCJyZXBsYWNlZCBieSBcXFwic2xvdC1zY29wZVxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXCJzbG90LXNjb3BlXFxcIiBhdHRyaWJ1dGUgXCIgK1xuICAgICAgICBcImNhbiBhbHNvIGJlIHVzZWQgb24gcGxhaW4gZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gPHRlbXBsYXRlPiB0byBcIiArXG4gICAgICAgIFwiZGVub3RlIHNjb3BlZCBzbG90cy5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Njb3BlJ10sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xuICB9IGVsc2UgaWYgKChzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpKSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiQW1iaWd1b3VzIGNvbWJpbmVkIHVzYWdlIG9mIHNsb3Qtc2NvcGUgYW5kIHYtZm9yIG9uIDxcIiArIChlbC50YWcpICsgXCI+IFwiICtcbiAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICBcInNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICB9XG5cbiAgLy8gc2xvdD1cInh4eFwiXG4gIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gISEoZWwuYXR0cnNNYXBbJzpzbG90J10gfHwgZWwuYXR0cnNNYXBbJ3YtYmluZDpzbG90J10pO1xuICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcbiAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxuICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgYWRkQXR0cihlbCwgJ3Nsb3QnLCBzbG90VGFyZ2V0LCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gMi42IHYtc2xvdCBzeW50YXhcbiAge1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIC8vIHYtc2xvdCBvbiA8dGVtcGxhdGU+XG4gICAgICB2YXIgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChlbC5zbG90VGFyZ2V0IHx8IGVsLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuXCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiPHRlbXBsYXRlIHYtc2xvdD4gY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSByb290IGxldmVsIGluc2lkZSBcIiArXG4gICAgICAgICAgICAgIFwidGhlIHJlY2VpdmluZyB0aGUgY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmcpO1xuICAgICAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuICAgICAgICB2YXIgZHluYW1pYyA9IHJlZi5keW5hbWljO1xuICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90QmluZGluZy52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuOyAvLyBmb3JjZSBpdCBpbnRvIGEgc2NvcGVkIHNsb3QgZm9yIHBlcmZcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdi1zbG90IG9uIGNvbXBvbmVudCwgZGVub3RlcyBkZWZhdWx0IHNsb3RcbiAgICAgIHZhciBzbG90QmluZGluZyQxID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmckMSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwidi1zbG90IGNhbiBvbmx5IGJlIHVzZWQgb24gY29tcG9uZW50cyBvciA8dGVtcGxhdGU+LlwiLFxuICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuc2xvdFNjb3BlIHx8IGVsLnNsb3RUYXJnZXQpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiVG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LCB0aGUgZGVmYXVsdCBzbG90IHNob3VsZCBhbHNvIHVzZSBcIiArXG4gICAgICAgICAgICAgIFwiPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuXCIsXG4gICAgICAgICAgICAgIHNsb3RCaW5kaW5nJDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4gdG8gaXRzIGRlZmF1bHQgc2xvdFxuICAgICAgICB2YXIgc2xvdHMgPSBlbC5zY29wZWRTbG90cyB8fCAoZWwuc2NvcGVkU2xvdHMgPSB7fSk7XG4gICAgICAgIHZhciByZWYkMSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nJDEpO1xuICAgICAgICB2YXIgbmFtZSQxID0gcmVmJDEubmFtZTtcbiAgICAgICAgdmFyIGR5bmFtaWMkMSA9IHJlZiQxLmR5bmFtaWM7XG4gICAgICAgIHZhciBzbG90Q29udGFpbmVyID0gc2xvdHNbbmFtZSQxXSA9IGNyZWF0ZUFTVEVsZW1lbnQoJ3RlbXBsYXRlJywgW10sIGVsKTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0ID0gbmFtZSQxO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYyQxO1xuICAgICAgICBzbG90Q29udGFpbmVyLmNoaWxkcmVuID0gZWwuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgaWYgKCFjLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nJDEudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjtcbiAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XG4gICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIG1hcmsgZWwgbm9uLXBsYWluIHNvIGRhdGEgZ2V0cyBnZW5lcmF0ZWRcbiAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2xvdE5hbWUgKGJpbmRpbmcpIHtcbiAgdmFyIG5hbWUgPSBiaW5kaW5nLm5hbWUucmVwbGFjZShzbG90UkUsICcnKTtcbiAgaWYgKCFuYW1lKSB7XG4gICAgaWYgKGJpbmRpbmcubmFtZVswXSAhPT0gJyMnKSB7XG4gICAgICBuYW1lID0gJ2RlZmF1bHQnO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcInYtc2xvdCBzaG9ydGhhbmQgc3ludGF4IHJlcXVpcmVzIGEgc2xvdCBuYW1lLlwiLFxuICAgICAgICBiaW5kaW5nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSlcbiAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgID8geyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XG4gICAgLy8gc3RhdGljIG5hbWVcbiAgICA6IHsgbmFtZTogKFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSwgZHluYW1pYzogZmFsc2UgfVxufVxuXG4vLyBoYW5kbGUgPHNsb3QvPiBvdXRsZXRzXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCIsXG4gICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIHN5bmNHZW4sIGlzRHluYW1pYztcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lLnJlcGxhY2UoZGlyUkUsICcnKSk7XG4gICAgICAvLyBzdXBwb3J0IC5mb28gc2hvcnRoYW5kIHN5bnRheCBmb3IgdGhlIC5wcm9wIG1vZGlmaWVyXG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAoXCJUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcXFwidi1iaW5kOlwiICsgbmFtZSArIFwiXFxcIlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIHN5bmNHZW4gPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIik7XG4gICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoaHlwaGVuYXRlKG5hbWUpICE9PSBjYW1lbGl6ZShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChoeXBoZW5hdGUobmFtZSkpKSxcbiAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlciB3LyBkeW5hbWljIGV2ZW50IG5hbWVcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAoXCJcXFwidXBkYXRlOlxcXCIrKFwiICsgbmFtZSArIFwiKVwiKSxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV0sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvLyBkeW5hbWljXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaXNEeW5hbWljID0gZmFsc2U7XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgICAgaWYgKGR5bmFtaWNBcmdSRS50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICBpc0R5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIGlzRHluYW1pYywgbW9kaWZpZXJzLCBsaXN0W2ldKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLFxuICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgbGlzdFtpXSk7XG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScsIGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgdmFyIG1hcCA9IGVsLmF0dHJzTWFwO1xuICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciB0eXBlQmluZGluZztcbiAgICBpZiAobWFwWyc6dHlwZSddIHx8IG1hcFsndi1iaW5kOnR5cGUnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcbiAgICB9XG4gICAgaWYgKCFtYXAudHlwZSAmJiAhdHlwZUJpbmRpbmcgJiYgbWFwWyd2LWJpbmQnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBcIihcIiArIChtYXBbJ3YtYmluZCddKSArIFwiKS50eXBlXCI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgfSk7XG4gICAgICAvLyAzLiBvdGhlclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDEsXG4gIG1vZGVsJDFcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpLCBkaXIpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn07XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzLHN0YXJ0LGVuZCxyYXdBdHRyc01hcCcgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqKD86W1xcdyRdKyk/XFxzKlxcKC87XG52YXIgZm5JbnZva2VSRSA9IC9cXChbXildKj9cXCk7KiQvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleSBhbGlhc2VzXG52YXIga2V5TmFtZXMgPSB7XG4gIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxuICBlc2M6IFsnRXNjJywgJ0VzY2FwZSddLFxuICB0YWI6ICdUYWInLFxuICBlbnRlcjogJ0VudGVyJyxcbiAgLy8gIzkxMTI6IElFMTEgdXNlcyBgU3BhY2ViYXJgIGZvciBTcGFjZSBrZXkgbmFtZS5cbiAgc3BhY2U6IFsnICcsICdTcGFjZWJhciddLFxuICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICB1cDogWydVcCcsICdBcnJvd1VwJ10sXG4gIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICBkb3duOiBbJ0Rvd24nLCAnQXJyb3dEb3duJ10sXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYERlbGAgZm9yIERlbGV0ZSBrZXkgbmFtZS5cbiAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnXVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlXG4pIHtcbiAgdmFyIHByZWZpeCA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOicgOiAnb246JztcbiAgdmFyIHN0YXRpY0hhbmRsZXJzID0gXCJcIjtcbiAgdmFyIGR5bmFtaWNIYW5kbGVycyA9IFwiXCI7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV0pO1xuICAgIGlmIChldmVudHNbbmFtZV0gJiYgZXZlbnRzW25hbWVdLmR5bmFtaWMpIHtcbiAgICAgIGR5bmFtaWNIYW5kbGVycyArPSBuYW1lICsgXCIsXCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNIYW5kbGVycyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBzdGF0aWNIYW5kbGVycyA9IFwie1wiICsgKHN0YXRpY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgaWYgKGR5bmFtaWNIYW5kbGVycykge1xuICAgIHJldHVybiBwcmVmaXggKyBcIl9kKFwiICsgc3RhdGljSGFuZGxlcnMgKyBcIixbXCIgKyAoZHluYW1pY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIl0pXCJcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlZml4ICsgc3RhdGljSGFuZGxlcnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChoYW5kbGVyKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25JbnZvY2F0aW9uID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZS5yZXBsYWNlKGZuSW52b2tlUkUsICcnKSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXG4gICAgfVxuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKSA6IGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gKGhhbmRsZXIubW9kaWZpZXJzKTtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl07IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKCRldmVudClcIilcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCJyZXR1cm4gKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpKCRldmVudClcIilcbiAgICAgICAgOiBpc0Z1bmN0aW9uSW52b2NhdGlvblxuICAgICAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKVxuICAgICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFxuICAgIC8vIG1ha2Ugc3VyZSB0aGUga2V5IGZpbHRlcnMgb25seSBhcHBseSB0byBLZXlib2FyZEV2ZW50c1xuICAgIC8vICM5NDQxOiBjYW4ndCB1c2UgJ2tleUNvZGUnIGluICRldmVudCBiZWNhdXNlIENocm9tZSBhdXRvZmlsbCBmaXJlcyBmYWtlXG4gICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cbiAgICBcImlmKCEkZXZlbnQudHlwZS5pbmRleE9mKCdrZXknKSYmXCIgK1xuICAgIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiXG4gIClcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBrZXlDb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xuICByZXR1cm4gKFxuICAgIFwiX2soJGV2ZW50LmtleUNvZGUsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5Q29kZSkpICsgXCIsXCIgK1xuICAgIFwiJGV2ZW50LmtleSxcIiArXG4gICAgXCJcIiArIChKU09OLnN0cmluZ2lmeShrZXlOYW1lKSkgK1xuICAgIFwiKVwiXG4gIClcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG9uIChlbCwgZGlyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgfVxuICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcIl9nKFwiICsgY29kZSArIFwiLFwiICsgKGRpci52YWx1ZSkgKyBcIilcIik7IH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgb246IG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuXG5cblxuXG52YXIgQ29kZWdlblN0YXRlID0gZnVuY3Rpb24gQ29kZWdlblN0YXRlIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICB0aGlzLm9uY2VJZCA9IDA7XG4gIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG4gIHRoaXMucHJlID0gZmFsc2U7XG59O1xuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJkaXZcIiknO1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwsIHN0YXRlKSB7XG4gIGlmIChlbC5wYXJlbnQpIHtcbiAgICBlbC5wcmUgPSBlbC5wcmUgfHwgZWwucGFyZW50LnByZTtcbiAgfVxuXG4gIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQgJiYgIXN0YXRlLnByZSkge1xuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB2YXIgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGE7XG4gICAgICBpZiAoIWVsLnBsYWluIHx8IChlbC5wcmUgJiYgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpKSkge1xuICAgICAgICBkYXRhID0gZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsLCBzdGF0ZSkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICAvLyBTb21lIGVsZW1lbnRzICh0ZW1wbGF0ZXMpIG5lZWQgdG8gYmVoYXZlIGRpZmZlcmVudGx5IGluc2lkZSBvZiBhIHYtcHJlXG4gIC8vIG5vZGUuICBBbGwgcHJlIG5vZGVzIGFyZSBzdGF0aWMgcm9vdHMsIHNvIHdlIGNhbiB1c2UgdGhpcyBhcyBhIGxvY2F0aW9uIHRvXG4gIC8vIHdyYXAgYSBzdGF0ZSBjaGFuZ2UgYW5kIHJlc2V0IGl0IHVwb24gZXhpdGluZyB0aGUgcHJlIG5vZGUuXG4gIHZhciBvcmlnaW5hbFByZVN0YXRlID0gc3RhdGUucHJlO1xuICBpZiAoZWwucHJlKSB7XG4gICAgc3RhdGUucHJlID0gZWwucHJlO1xuICB9XG4gIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIikpO1xuICBzdGF0ZS5wcmUgPSBvcmlnaW5hbFByZVN0YXRlO1xuICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGUud2FybihcbiAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW9uY2UnXVxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICB9XG4gICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIixcIiArIChzdGF0ZS5vbmNlSWQrKykgKyBcIixcIiArIGtleSArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoXG4gIGNvbmRpdGlvbnMsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgfVxuXG4gIHZhciBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XG4gIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgcmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGFsdEdlblxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxuICAgICAgOiBlbC5vbmNlXG4gICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEhlbHBlclxuKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxuICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgIWVsLmtleVxuICApIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddLFxuICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICApO1xuICB9XG5cbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiAoYWx0SGVscGVyIHx8ICdfbCcpICsgXCIoKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoKGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDIgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGF0YSA9ICd7JztcblxuICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gc3RhdGUuZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IFwiYXR0cnM6XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwiLFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwiLFwiO1xuICB9XG4gIC8vIGV2ZW50IGhhbmRsZXJzXG4gIGlmIChlbC5ldmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbCwgZWwuc2NvcGVkU2xvdHMsIHN0YXRlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZHluYW1pYyBhcmd1bWVudCB3cmFwXG4gIC8vIHYtYmluZCB3aXRoIGR5bmFtaWMgYXJndW1lbnRzIG11c3QgYmUgYXBwbGllZCB1c2luZyB0aGUgc2FtZSB2LWJpbmQgb2JqZWN0XG4gIC8vIG1lcmdlIGhlbHBlciBzbyB0aGF0IGNsYXNzL3N0eWxlL211c3RVc2VQcm9wIGF0dHJzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cbiAgaWYgKGVsLmR5bmFtaWNBdHRycykge1xuICAgIGRhdGEgPSBcIl9iKFwiICsgZGF0YSArIFwiLFxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiICsgKGdlblByb3BzKGVsLmR5bmFtaWNBdHRycykpICsgXCIpXCI7XG4gIH1cbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgLy8gdi1vbiBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgdmFyIGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XCIgKyAoZGlyLmlzRHluYW1pY0FyZyA/IGRpci5hcmcgOiAoXCJcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikpKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUnVudGltZSkge1xuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUgKGVsLCBzdGF0ZSkge1xuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDFcbiAgKSkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICAnSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyxcbiAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICApO1xuICB9XG4gIGlmIChhc3QgJiYgYXN0LnR5cGUgPT09IDEpIHtcbiAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBzdGF0ZS5vcHRpb25zKTtcbiAgICByZXR1cm4gKFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiICsgKGlubGluZVJlbmRlckZucy5yZW5kZXIpICsgXCJ9LHN0YXRpY1JlbmRlckZuczpbXCIgKyAoaW5saW5lUmVuZGVyRm5zLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcImZ1bmN0aW9uKCl7XCIgKyBjb2RlICsgXCJ9XCIpOyB9KS5qb2luKCcsJykpICsgXCJdfVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChcbiAgZWwsXG4gIHNsb3RzLFxuICBzdGF0ZVxuKSB7XG4gIC8vIGJ5IGRlZmF1bHQgc2NvcGVkIHNsb3RzIGFyZSBjb25zaWRlcmVkIFwic3RhYmxlXCIsIHRoaXMgYWxsb3dzIGNoaWxkXG4gIC8vIGNvbXBvbmVudHMgd2l0aCBvbmx5IHNjb3BlZCBzbG90cyB0byBza2lwIGZvcmNlZCB1cGRhdGVzIGZyb20gcGFyZW50LlxuICAvLyBidXQgaW4gc29tZSBjYXNlcyB3ZSBoYXZlIHRvIGJhaWwtb3V0IG9mIHRoaXMgb3B0aW1pemF0aW9uXG4gIC8vIGZvciBleGFtcGxlIGlmIHRoZSBzbG90IGNvbnRhaW5zIGR5bmFtaWMgbmFtZXMsIGhhcyB2LWlmIG9yIHYtZm9yIG9uIHRoZW0uLi5cbiAgdmFyIG5lZWRzRm9yY2VVcGRhdGUgPSBlbC5mb3IgfHwgT2JqZWN0LmtleXMoc2xvdHMpLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBzbG90ID0gc2xvdHNba2V5XTtcbiAgICByZXR1cm4gKFxuICAgICAgc2xvdC5zbG90VGFyZ2V0RHluYW1pYyB8fFxuICAgICAgc2xvdC5pZiB8fFxuICAgICAgc2xvdC5mb3IgfHxcbiAgICAgIGNvbnRhaW5zU2xvdENoaWxkKHNsb3QpIC8vIGlzIHBhc3NpbmcgZG93biBzbG90IGZyb20gcGFyZW50IHdoaWNoIG1heSBiZSBkeW5hbWljXG4gICAgKVxuICB9KTtcblxuICAvLyAjOTUzNDogaWYgYSBjb21wb25lbnQgd2l0aCBzY29wZWQgc2xvdHMgaXMgaW5zaWRlIGEgY29uZGl0aW9uYWwgYnJhbmNoLFxuICAvLyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgc2FtZSBjb21wb25lbnQgdG8gYmUgcmV1c2VkIGJ1dCB3aXRoIGRpZmZlcmVudFxuICAvLyBjb21waWxlZCBzbG90IGNvbnRlbnQuIFRvIGF2b2lkIHRoYXQsIHdlIGdlbmVyYXRlIGEgdW5pcXVlIGtleSBiYXNlZCBvblxuICAvLyB0aGUgZ2VuZXJhdGVkIGNvZGUgb2YgYWxsIHRoZSBzbG90IGNvbnRlbnRzLlxuICB2YXIgbmVlZHNLZXkgPSAhIWVsLmlmO1xuXG4gIC8vIE9SIHdoZW4gaXQgaXMgaW5zaWRlIGFub3RoZXIgc2NvcGVkIHNsb3Qgb3Igdi1mb3IgKHRoZSByZWFjdGl2aXR5IG1heSBiZVxuICAvLyBkaXNjb25uZWN0ZWQgZHVlIHRvIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgdmFyaWFibGUpXG4gIC8vICM5NDM4LCAjOTUwNlxuICAvLyBUT0RPOiB0aGlzIGNhbiBiZSBmdXJ0aGVyIG9wdGltaXplZCBieSBwcm9wZXJseSBhbmFseXppbmcgaW4tc2NvcGUgYmluZGluZ3NcbiAgLy8gYW5kIHNraXAgZm9yY2UgdXBkYXRpbmcgb25lcyB0aGF0IGRvIG5vdCBhY3R1YWxseSB1c2Ugc2NvcGUgdmFyaWFibGVzLlxuICBpZiAoIW5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKHBhcmVudC5zbG90U2NvcGUgJiYgcGFyZW50LnNsb3RTY29wZSAhPT0gZW1wdHlTbG90U2NvcGVUb2tlbikgfHxcbiAgICAgICAgcGFyZW50LmZvclxuICAgICAgKSB7XG4gICAgICAgIG5lZWRzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudC5pZikge1xuICAgICAgICBuZWVkc0tleSA9IHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHZhciBnZW5lcmF0ZWRTbG90cyA9IE9iamVjdC5rZXlzKHNsb3RzKVxuICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZ2VuU2NvcGVkU2xvdChzbG90c1trZXldLCBzdGF0ZSk7IH0pXG4gICAgLmpvaW4oJywnKTtcblxuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgZ2VuZXJhdGVkU2xvdHMgKyBcIl1cIiArIChuZWVkc0ZvcmNlVXBkYXRlID8gXCIsbnVsbCx0cnVlXCIgOiBcIlwiKSArICghbmVlZHNGb3JjZVVwZGF0ZSAmJiBuZWVkc0tleSA/IChcIixudWxsLGZhbHNlLFwiICsgKGhhc2goZ2VuZXJhdGVkU2xvdHMpKSkgOiBcIlwiKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICB2YXIgaGFzaCA9IDUzODE7XG4gIHZhciBpID0gc3RyLmxlbmd0aDtcbiAgd2hpbGUoaSkge1xuICAgIGhhc2ggPSAoaGFzaCAqIDMzKSBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XG4gIH1cbiAgcmV0dXJuIGhhc2ggPj4+IDBcbn1cblxuZnVuY3Rpb24gY29udGFpbnNTbG90Q2hpbGQgKGVsKSB7XG4gIGlmIChlbC50eXBlID09PSAxKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZWwuY2hpbGRyZW4uc29tZShjb250YWluc1Nsb3RDaGlsZClcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBpc0xlZ2FjeVN5bnRheCA9IGVsLmF0dHJzTWFwWydzbG90LXNjb3BlJ107XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQgJiYgIWlzTGVnYWN5U3ludGF4KSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdCwgXCJudWxsXCIpXG4gIH1cbiAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QpXG4gIH1cbiAgdmFyIHNsb3RTY29wZSA9IGVsLnNsb3RTY29wZSA9PT0gZW1wdHlTbG90U2NvcGVUb2tlblxuICAgID8gXCJcIlxuICAgIDogU3RyaW5nKGVsLnNsb3RTY29wZSk7XG4gIHZhciBmbiA9IFwiZnVuY3Rpb24oXCIgKyBzbG90U2NvcGUgKyBcIil7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBlbC5pZiAmJiBpc0xlZ2FjeVN5bnRheFxuICAgICAgICA/IChcIihcIiArIChlbC5pZikgKyBcIik/XCIgKyAoZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJykgKyBcIjp1bmRlZmluZWRcIilcbiAgICAgICAgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnXG4gICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIjtcbiAgLy8gcmV2ZXJzZSBwcm94eSB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICB2YXIgcmV2ZXJzZVByb3h5ID0gc2xvdFNjb3BlID8gXCJcIiA6IFwiLHByb3h5OnRydWVcIjtcbiAgcmV0dXJuIChcIntrZXk6XCIgKyAoZWwuc2xvdFRhcmdldCB8fCBcIlxcXCJkZWZhdWx0XFxcIlwiKSArIFwiLGZuOlwiICsgZm4gKyByZXZlcnNlUHJveHkgKyBcIn1cIilcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxuICBlbCxcbiAgc3RhdGUsXG4gIGNoZWNrU2tpcCxcbiAgYWx0R2VuRWxlbWVudCxcbiAgYWx0R2VuTm9kZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBlbCQxLmZvciAmJlxuICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcbiAgICApIHtcbiAgICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgICA/IHN0YXRlLm1heWJlQ29tcG9uZW50KGVsJDEpID8gXCIsMVwiIDogXCIsMFwiXG4gICAgICAgIDogXCJcIjtcbiAgICAgIHJldHVybiAoXCJcIiArICgoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbCQxLCBzdGF0ZSkpICsgbm9ybWFsaXphdGlvblR5cGUpXG4gICAgfVxuICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSQxID0gY2hlY2tTa2lwXG4gICAgICA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuLCBzdGF0ZS5tYXliZUNvbXBvbmVudClcbiAgICAgIDogMDtcbiAgICB2YXIgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBnZW4oYywgc3RhdGUpOyB9KS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUkMSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlJDEpIDogJycpKVxuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gIGNoaWxkcmVuLFxuICBtYXliZUNvbXBvbmVudFxuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlLCBzdGF0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XG4gICAgcmV0dXJuIGdlbkNvbW1lbnQobm9kZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuQ29tbWVudCAoY29tbWVudCkge1xuICByZXR1cm4gKFwiX2UoXCIgKyAoSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzIHx8IGVsLmR5bmFtaWNBdHRyc1xuICAgID8gZ2VuUHJvcHMoKGVsLmF0dHJzIHx8IFtdKS5jb25jYXQoZWwuZHluYW1pY0F0dHJzIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuICh7XG4gICAgICAgIC8vIHNsb3QgcHJvcHMgYXJlIGNhbWVsaXplZFxuICAgICAgICBuYW1lOiBjYW1lbGl6ZShhdHRyLm5hbWUpLFxuICAgICAgICB2YWx1ZTogYXR0ci52YWx1ZSxcbiAgICAgICAgZHluYW1pYzogYXR0ci5keW5hbWljXG4gICAgICB9KTsgfSkpXG4gICAgOiBudWxsO1xuICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICByZXMgKz0gXCIsbnVsbFwiO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBcIixcIiArIGF0dHJzO1xuICB9XG4gIGlmIChiaW5kJCQxKSB7XG4gICAgcmVzICs9IChhdHRycyA/ICcnIDogJyxudWxsJykgKyBcIixcIiArIGJpbmQkJDE7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICBjb21wb25lbnROYW1lLFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YSQyKGVsLCBzdGF0ZSkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgc3RhdGljUHJvcHMgPSBcIlwiO1xuICB2YXIgZHluYW1pY1Byb3BzID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgdmFyIHZhbHVlID0gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpO1xuICAgIGlmIChwcm9wLmR5bmFtaWMpIHtcbiAgICAgIGR5bmFtaWNQcm9wcyArPSAocHJvcC5uYW1lKSArIFwiLFwiICsgdmFsdWUgKyBcIixcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGljUHJvcHMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArIHZhbHVlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIHN0YXRpY1Byb3BzID0gXCJ7XCIgKyAoc3RhdGljUHJvcHMuc2xpY2UoMCwgLTEpKSArIFwifVwiO1xuICBpZiAoZHluYW1pY1Byb3BzKSB7XG4gICAgcmV0dXJuIChcIl9kKFwiICsgc3RhdGljUHJvcHMgKyBcIixbXCIgKyAoZHluYW1pY1Byb3BzLnNsaWNlKDAsIC0xKSkgKyBcIl0pXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRpY1Byb3BzXG4gIH1cbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cblxuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QsIHdhcm4pIHtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIHdhcm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgd2Fybikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBub2RlLnJhd0F0dHJzTWFwW25hbWVdO1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCB3YXJuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCB3YXJuLCBub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgd2FybihcbiAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIHdhcm4sIHJhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoXG4gIGlkZW50LFxuICB0eXBlLFxuICB0ZXh0LFxuICB3YXJuLFxuICByYW5nZVxuKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbigoXCJ2YXIgXCIgKyBpZGVudCArIFwiPV9cIikpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpLCByYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiXFxuICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpLFxuICAgICAgICByYW5nZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgICAgXCIgIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkgKyBcIlxcblwiLFxuICAgICAgICByYW5nZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciByYW5nZSA9IDI7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lIChcbiAgc291cmNlLFxuICBzdGFydCxcbiAgZW5kXG4pIHtcbiAgaWYgKCBzdGFydCA9PT0gdm9pZCAwICkgc3RhcnQgPSAwO1xuICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gc291cmNlLmxlbmd0aDtcblxuICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAodmFyIGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgcmVzLnB1c2goKFwiXCIgKyAoaiArIDEpICsgKHJlcGVhdCQxKFwiIFwiLCAzIC0gU3RyaW5nKGogKyAxKS5sZW5ndGgpKSArIFwifCAgXCIgKyAobGluZXNbal0pKSk7XG4gICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXG4gICAgICAgICAgdmFyIHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydDtcbiAgICAgICAgICByZXMucHVzaChcIiAgIHwgIFwiICsgcmVwZWF0JDEoXCIgXCIsIHBhZCkgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGgkMSA9IE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoJDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuam9pbignXFxuJylcbn1cblxuZnVuY3Rpb24gcmVwZWF0JDEgKHN0ciwgbikge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmIChuID4gMCkge1xuICAgIHdoaWxlICh0cnVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGlmIChuICYgMSkgeyByZXN1bHQgKz0gc3RyOyB9XG4gICAgICBuID4+Pj0gMTtcbiAgICAgIGlmIChuIDw9IDApIHsgYnJlYWsgfVxuICAgICAgc3RyICs9IHN0cjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIChjb21waWxlKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICB2YXIgd2FybiQkMSA9IG9wdGlvbnMud2FybiB8fCB3YXJuO1xuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyAoZS5tc2cpICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlLnN0YXJ0LCBlLmVuZCksXG4gICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aXAoZS5tc2csIHZtKTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybiQkMShcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBjb21waWxlIChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIHRpcHMgPSBbXTtcblxuICAgICAgdmFyIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgdmFyIGxlYWRpbmdTcGFjZUxlbmd0aCA9IHRlbXBsYXRlLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcblxuICAgICAgICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHsgbXNnOiBtc2cgfTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuc3RhcnQgPSByYW5nZS5zdGFydCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVuZCA9IHJhbmdlLmVuZCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2goZGF0YSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyB8fCBudWxsKSxcbiAgICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSB3YXJuO1xuXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0LCB3YXJuKTtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgcmV0dXJuIGNvbXBpbGVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGBjcmVhdGVDb21waWxlckNyZWF0b3JgIGFsbG93cyBjcmVhdGluZyBjb21waWxlcnMgdGhhdCB1c2UgYWx0ZXJuYXRpdmVcbi8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxudmFyIGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgfVxuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGUgPSByZWYkMS5jb21waWxlO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG52YXIgZGl2O1xuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBcIjxhIGhyZWY9XFxcIlxcblxcXCIvPlwiIDogXCI8ZGl2IGE9XFxcIlxcblxcXCIvPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxufVxuXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xuLy8gIzY4Mjg6IGNocm9tZSBlbmNvZGVzIGNvbnRlbnQgaW4gYVtocmVmXVxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZSh0cnVlKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcbiAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi9jb3JlXCIsXG5cdFwiLi9jb3JlL2FjY2Vzc1wiLFxuXHRcIi4vY29yZS9jYW1lbENhc2VcIixcblx0XCIuL2RhdGEvdmFyL2RhdGFQcml2XCIsXG5cdFwiLi9kYXRhL3Zhci9kYXRhVXNlclwiXG5dLCBmdW5jdGlvbiggalF1ZXJ5LCBhY2Nlc3MsIGNhbWVsQ2FzZSwgZGF0YVByaXYsIGRhdGFVc2VyICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiIsImRlZmluZSggZnVuY3Rpb24oKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBBIG1ldGhvZCBmb3IgcXVpY2tseSBzd2FwcGluZyBpbi9vdXQgQ1NTIHByb3BlcnRpZXMgdG8gZ2V0IGNvcnJlY3QgY2FsY3VsYXRpb25zLlxucmV0dXJuIGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi9jb3JlXCIsXG5cdFwiLi4vY29yZS9hY2Nlc3NcIixcblx0XCIuLi9jb3JlL25vZGVOYW1lXCIsXG5cdFwiLi9zdXBwb3J0XCIsXG5cdFwiLi4vdmFyL3Jub3RodG1sd2hpdGVcIixcblx0XCIuLi9zZWxlY3RvclwiXG5dLCBmdW5jdGlvbiggalF1ZXJ5LCBhY2Nlc3MsIG5vZGVOYW1lLCBzdXBwb3J0LCBybm90aHRtbHdoaXRlICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vY29yZVwiLFxuXHRcIi4uL3Zhci9yY3NzTnVtXCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnksIHJjc3NOdW0gKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsIHNjYWxlLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0XHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG5cdFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuXHRcdFx0Ly8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cblx0XHRcdC8vIEZpbmlzaCBpZiB0aGUgc2NhbGUgZXF1YWxzIG9yIGNyb3NzZXMgMSAobWFraW5nIHRoZSBvbGQqbmV3IHByb2R1Y3Qgbm9uLXBvc2l0aXZlKS5cblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblx0XHRcdGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMDtcblx0XHRcdH1cblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cblx0XHR9XG5cblx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG5cdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxucmV0dXJuIGFkanVzdENTUztcbn0gKTtcbiIsImRlZmluZSggW1xuXHRcIi4uL2NvcmVcIixcblx0XCIuLi9jb3JlL25vZGVOYW1lXCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnksIG5vZGVOYW1lICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5yZXR1cm4gZ2V0QWxsO1xufSApO1xuIiwiZGVmaW5lKCBmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuICAgICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG4gICAgICAvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiO1xuICB9O1xuXG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi9jb3JlXCIsXG5cdFwiLi4vY3NzXCJcbl0sIGZ1bmN0aW9uKCBqUXVlcnkgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vY29yZVwiXG5dLCBmdW5jdGlvbiggalF1ZXJ5ICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cbn0gKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZSh1cmwsIG5lZWRRdW90ZXMpIHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfSAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cblxuXG4gIGlmICgvXlsnXCJdLipbJ1wiXSQvLnRlc3QodXJsKSkge1xuICAgIHVybCA9IHVybC5zbGljZSgxLCAtMSk7XG4gIH0gLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuXG5cbiAgaWYgKC9bXCInKCkgXFx0XFxuXS8udGVzdCh1cmwpIHx8IG5lZWRRdW90ZXMpIHtcbiAgICByZXR1cm4gJ1wiJyArIHVybC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpICsgJ1wiJztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59OyIsImRlZmluZSggW1xuXHRcIi4vY29yZVwiLFxuXHRcIi4uL2V4dGVybmFsL3NpenpsZS9kaXN0L3NpenpsZVwiXG5dLCBmdW5jdGlvbiggalF1ZXJ5LCBTaXp6bGUgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi9kb2N1bWVudFwiXG5dLCBmdW5jdGlvbiggZG9jdW1lbnQgKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuL2NvcmVcIixcblx0XCIuL2NvcmUvY2FtZWxDYXNlXCIsXG5cdFwiLi92YXIvZG9jdW1lbnRcIixcblx0XCIuL3Zhci9pc0Z1bmN0aW9uXCIsXG5cdFwiLi92YXIvcmNzc051bVwiLFxuXHRcIi4vdmFyL3Jub3RodG1sd2hpdGVcIixcblx0XCIuL2Nzcy92YXIvY3NzRXhwYW5kXCIsXG5cdFwiLi9jc3MvdmFyL2lzSGlkZGVuV2l0aGluVHJlZVwiLFxuXHRcIi4vY3NzL3Zhci9zd2FwXCIsXG5cdFwiLi9jc3MvYWRqdXN0Q1NTXCIsXG5cdFwiLi9kYXRhL3Zhci9kYXRhUHJpdlwiLFxuXHRcIi4vY3NzL3Nob3dIaWRlXCIsXG5cblx0XCIuL2NvcmUvaW5pdFwiLFxuXHRcIi4vcXVldWVcIixcblx0XCIuL2RlZmVycmVkXCIsXG5cdFwiLi90cmF2ZXJzaW5nXCIsXG5cdFwiLi9tYW5pcHVsYXRpb25cIixcblx0XCIuL2Nzc1wiLFxuXHRcIi4vZWZmZWN0cy9Ud2VlblwiXG5dLCBmdW5jdGlvbiggalF1ZXJ5LCBjYW1lbENhc2UsIGRvY3VtZW50LCBpc0Z1bmN0aW9uLCByY3NzTnVtLCBybm90aHRtbHdoaXRlLCBjc3NFeHBhbmQsXG5cdGlzSGlkZGVuV2l0aGluVHJlZSwgc3dhcCwgYWRqdXN0Q1NTLCBkYXRhUHJpdiwgc2hvd0hpZGUgKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0gRGF0ZS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vY29yZVwiLFxuXHRcIi4uL3Zhci9kb2N1bWVudFwiLFxuXHRcIi4uL2NvcmUvcmVhZHlFeGNlcHRpb25cIixcblx0XCIuLi9kZWZlcnJlZFwiXG5dLCBmdW5jdGlvbiggalF1ZXJ5LCBkb2N1bWVudCApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cbn0gKTtcbiIsImRlZmluZSggW1xuXHRcIi4uL2NvcmVcIixcblx0XCIuLi9zZWxlY3RvclwiLFxuXHRcIi4uL2VmZmVjdHNcIlxuXSwgZnVuY3Rpb24oIGpRdWVyeSApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi9jb3JlXCIsXG5cdFwiLi4vY29yZS9zdHJpcEFuZENvbGxhcHNlXCIsXG5cdFwiLi9zdXBwb3J0XCIsXG5cdFwiLi4vY29yZS9ub2RlTmFtZVwiLFxuXHRcIi4uL3Zhci9pc0Z1bmN0aW9uXCIsXG5cblx0XCIuLi9jb3JlL2luaXRcIlxuXSwgZnVuY3Rpb24oIGpRdWVyeSwgc3RyaXBBbmRDb2xsYXBzZSwgc3VwcG9ydCwgbm9kZU5hbWUsIGlzRnVuY3Rpb24gKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuL2NvcmVcIixcblx0XCIuL3Zhci9pbmRleE9mXCIsXG5cdFwiLi90cmF2ZXJzaW5nL3Zhci9kaXJcIixcblx0XCIuL3RyYXZlcnNpbmcvdmFyL3NpYmxpbmdzXCIsXG5cdFwiLi90cmF2ZXJzaW5nL3Zhci9ybmVlZHNDb250ZXh0XCIsXG5cdFwiLi9jb3JlL25vZGVOYW1lXCIsXG5cblx0XCIuL2NvcmUvaW5pdFwiLFxuXHRcIi4vdHJhdmVyc2luZy9maW5kRmlsdGVyXCIsXG5cdFwiLi9zZWxlY3RvclwiXG5dLCBmdW5jdGlvbiggalF1ZXJ5LCBpbmRleE9mLCBkaXIsIHNpYmxpbmdzLCBybmVlZHNDb250ZXh0LCBub2RlTmFtZSApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcImlmcmFtZVwiICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcbiAgICAgICAgLy8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG4gICAgICAgIC8vIGRvbid0IHN1cHBvcnQgaXQuXG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiZGVmaW5lKCBmdW5jdGlvbigpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxucmV0dXJuIHdyYXBNYXA7XG59ICk7XG4iLCJkZWZpbmUoIFtcblx0XCIuLi8uLi92YXIvcG51bVwiXG5dLCBmdW5jdGlvbiggcG51bSApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0cmV0dXJuIG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xufSApO1xuIiwiZGVmaW5lKCBmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0cmV0dXJuIFtdO1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi9jb3JlXCIsXG5cdFwiLi9jb3JlL3RvVHlwZVwiLFxuXHRcIi4vbWFuaXB1bGF0aW9uL3Zhci9yY2hlY2thYmxlVHlwZVwiLFxuXHRcIi4vdmFyL2lzRnVuY3Rpb25cIixcblx0XCIuL2NvcmUvaW5pdFwiLFxuXHRcIi4vdHJhdmVyc2luZ1wiLCAvLyBmaWx0ZXJcblx0XCIuL2F0dHJpYnV0ZXMvcHJvcFwiXG5dLCBmdW5jdGlvbiggalF1ZXJ5LCB0b1R5cGUsIHJjaGVja2FibGVUeXBlLCBpc0Z1bmN0aW9uICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vY29yZVwiLFxuXHRcIi4uL2RhdGEvdmFyL2RhdGFQcml2XCIsXG5cdFwiLi4vY3NzL3Zhci9pc0hpZGRlbldpdGhpblRyZWVcIlxuXSwgZnVuY3Rpb24oIGpRdWVyeSwgZGF0YVByaXYsIGlzSGlkZGVuV2l0aGluVHJlZSApIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxucmV0dXJuIHNob3dIaWRlO1xufSApO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi9hcnJcIlxuXSwgZnVuY3Rpb24oIGFyciApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0cmV0dXJuIGFyci5wdXNoO1xufSApO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwiZGVmaW5lKCBbXG5cdFwiLi4vdmFyL2RvY3VtZW50XCIsXG5cdFwiLi4vdmFyL3N1cHBvcnRcIlxuXSwgZnVuY3Rpb24oIGRvY3VtZW50LCBzdXBwb3J0ICkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cbnJldHVybiBzdXBwb3J0O1xufSApO1xuIiwiZGVmaW5lKCBmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0cmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbn0gKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=